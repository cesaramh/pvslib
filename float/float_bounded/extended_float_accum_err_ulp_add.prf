(extended_float_accum_err_ulp_add
 (IMP_accum_err_add_TCC1 0
  (IMP_accum_err_add_TCC1-1 nil 3876289711
   ("" (use "roundp_is_even_closest") nil nil)
   ((dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_accum_err_ulp_add nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_accum_err_ulp_add nil)
    (radix formal-const-decl "above(1)"
           extended_float_accum_err_ulp_add nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (roundp_is_even_closest formula-decl nil unb_link nil))
   nil
   (IMP_accum_err_add assuming
    "float_unbounded@accum_err_add[extended_float_accum_err_ulp_add.radix, (# dExp := extended_float_accum_err_ulp_add.dExp, Prec := extended_float_accum_err_ulp_add.precision #), rounding_th[extended_float_accum_err_ulp_add.radix, extended_float_accum_err_ulp_add.precision, extended_float_accum_err_ulp_add.dExp].closest?_ucf, rounding_th[extended_float_accum_err_ulp_add.radix, extended_float_accum_err_ulp_add.precision, extended_float_accum_err_ulp_add.dExp].rnd_ucf].accum_err_add"
    "round_even_closest: ASSUMPTION FORALL (x: reals.real, f: (float[accum_err_add.radix].Fbounded?(accum_err_add.b))): booleans.IMPLIES(accum_err_add.round(x, f), float[accum_err_add.radix].EvenClosest?(accum_err_add.b)(x, f))")))
 (IMP_accum_err_add_TCC2 0
  (IMP_accum_err_add_TCC2-1 nil 3876289711
   ("" (use "closest?_ucf__j") (("" (flatten) nil nil)) nil)
   ((dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_accum_err_ulp_add nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_accum_err_ulp_add nil)
    (radix formal-const-decl "above(1)"
           extended_float_accum_err_ulp_add nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (closest?_ucf__j judgement-tcc nil float_props_rounding
     float_unbounded))
   nil
   (IMP_accum_err_add assuming
    "float_unbounded@accum_err_add[extended_float_accum_err_ulp_add.radix, (# dExp := extended_float_accum_err_ulp_add.dExp, Prec := extended_float_accum_err_ulp_add.precision #), rounding_th[extended_float_accum_err_ulp_add.radix, extended_float_accum_err_ulp_add.precision, extended_float_accum_err_ulp_add.dExp].closest?_ucf, rounding_th[extended_float_accum_err_ulp_add.radix, extended_float_accum_err_ulp_add.precision, extended_float_accum_err_ulp_add.dExp].rnd_ucf].accum_err_add"
    "round_rounded_mode: ASSUMPTION float[accum_err_add.radix].rounded_mode?(accum_err_add.b)(accum_err_add.round)")))
 (IMP_domain_equivalence_TCC1 0
  (IMP_domain_equivalence_TCC1-1 nil 3876298854
   ("" (assuming-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (emax const-decl "above(1)" extended_float nil)
    (max_exp const-decl "posint" extended_float nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_accum_err_ulp_add nil)
    (xef_real_1_j number-judgement "xef_real" extended_float_add nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (IMP_domain_equivalence assuming
    "domain_equivalence[extended_float_accum_err_ulp_add.radix, extended_float_accum_err_ulp_add.precision, extended_float[extended_float_accum_err_ulp_add.radix, extended_float_accum_err_ulp_add.precision, extended_float_accum_err_ulp_add.dExp].emax, extended_float_accum_err_ulp_add.dExp].domain_equivalence"
    "dExp_emax: ASSUMPTION domain_equivalence.dExp = (number_fields.-)((number_fields.+)((number_fields.-)(domain_equivalence.e_max, 1), domain_equivalence.precision), 1)")))
 (accumulated_round_off_error_bound__addition 0
  (accumulated_round_off_error_bound__addition-1 nil 3876289731
   ("" (skeep)
    (("" (beta)
      (("" (flatten)
        (("" (lemma "accum_err_bound")
          (("" (inst -1 "e1" "e2" "to_unb(f1)" "to_unb(f2)" "r1" "r2")
            (("" (split)
              (("1" (rewrite "to_unb_addition_projection")
                (("1" (with-tccs (rewrite "axm_ulp_fnd_ulp")) nil nil))
                nil)
               ("2" (rewrite "to_unb_projection") nil nil)
               ("3" (rewrite "to_unb_projection" :dir rl :fnums 1) nil
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_accum_err_ulp_add nil)
    (precision formal-const-decl "above(1)"
     extended_float_accum_err_ulp_add nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_accum_err_ulp_add nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (accum_err_bound formula-decl nil accum_err_add float_unbounded)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (closest?_ucf__j name-judgement "{round:
   RestrictedRounding[radix]((# Prec := precision, dExp := dExp #),
                             EvenClosest?) |
   rounded_mode?((# Prec := precision, dExp := dExp #))(round)}"
     extended_float_rounding__nearest_even nil)
    (closest?_ucf__j name-judgement "{round:
   RestrictedRounding[radix]((# Prec := precision, dExp := dExp #),
                             EvenClosest?) |
   rounded_mode?((# Prec := precision, dExp := dExp #))(round)}"
     extended_float_add nil)
    (closest?_ucf__j name-judgement "{round:
   RestrictedRounding((# Prec := precision, dExp := dExp #),
                      EvenClosest?) |
   rounded_mode?((# Prec := precision, dExp := dExp #))(round)}"
     float_props_rounding float_unbounded)
    (closest?_ucf__j name-judgement "{round:
   RestrictedRounding[radix]((# dExp := dExp, Prec := precision #),
                             EvenClosest?) |
   rounded_mode?((# dExp := dExp, Prec := precision #))(round)}"
     extended_float_accum_err_ulp_add nil)
    (roundp_ClosestRoundingPred name-judgement
     "ClosestRoundingPred[radix]((# dExp := dExp, Prec := precision #))"
     extended_float_accum_err_ulp_add nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)" extended_float_add nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun((# Prec := precision, dExp := dExp #), closest?_ucf)"
     float_props_rounding float_unbounded)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# dExp := dExp, Prec := precision #),
                          closest?_ucf)"
     extended_float_accum_err_ulp_add nil)
    (axm_ulp_fnd_ulp formula-decl nil domain_equivalence nil)
    (add_ulp_bound const-decl "nonneg_real" accum_err_add
     float_unbounded)
    (emax const-decl "above(1)" extended_float nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (to_unb_addition_projection formula-decl nil unb_link nil)
    (to_unb_projection formula-decl nil unb_link nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (efloat type-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (to_unb const-decl "unb_canonic_float" unb_link nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_accum_err_ulp_add nil)
    (xef_real_1_j number-judgement "xef_real" extended_float_add nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak)))


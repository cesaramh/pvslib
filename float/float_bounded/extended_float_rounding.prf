(extended_float_rounding
 (radix__TCC1 0
  (radix__TCC1-1 nil 3765633954 ("" (judgement-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (radix__ subtype "extended_float_rounding.radix_"
    "integers.above(1)")))
 (precision__TCC1 0
  (precision__TCC1-1 nil 3765633954
   ("" (typepred "radix_")
    (("" (typepred "precision_") (("" (assert) nil nil)) nil)) nil)
   ((precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nil name-judgement "above(1)" extended_float_rounding nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil))
   nil
   (precision__ subtype "extended_float_rounding.precision_"
    "integers.above(1)")))
 (dExp__TCC1 0
  (dExp__TCC1-1 nil 3765633954
   ("" (typepred "precision_")
    (("" (typepred "radix_")
      (("" (typepred "dExp_") (("" (ground) nil nil)) nil)) nil))
    nil)
   ((nil name-judgement "above(1)" extended_float_rounding nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}" extended_float_rounding nil)
    (nil name-judgement "above(1)" extended_float_rounding nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil))
   nil
   (dExp__ subtype "extended_float_rounding.dExp_"
    "{d: integers.posnat | reals.>(d, (number_fields.-)(number_fields.*(2, extended_float_rounding.precision_), 3))}")))
 (round_er_eq_unb_TCC1 0
  (round_er_eq_unb_TCC1-1 nil 3765734810
   ("" (skeep :preds? t)
    (("" (split 2)
      (("1" (rewrite "bound_on_exp_of_rounded_erreal") nil nil)
       ("2" (use "er_canonic")
        (("2" (skeep :preds? t)
          (("2" (replace -3 :dir rl :hide? y)
            (("2" (lemma "rnd_prj_ucf")
              (("2" (inst -1 "f")
                (("2" (expand "prj_ucf")
                  (("2" (replace -1 :hide? t)
                    (("2" (expand "FtoR") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (above nonempty-type-eq-decl nil integers nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}" extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (bound_on_exp_of_rounded_erreal formula-decl nil
     extended_float_rounding nil)
    (rnd_prj_ucf formula-decl nil float_props_rounding float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (float type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (<= const-decl "bool" reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (xef_real_0_j number-judgement "xef_real" extended_float_rounding
     nil)
    (nil name-judgement "{d: posnat | d > 2 * (precision_ - 1) - 1}"
     extended_float_rounding nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nil name-judgement "above(1)" extended_float_rounding nil)
    (xef_real_1_j number-judgement "xef_real" extended_float_rounding
     nil)
    (nil name-judgement "above(1)" extended_float_rounding nil)
    (er_canonic formula-decl nil
     extended_float_exactly_representable_reals nil))
   nil
   (round_er_eq_unb subtype
    "float_props_rounding[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].rnd_ucf(extended_float_rounding.x)"
    "{v: float_props_rounding[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].max_exp), Fnum(v) /= 0)}")))
 (round_er_eq_unb 0
  (round_er_eq_unb-1 nil 3765734822
   ("" (skeep :preds? t)
    (("" (expand "round")
      (("" (use "er_lower_bound")
        (("" (use "er_upper_bound")
          (("" (rewrite "er_ub_correspondent")
            (("" (rewrite "er_lb_correspondent")
              (("" (assert)
                (("" (lift-if 2)
                  (("" (split 2)
                    (("1" (flatten)
                      (("1" (lemma "er_max_neg_prop")
                        (("1" (inst -1 "x")
                          (("1" (rewrite "er_max_neg_correspondent")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (use "er_min_pos_prop")
                            (("1" (rewrite "er_min_pos_correspondent")
                              (("1" (assert) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (use "er_upper_bound")
                                (("1"
                                  (use "er_ub_correspondent")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_lb const-decl "er_real" ieee754_domain float_bounded_axiomatic)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_min_pos_prop formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (zero_is_er formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_max_neg_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_max_neg_prop formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (posinf const-decl "efloat" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic))
   nil))
 (proj_round_er_eq_unb_TCC1 0
  (proj_round_er_eq_unb_TCC1-1 nil 3765734566
   ("" (skeep :preds? t) (("" (use "rtoed_er_is_finite") nil nil)) nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (above nonempty-type-eq-decl nil integers nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}" extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (rtoed_er_is_finite formula-decl nil extended_float_rounding nil))
   nil
   (proj_round_er_eq_unb subtype
    "extended_float_rounding.round(extended_float_rounding.x)"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)")))
 (proj_round_er_eq_unb 0
  (proj_round_er_eq_unb-1 nil 3765734582
   ("" (skeep :preds? t)
    (("" (use "er_lower_bound")
      (("" (use "er_upper_bound")
        (("" (rewrite "er_ub_correspondent")
          (("" (rewrite "er_lb_correspondent")
            (("" (expand "round")
              (("" (assert)
                (("" (lift-if 1)
                  (("" (split 1)
                    (("1" (flatten)
                      (("1" (expand "prj_ef")
                        (("1" (lemma "er_max_neg_prop")
                          (("1" (inst -1 "x")
                            (("1" (rewrite "er_max_neg_correspondent")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (case "x=0")
                            (("1" (expand "prj_ef")
                              (("1"
                                (replace -1 :hide? t)
                                (("1"
                                  (rewrite "dtor_rtod_on_er")
                                  nil
                                  nil))
                                nil))
                              nil)
                             ("2" (lemma "er_min_pos_prop")
                              (("2"
                                (inst -1 "x")
                                (("1"
                                  (rewrite "er_min_pos_correspondent")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (expand "prj_ef")
                            (("2" (split 2)
                              (("1"
                                (flatten)
                                (("1"
                                  (use "er_upper_bound")
                                  (("1"
                                    (use "er_ub_correspondent")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_min_pos_prop formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (er_max_neg_prop formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_max_neg_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (prj_ef const-decl "real" extended_float nil)
    (posinf const-decl "efloat" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_lb const-decl "er_real" ieee754_domain float_bounded_axiomatic)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic))
   nil))
 (proj_round_on_er 0
  (proj_round_on_er-1 nil 3765734102
   ("" (skeep :preds? t)
    (("" (use "er_lower_bound")
      (("" (use "er_upper_bound")
        (("" (rewrite "er_ub_correspondent")
          (("" (rewrite "er_lb_correspondent")
            (("" (expand "round")
              (("" (assert)
                (("" (lift-if 1)
                  (("" (split 1)
                    (("1" (flatten)
                      (("1" (expand "prj_ef")
                        (("1" (lemma "er_max_neg_prop")
                          (("1" (inst -1 "x")
                            (("1" (rewrite "er_max_neg_correspondent")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (case "x=0")
                            (("1" (expand "prj_ef")
                              (("1" (propax) nil nil)) nil)
                             ("2" (lemma "er_min_pos_prop")
                              (("2"
                                (inst -1 "x")
                                (("1"
                                  (rewrite "er_min_pos_correspondent")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (use "er_upper_bound")
                                (("1"
                                  (use "er_ub_correspondent")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (expand "prj_ef")
                                (("2" (use "dtor_rtod_on_er") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (er_min_pos_prop formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_max_neg_prop formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_max_neg_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (prj_ef const-decl "real" extended_float nil)
    (posinf const-decl "efloat" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_lb const-decl "er_real" ieee754_domain float_bounded_axiomatic)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic))
   nil))
 (round_is_injective_on_er 0
  (round_is_injective_on_er-1 nil 3765734011
   ("" (skeep :preds? t)
    (("" (case "x=0")
      (("1" (rewrite -1)
        (("1" (rewrite "round_zero")
          (("1" (expand "round")
            (("1" (lift-if -3)
              (("1" (hide -1)
                (("1" (use "er_lower_bound")
                  (("1" (use "er_upper_bound")
                    (("1" (assert)
                      (("1" (split -4)
                        (("1" (propax) nil nil)
                         ("2" (flatten)
                          (("2" (split -1)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (split -1)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (split 1)
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (use "er_min_pos_prop")
                                      (("1"
                                        (rewrite
                                         "er_min_pos_correspondent")
                                        (("1" (assert) nil nil))
                                        nil)
                                       ("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "y= 0")
        (("1" (rewrite -1)
          (("1" (hide 2)
            (("1" (rewrite "round_zero")
              (("1" (expand "round")
                (("1" (lift-if -3)
                  (("1" (hide -2)
                    (("1" (use "er_lower_bound")
                      (("1" (use "er_upper_bound")
                        (("1" (assert)
                          (("1" (split -4)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (split -1)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (decompose-equality -3)
                                    nil
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (split -1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (split 1)
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (use "er_min_pos_prop")
                                          (("1"
                                            (rewrite
                                             "er_min_pos_correspondent")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case "rnd_ucf(x) = rnd_ucf(y)")
          (("1" (hide -4)
            (("1" (typepred "rnd_ucf(x)")
              (("1" (expand "currified_closest?_ucf")
                (("1" (expand "closest?_ucf")
                  (("1" (use "EvenClosest_Unique")
                    (("1" (expand "Unique?")
                      (("1" (inst -1 "x" "rnd_ucf(x)" "rnd_ucf(y)")
                        (("1" (split -1)
                          (("1" (lemma "proj_round_on_er")
                            (("1" (inst -1 "x")
                              (("1"
                                (lemma "proj_round_on_er")
                                (("1"
                                  (inst -1 "y")
                                  (("1"
                                    (rewrite "proj_round_er_eq_unb")
                                    (("1"
                                      (rewrite "proj_round_er_eq_unb")
                                      (("1"
                                        (expand "prj_ucf")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil)
                           ("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma "round_er_eq_unb")
            (("2" (inst -1 "x")
              (("2" (rewrite -1)
                (("2" (lemma "round_er_eq_unb")
                  (("2" (inst -1 "y")
                    (("2" (rewrite -1)
                      (("2" (decompose-equality -3) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (neginf const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (zero_exclusive formula-decl nil extended_float nil)
    (posinf const-decl "efloat" extended_float nil)
    (er_min_pos_prop formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_lb const-decl "er_real" ieee754_domain float_bounded_axiomatic)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Unique? const-decl "bool" float float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (EvenClosest_Unique formula-decl nil float float_unbounded)
    (nzfinite adt-constructor-decl
     "[{v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0} ->
   (nzfinite?)]" extended_float nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil)
    (max_exp const-decl "posint" extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (zero adt-constructor-decl "[bool -> (zero?)]" extended_float nil)
    (positive? shared-adt-accessor-decl
     "[{x: efloat | infinite?(x) OR zero?(x)} -> bool]" extended_float
     nil)
    (zero? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (infinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (efloat type-decl nil extended_float nil))
   nil))
 (ieee754_semantics_round_proj_interpretation_obligation_1_TCC1 0
  (ieee754_semantics_round_proj_interpretation_obligation_1_TCC1-1 nil
   3765735133 ("" (subtype-tcc) nil nil)
   ((dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}" extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite? const-decl "bool" extended_float nil))
   nil
   (ieee754_semantics_round_proj_interpretation_obligation_1 subtype
    "extended_float_rounding.f"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)")))
 (ieee754_semantics_round_proj_interpretation_obligation_1 0
  (ieee754_semantics_round_proj_interpretation_obligation_1-1 nil
   3765735141
   ("" (skeep)
    (("" (use "round_inverse_of_projection_on_nzfinite")
      (("" (assert) nil nil)) nil))
    nil)
   ((efloat type-decl nil extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil))
   nil))
 (ieee754_semantics_nzfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_nzfinite?_def_interpretation_obligation_1-2 ""
   3790103861
   ("" (skeep)
    (("" (mapped-axiom-tcc) (("" (grind-reals) nil nil)) nil)) nil)
   ((prj_ef const-decl "real" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (FtoR const-decl "real" float float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded))
   shostak)
  (ieee754_semantics_nzfinite?_def_interpretation_obligation_1-1 nil
   3765633636
   ("" (then (skeep) (mapped-axiom-tcc) (grind-reals)) nil nil)
   ((FtoR const-decl "real" float float_unbounded)
    (is_finite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil))
   shostak))
 (ieee754_semantics_pfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_pfinite?_def_interpretation_obligation_1-1 nil
   3765633683
   ("" (skeep)
    (("" (mapped-axiom-tcc)
      (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil))
    nil)
   ((nzpfinite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (FtoR const-decl "real" float float_unbounded))
   shostak))
 (ieee754_semantics_nfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_nfinite?_def_interpretation_obligation_1-1 nil
   3765633683
   ("" (skeep)
    (("" (mapped-axiom-tcc)
      (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil))
    nil)
   ((nznfinite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (FtoR const-decl "real" float float_unbounded))
   shostak))
 (ieee754_semantics_add_inv_def_interpretation_obligation_1_TCC1 0
  (ieee754_semantics_add_inv_def_interpretation_obligation_1_TCC1-1 nil
   3765633590 ("" (subtype-tcc) nil nil)
   ((radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Fopp const-decl "float" float float_unbounded)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}" extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (flip_sign const-decl "efloat" extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (nil name-judgement "above(1)" extended_float_rounding nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (nil name-judgement "above(1)" extended_float_rounding nil)
    (xef_real_1_j number-judgement "xef_real" extended_float_rounding
     nil)
    (int_times_int_is_int application-judgement "int" integers nil))
   nil
   (ieee754_semantics_add_inv_def_interpretation_obligation_1 subtype
    "extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].flip_sign(extended_float_rounding.f)"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)")))
 (ieee754_semantics_add_inv_def_interpretation_obligation_1 0
  (ieee754_semantics_add_inv_def_interpretation_obligation_1-2 ""
   3790103865
   ("" (skeep :preds? t)
    (("" (expand "flip_sign")
      (("" (expand "prj_ef")
        (("" (expand "prj_ucf") (("" (use "FoppCorrect") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((flip_sign const-decl "efloat" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (FoppCorrect formula-decl nil float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (efloat type-decl nil extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (Format type-eq-decl nil float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (max_exp const-decl "posint" extended_float nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil)
    (prj_ef const-decl "real" extended_float nil))
   shostak)
  (ieee754_semantics_add_inv_def_interpretation_obligation_1-1 nil
   3765633600
   (""
    (then (skeep :preds? t) (expand "flip_sign") (expand "prj_ef")
     (expand "prj_ucf") (use "FoppCorrect"))
    nil nil)
   ((val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil)
    (max_exp const-decl "posint" extended_float nil)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (efloat type-decl nil extended_float nil)
    (float type-eq-decl nil float float_unbounded)
    (FoppCorrect formula-decl nil float float_unbounded))
   shostak))
 (proj_round_is_monotone_on_er_TCC1 0
  (proj_round_is_monotone_on_er_TCC1-1 nil 3799155549
   ("" (skeep) (("" (use "rtoed_er_is_finite") nil nil)) nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (above nonempty-type-eq-decl nil integers nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}" extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (rtoed_er_is_finite formula-decl nil extended_float_rounding nil))
   nil
   (proj_round_is_monotone_on_er subtype
    "extended_float_rounding.round(extended_float_rounding.y)"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)")))
 (proj_round_is_monotone_on_er 0
  (proj_round_is_monotone_on_er-1 nil 3799155570
   ("" (skeep :preds? t)
    (("" (rewrite "proj_round_er_eq_unb")
      (("" (rewrite "proj_round_er_eq_unb")
        (("" (typepred "rnd_ucf(x)")
          (("" (expand "currified_closest?_ucf")
            (("" (use "closest?_ucf__j")
              (("" (flatten)
                (("" (expand "rounded_mode?")
                  (("" (flatten)
                    (("" (expand "monotone?")
                      (("" (inst -5 "x" "y" "rnd_ucf(x)" "rnd_ucf(y)")
                        (("" (split -5)
                          (("1" (expand "prj_ucf")
                            (("1" (propax) nil nil)) nil)
                           ("2" (case "x=y")
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("3" (propax) nil nil)
                           ("4" (typepred "rnd_ucf(y)")
                            (("4" (expand "currified_closest?_ucf")
                              (("4" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (closest?_ucf__j judgement-tcc nil float_props_rounding
     float_unbounded)
    (rounded_mode? const-decl "bool" float float_unbounded)
    (monotone? const-decl "bool" float float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded))
   shostak))
 (round_inverse_of_projection_on_nzfinite_TCC1 0
  (round_inverse_of_projection_on_nzfinite_TCC1-1 nil 3913301388
   ("" (subtype-tcc) nil nil)
   ((dExp_ formal-const-decl "{d: posnat |
   radix_ = 2 IMPLIES
    (precision_ = 53 IMPLIES d = 1074) AND
     (precision_ = 24 IMPLIES d = 149)}" extended_float_rounding nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision_ formal-const-decl
     "{i: posint | radix_ = 2 IMPLIES (i = 53 OR i = 24)}"
     extended_float_rounding nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (radix_ formal-const-decl "{i: posint | i = 2}"
     extended_float_rounding nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite? const-decl "bool" extended_float nil))
   nil
   (round_inverse_of_projection_on_nzfinite subtype
    "extended_float_rounding.f"
    "(extended_float[extended_float_rounding.radix_, extended_float_rounding.precision_, extended_float_rounding.dExp_].is_finite?)"))))


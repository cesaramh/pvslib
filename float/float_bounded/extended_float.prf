(extended_float
 (min_exp_TCC1 0
  (min_exp_TCC1-1 nil 3765199342 ("" (subtype-tcc) nil nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (min_exp subtype "(number_fields.-)(extended_float.dExp)"
    "negint")))
 (max_exp_TCC1 0
  (max_exp_TCC1-1 nil 3765199342 ("" (subtype-tcc) nil nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (max_exp subtype
    "(number_fields.+)((number_fields.-)(extended_float.dExp, number_fields.*(2, ((number_fields.-)(extended_float.precision, 1)))), 1)"
    "posint")))
 (min_pos_value_TCC1 0
  (min_pos_value_TCC1-1 nil 3763821233 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (min_pos_value subtype "extended_float.min_exp"
    "{i: integers.int | booleans.OR(extended_float.radix /= 0, reals.>=(i, 0))}")))
 (max_pos_value_TCC1 0
  (max_pos_value_TCC1-1 nil 3763821233 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (max_pos_value subtype "extended_float.precision"
    "{i: integers.int | booleans.OR(extended_float.radix /= 0, reals.>=(i, 0))}")))
 (max_pos_value_TCC2 0
  (max_pos_value_TCC2-1 nil 3763821233 ("" (subtype-tcc) nil nil)
   ((/= const-decl "boolean" notequal nil)) nil
   (max_pos_value subtype "extended_float.max_exp"
    "{i: integers.int | booleans.OR(extended_float.radix /= 0, reals.>=(i, 0))}")))
 (max_pos_value_TCC3 0
  (max_pos_value_TCC3-1 nil 3763821233
   ("" (case "(radix ^ precision - 1) * radix ^ max_exp > 0")
    (("1" (assert) nil nil)
     ("2" (hide 2)
      (("2" (use "posreal_mult_closed")
        (("2" (assert)
          (("2" (hide 2)
            (("2" (typepred "radix")
              (("2" (lemma "increasing_expt_aux")
                (("2" (expand "^")
                  (("2" (inst -1 "radix" "precision -2 ")
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (typepred "radix") (("3" (assert) nil nil)) nil)) nil)
     ("4" (typepred "radix") (("4" (assert) nil nil)) nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (increasing_expt_aux formula-decl nil exponentiation nil)
    (posreal_mult_closed formula-decl nil real_axioms nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (>= const-decl "bool" reals nil)
    (^ const-decl "real" exponentiation nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" extended_float nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil))
   nil
   (max_pos_value subtype
    "number_fields.*(((number_fields.-)(exponentiation.^(extended_float.radix, extended_float.precision), 1)), exponentiation.^(extended_float.radix, extended_float.max_exp))"
    "posreal")))
 (emax_TCC1 0
  (emax_TCC1-1 nil 3765199342 ("" (subtype-tcc) nil nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (max_exp const-decl "posint" extended_float nil))
   nil
   (emax subtype
    "(number_fields.-)((number_fields.+)(extended_float.max_exp, extended_float.precision), 1)"
    "integers.above(1)")))
 (min_pos_value__min_pos_unb_canonic_float__eq 0
  (min_pos_value__min_pos_unb_canonic_float__eq-1 nil 3764927848
   ("" (expand "minimum_positive_bounded_value")
    (("" (expand "min_pos_value")
      (("" (expand "min_exp")
        (("" (expand "given_format") (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((min_pos_value const-decl "posreal" extended_float nil)
    (min_exp const-decl "negint" extended_float nil)
    (minimum_positive_bounded_value const-decl "posreal" float
     float_unbounded))
   shostak))
 (is_pos_inf?_TCC1 0
  (is_pos_inf?_TCC1-1 nil 3795961992 ("" (subtype-tcc) nil nil) nil nil
   (is_pos_inf? subtype "extended_float.d"
    "{x: extended_float.efloat | booleans.OR(extended_float.infinite?(x), extended_float.zero?(x))}")))
 (is_pos_zero?_TCC1 0
  (is_pos_zero?_TCC1-1 nil 3795961992 ("" (subtype-tcc) nil nil) nil
   nil
   (is_pos_zero? subtype "extended_float.d"
    "{x: extended_float.efloat | booleans.OR(extended_float.infinite?(x), extended_float.zero?(x))}")))
 (inf_exclusive 0
  (inf_exclusive-1 nil 3765039147 ("" (decompose-equality) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (efloat type-decl nil extended_float nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (infinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (zero? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (positive? shared-adt-accessor-decl
     "[{x: efloat | infinite?(x) OR zero?(x)} -> bool]" extended_float
     nil)
    (inf adt-constructor-decl "[bool -> (infinite?)]" extended_float
         nil)
    (TRUE const-decl "bool" booleans nil)
    (FALSE const-decl "bool" booleans nil))
   shostak))
 (zero_inclusive 0
  (zero_inclusive-1 nil 3765034302
   ("" (grind)
    (("" (apply-extensionality 1)
      (("" (apply-extensionality 3) nil nil)) nil))
    nil)
   ((efloat_zero_extensionality formula-decl nil extended_float nil)
    (efloat type-decl nil extended_float nil)
    (boolean nonempty-type-decl nil booleans nil)
    (zero? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (zero adt-constructor-decl "[bool -> (zero?)]" extended_float nil)
    (FALSE const-decl "bool" booleans nil))
   shostak))
 (zero_exclusive 0
  (zero_exclusive-1 nil 3765039125 ("" (decompose-equality) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (efloat type-decl nil extended_float nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (infinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (zero? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (positive? shared-adt-accessor-decl
     "[{x: efloat | infinite?(x) OR zero?(x)} -> bool]" extended_float
     nil)
    (zero adt-constructor-decl "[bool -> (zero?)]" extended_float nil)
    (TRUE const-decl "bool" booleans nil)
    (FALSE const-decl "bool" booleans nil))
   shostak))
 (prj_ef_TCC1 0
  (prj_ef_TCC1-1 nil 3799077331 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (efloat type-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil))
   nil
   (prj_ef subtype "extended_float.f" "(extended_float.nzfinite?)")))
 (projection_on_nzfinite_TCC1 0
  (projection_on_nzfinite_TCC1-1 nil 3799077331
   ("" (subtype-tcc) nil nil)
   ((is_finite? const-decl "bool" extended_float nil)) nil
   (projection_on_nzfinite subtype "extended_float.f"
    "(extended_float.is_finite?)")))
 (projection_on_nzfinite 0
  (projection_on_nzfinite-1 nil 3799077348
   ("" (skeep :preds? t)
    (("" (expand "prj_ef")
      (("" (typepred "val(f)")
        (("" (expand "/=")
          (("" (expand "prj_ucf")
            (("" (expand "FtoR") (("" (grind-reals) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prj_ef const-decl "real" extended_float nil)
    (FtoR const-decl "real" float float_unbounded)
    (nonzero_times3 formula-decl nil real_props nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (radix formal-const-decl "above(1)" extended_float nil)
    (Format type-eq-decl nil float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (precision formal-const-decl "above(1)" extended_float nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (efloat type-decl nil extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil))
   shostak))
 (xef_real_TCC1 0
  (xef_real_TCC1-1 nil 3795962017
   ("" (expand "exactly_representable_as_pair_of_integers?")
    (("" (inst 1 "float_pair(0,-dExp(given_format))")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (float_pair const-decl "float" float float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (radix formal-const-decl "above(1)" extended_float nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (FtoR const-decl "real" float float_unbounded)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vNum const-decl "posnat" float float_unbounded)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil))
   nil (xef_real subtype "0" "xef_real")))
 (xef_real_0_j 0
  (xef_real_0_j-2 nil 3799163489
   ("" (expand "exactly_representable_as_pair_of_integers?")
    (("" (inst 1 "float_pair(0,-dExp(given_format))")
      (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
    nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (float_pair const-decl "float" float float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (radix formal-const-decl "above(1)" extended_float nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (FtoR const-decl "real" float float_unbounded)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vNum const-decl "posnat" float float_unbounded)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil))
   nil (xef_real_0_j subtype "0" "xef_real"))
  (xef_real_0_j-1 nil 3799163439 ("" (judgement-tcc) nil nil) nil nil
   (xef_real_0_j subtype "0" "xef_real")))
 (xef_real_1_j 0
  (xef_real_1_j-1 nil 3866841313
   ("" (expand "exactly_representable_as_pair_of_integers?")
    (("" (inst 1 "float_pair(1,0)")
      (("1" (grind) nil nil)
       ("2" (grind)
        (("2" (typepred "precision")
          (("2" (typepred "radix")
            (("2" (both-sides "-" "2" -2)
              (("2" (assert)
                (("2" (case "1 <= expt(radix, precision - 2)")
                  (("1"
                    (case "1 * 1 < radix * expt(radix, precision - 2)")
                    (("1" (assert)
                      (("1"
                        (case "1 * 1 < radix * (radix * expt(radix, precision - 2))")
                        (("1" (assert) nil nil)
                         ("2" (hide 2)
                          (("2"
                            (name-replace "bla"
                             "radix * expt(radix, precision - 2)")
                            (("2" (hide-all-but (1 -1 -3))
                              (("2"
                                (use "lt_times_lt_pos1")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 2)
                      (("2" (use "lt_times_lt_pos1")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2" (use "expt_gt1_bound1") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((xef_real_0_j number-judgement "xef_real" extended_float nil)
    (float_pair const-decl "float" float float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (radix formal-const-decl "above(1)" extended_float nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (FtoR const-decl "real" float float_unbounded)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (even? const-decl "bool" integers nil)
    (both_sides_minus_gt1 formula-decl nil real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (lt_times_lt_pos1 formula-decl nil real_props nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (odd_times_odd_is_odd application-judgement "odd_int" integers nil)
    (expt_gt1_bound1 formula-decl nil exponentiation nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}"
     real_defs nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}"
     real_defs nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (vNum const-decl "posnat" float float_unbounded)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil))
   nil (xef_real_1_j subtype "1" "xef_real")))
 (min_pos_value_xef_real 1
  (min_pos_value_xef_real-2 nil 3799077339
   ("" (skeep :preds? t)
    (("" (expand "prj_ef")
      (("" (typepred "val(f)")
        (("" (expand "/=")
          (("" (expand "prj_ucf")
            (("" (expand "FtoR") (("" (grind-reals) nil))))))))))))
    nil)
   nil nil
   (min_pos_value_xef_real subtype "extended_float.min_pos_value"
    "xef_real"))
  (min_pos_value_xef_real-1 nil 3795968148
   ("" (expand "exactly_representable_as_pair_of_integers?")
    (("" (inst 1 "float_pair(1,min_exp)")
      (("1" (grind) nil nil)
       ("2" (expand "float_pair")
        (("2" (expand "Fbounded?")
          (("2" (expand "given_format")
            (("2" (split 1)
              (("1" (expand "vNum")
                (("1" (typepred "precision")
                  (("1" (eval-expr "abs(1)")
                    (("1" (replace -1 :hide? t)
                      (("1" (typepred "radix")
                        (("1" (lemma "both_sides_expt_pos_gt")
                          (("1" (inst? -1 :where -2)
                            (("1" (inst -1 "precision")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((xef_real_1_j number-judgement "xef_real" extended_float nil)
    (min_exp const-decl "negint" extended_float nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (float_pair const-decl "float" float float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (radix formal-const-decl "above(1)" extended_float nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (xef_real_0_j number-judgement "xef_real" extended_float nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (FtoR const-decl "real" float float_unbounded)
    (min_pos_value const-decl "posreal" extended_float nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (vNum const-decl "posnat" float float_unbounded)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}"
     real_defs nil)
    (nzrat_abs_is_pos application-judgement "{r: posrat | r >= q}"
     real_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (expt_1i formula-decl nil exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_expt_pos_gt formula-decl nil exponentiation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil))
   nil
   (min_pos_value_xef_real subtype "extended_float.min_pos_value"
    "xef_real")))
 (max_pos_value_xef_real 0
  (max_pos_value_xef_real-1 nil 3795968148
   ("" (judgement-tcc)
    (("" (inst 1 "float_pair((radix^precision - 1),max_exp)")
      (("1" (grind) nil nil)
       ("2" (expand "float_pair")
        (("2" (case "1<expt(radix, precision)")
          (("1" (assert) nil nil)
           ("2" (hide 2)
            (("2" (typepred "radix")
              (("2" (typepred "precision")
                (("2" (lemma "both_sides_expt_pos_gt")
                  (("2" (inst? -1 :where -3)
                    (("2" (inst -1 "precision")
                      (("2" (assert)
                        (("2" (rewrite "expt_1n_aux")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (float type-eq-decl nil float float_unbounded)
    (float_pair const-decl "float" float float_unbounded)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (expt def-decl "real" exponentiation nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (<= const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (vNum const-decl "posnat" float float_unbounded)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (both_sides_expt_pos_gt formula-decl nil exponentiation nil)
    (expt_1n_aux formula-decl nil exponentiation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (xef_real_0_j number-judgement "xef_real" extended_float nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (xef_real_1_j number-judgement "xef_real" extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (FtoR const-decl "real" float float_unbounded)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" extended_float nil)
    (max_pos_value const-decl "posreal" extended_float nil)
    (max_exp const-decl "posint" extended_float nil))
   nil
   (max_pos_value_xef_real subtype "extended_float.max_pos_value"
    "xef_real")))
 (xef_real_upper_bound 0
  (xef_real_upper_bound-1 nil 3795971838
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable_as_pair_of_integers?")
      (("" (skeep :preds? t)
        (("" (expand "Fbounded?")
          (("" (flatten)
            (("" (expand "given_format")
              (("" (expand "vNum")
                (("" (replace -3 :hide? t :dir rl)
                  (("" (expand "FtoR")
                    (("" (expand "max_pos_value" :assert? none)
                      (("" (lemma "le_times_le_pos")
                        ((""
                          (inst -1 "abs(Fnum(f))" "radix ^ (Fexp(f))"
                           "radix ^ max_exp" "(radix ^ precision - 1)")
                          (("" (split -1)
                            (("1" (lemma "both_sides_times_pos_le1")
                              (("1"
                                (inst
                                 -1
                                 "radix ^ (Fexp(f))"
                                 "Fnum(f)"
                                 "abs(Fnum(f))")
                                (("1" (assert) nil nil))
                                nil))
                              nil)
                             ("2"
                              (name-replace "bla" "radix ^ precision")
                              (("2"
                                (assert)
                                (("2" (grind) nil nil))
                                nil))
                              nil)
                             ("3" (lemma "both_sides_expt_gt1_le")
                              (("3"
                                (inst? -1 :where -4)
                                (("3"
                                  (inst? -1 :where 1)
                                  (("1" (assert) nil nil)
                                   ("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (vNum const-decl "posnat" float float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (le_times_le_pos formula-decl nil real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (both_sides_times_pos_le1 formula-decl nil real_props nil)
    (expt def-decl "real" exponentiation nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (xef_real_0_j number-judgement "xef_real" extended_float nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_expt_gt1_le formula-decl nil exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (Format type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float float_unbounded)
    (radix formal-const-decl "above(1)" extended_float nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (xef_real_1_j number-judgement "xef_real" extended_float nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (max_pos_value const-decl "posreal" extended_float nil))
   shostak))
 (xef_real_lower_bound 0
  (xef_real_lower_bound-1 nil 3796029143
   ("" (skeep)
    (("" (lemma "xef_real_upper_bound")
      (("" (inst -1 "-x")
        (("1" (grind) nil nil)
         ("2" (typepred "x")
          (("2" (hide 2)
            (("2" (expand "exactly_representable_as_pair_of_integers?")
              (("2" (skeep)
                (("2" (inst 1 "float_pair(-Fnum(f),Fexp(f))")
                  (("1" (grind) nil nil)
                   ("2" (typepred "f")
                    (("2" (expand "Fbounded?")
                      (("2" (flatten)
                        (("2" (expand "float_pair")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((xef_real_upper_bound formula-decl nil extended_float nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (f skolem-const-decl
     "(Fbounded?((# Prec := precision, dExp := dExp #)))"
     extended_float nil)
    (float_pair const-decl "float" float float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (radix formal-const-decl "above(1)" extended_float nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (FtoR const-decl "real" float float_unbounded)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (vNum const-decl "posnat" float float_unbounded)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (xef_real_0_j number-judgement "xef_real" extended_float nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (xef_real_1_j number-judgement "xef_real" extended_float nil)
    (max_pos_value_xef_real name-judgement "xef_real" extended_float
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (max_pos_value const-decl "posreal" extended_float nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (x skolem-const-decl "xef_real" extended_float nil)
    (minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (xef_real_not_zero_prj_rnd_ucf 0
  (xef_real_not_zero_prj_rnd_ucf-1 nil 3884207007
   ("" (skeep)
    (("" (typepred "rnd_ucf[radix, precision, dExp](x)")
      (("" (expand "currified_closest?_ucf")
        (("" (expand "closest?_ucf")
          (("" (expand "EvenClosest?")
            (("" (flatten)
              (("" (expand "Closest?")
                (("" (typepred "x")
                  ((""
                    (expand "exactly_representable_as_pair_of_integers?")
                    (("" (skeep -1)
                      (("" (inst -4 "f")
                        (("" (replace -1 * :hide? t)
                          (("" (assert)
                            (("" (rewrite "abs_0")
                              ((""
                                (case
                                 "forall(x,y: real): abs(x-y) <= 0 IMPLiES x=y")
                                (("1"
                                  (inst? -1 :where -4)
                                  (("1"
                                    (expand "prj_ucf")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)" extended_float nil)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (radix formal-const-decl "above(1)" extended_float nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real" extended_float nil)
    (closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (abs_0 formula-decl nil abs_lems reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (FtoR const-decl "real" float float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)" extended_float nil)
    (xef_real_0_j number-judgement "xef_real" extended_float nil)
    (Closest? const-decl "bool" float float_unbounded)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (EvenClosest? const-decl "bool" float float_unbounded))
   shostak))
 (as_float_existence 0
  (as_float_existence-1 nil 3884207276
   ("" (lemma "xef_real_not_zero_prj_rnd_ucf")
    ((""
      (inst 1 "LAMBDA(
                     x: xef_real) ->
                         {f: efloat |
                            IF x = 0 THEN f = poszero
                            ELSE nzfinite?(f) AND FtoR[radix](val(f)) = x
                            ENDIF}: IF x = 0 THEN poszero ELSE nzfinite(rnd_ucf(x)) ENDIF")
      (("1" (skeep 1)
        (("1" (inst? -1)
          (("1" (assert)
            (("1" (expand "prj_ucf") (("1" (propax) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand "prj_ucf")
          (("2" (inst?)
            (("2" (assert)
              (("2" (typepred "x")
                (("2"
                  (expand "exactly_representable_as_pair_of_integers?")
                  (("2" (skeep -1)
                    (("2" (split 2)
                      (("1"
                        (typepred "rnd_ucf[radix, precision, dExp](x)")
                        (("1" (use "CanonicLeastExp")
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (expand "/=")
                        (("2" (expand "FtoR")
                          (("2" (replace -1 * :hide? t)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skeep) (("3" (assert) nil nil)) nil))
      nil))
    nil)
   ((posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real" extended_float nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (efloat type-decl nil extended_float nil)
    (boolean nonempty-type-decl nil booleans nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (int nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" extended_float nil)
    (float type-eq-decl nil float float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (precision formal-const-decl "above(1)" extended_float nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (<= const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil)
    (nzfinite adt-constructor-decl
     "[{v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0} ->
   (nzfinite?)]" extended_float nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (FALSE const-decl "bool" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (xef_real_0_j number-judgement "xef_real" extended_float nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (CanonicLeastExp formula-decl nil float float_unbounded)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (xef_real_not_zero_prj_rnd_ucf formula-decl nil extended_float
     nil))
   shostak))
 (as_float_TCC1 0
  (as_float_TCC1-1 nil 3866841313
   ("" (lemma "as_float_existence") (("" (propax) nil nil)) nil)
   ((as_float_existence formula-decl nil extended_float nil)) nil
   (as_float existence ""
    "[x: extended_float.xef_real -> {f: extended_float.efloat | IF x = 0 THEN f = extended_float.poszero ELSE booleans.AND(extended_float.nzfinite?(f), float[extended_float.radix].FtoR(extended_float.val(f)) = x) ENDIF}]")))
 (flip_sign_j 0
  (flip_sign_j-1 nil 3799077429
   ("" (skeep :preds? t)
    (("" (split 1)
      (("1" (lemma "FcanonicOpp")
        (("1" (inst -1 "given_format" "val(f)")
          (("1" (assert) nil nil)) nil))
        nil)
       ("2" (expand "Fopp")
        (("2" (typepred "val(f)") (("2" (propax) nil nil)) nil)) nil)
       ("3" (expand "Fopp") (("3" (assert) nil nil)) nil))
      nil))
    nil)
   ((posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real" extended_float nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float float_unbounded)
    (precision formal-const-decl "above(1)" extended_float nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float nil)
    (float type-eq-decl nil float float_unbounded)
    (efloat type-decl nil extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil)
    (FcanonicOpp formula-decl nil float float_unbounded)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" extended_float nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Fopp const-decl "float" float float_unbounded)
    (xef_real_0_j number-judgement "xef_real" extended_float nil)
    (minus_int_is_int application-judgement "int" integers nil))
   nil
   (flip_sign_j subtype
    "float[extended_float.radix].Fopp(extended_float.val(extended_float.f))"
    "{v: float_props_rounding[extended_float.radix, extended_float.precision, extended_float.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float.max_exp), Fnum(v) /= 0)}"))))


(extended_float_rounding__nearest_even
 (dtor_rtod_on_er 0
  (dtor_rtod_on_er-2 "" 3795967692
   ("" (skeep :preds? t)
    (("" (typepred "rnd_ucf(x)")
      (("" (expand "currified_closest?_ucf")
        (("" (expand "closest?_ucf")
          (("" (expand "EvenClosest?")
            (("" (flatten)
              (("" (expand "Closest?" -2)
                (("" (typepred "x")
                  ((""
                    (expand "exactly_representable_as_pair_of_integers?")
                    (("" (skeep -1 :preds? t)
                      (("" (inst -5 "f")
                        (("" (replace -2 :hide? t)
                          (("" (assert)
                            (("" (eval-expr "abs(0)")
                              ((""
                                (replace -1 :hide? t)
                                ((""
                                  (case "FtoR(rnd_ucf(x)) - x = 0")
                                  (("1"
                                    (expand "prj_ucf")
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (expand "abs")
                                    (("2" (grind-reals) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (FtoR const-decl "real" float float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (Closest? const-decl "bool" float float_unbounded)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (EvenClosest? const-decl "bool" float float_unbounded))
   shostak)
  (dtor_rtod_on_er-1 nil 3795879576
   ("" (skeep :preds? t)
    (("" (typepred "rnd_ucf(x)")
      (("" (expand "currified_closest?_ucf")
        (("" (expand "closest?_ucf")
          (("" (expand "EvenClosest?")
            (("" (flatten)
              (("" (expand "Closest?" -2)
                (("" (use "er_bounded")
                  (("" (skeep -1 :preds? t)
                    (("" (inst -5 "f")
                      (("" (replace -3 :hide? t)
                        (("" (assert)
                          (("" (eval-expr "abs(0)")
                            (("" (replace -1 :hide? t)
                              ((""
                                (case "FtoR(rnd_ucf(x)) - x = 0")
                                (("1"
                                  (expand "prj_ucf")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (expand "abs")
                                  (("2" (grind-reals) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (Closest? const-decl "bool" float float_unbounded)
    (EvenClosest? const-decl "bool" float float_unbounded))
   shostak))
 (bound_on_exp_of_rounded_erreal 0
  (bound_on_exp_of_rounded_erreal-1 nil 3795879576
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable_as_pair_of_integers?")
      (("" (skeep :preds? t)
        (("" (lemma "CanonicLeastExp")
          (("" (inst -1 "given_format" "rnd_ucf(x)" "f")
            (("" (split -1)
              (("1" (assert) nil nil)
               ("2" (use "dtor_rtod_on_er")
                (("2" (expand "prj_ucf") (("2" (assert) nil nil)) nil))
                nil)
               ("3" (propax) nil nil) ("4" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (CanonicLeastExp formula-decl nil float float_unbounded)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (dtor_rtod_on_er formula-decl nil
     extended_float_rounding__nearest_even nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (Format type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (rtod_on_ranged_pos_is_in_range 0
  (rtod_on_ranged_pos_is_in_range-2 "" 3765539818
   ("" (skeep :preds? t)
    (("" (lemma "bound_on_exp_of_rounded_erreal")
      (("" (inst -1 "max_pos_value")
        (("" (case "Fexp(rnd_ucf(x)) <= Fexp(rnd_ucf(max_pos_value))")
          (("1" (split 1)
            (("1" (assert) nil nil)
             ("2" (assert)
              (("2" (expand "/=")
                (("2" (lemma "rnd_ucf_monotonic")
                  (("2" (inst -1 "min_pos_value" "x")
                    (("2" (split -1)
                      (("1"
                        (case "prj_ucf(rnd_ucf(min_pos_value)) = min_pos_value")
                        (("1" (replace -1 :hide? t)
                          (("1" (case "prj_ucf(rnd_ucf(x)) = 0")
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (hide-all-but -1)
                                (("1"
                                  (expand "min_pos_value")
                                  (("1"
                                    (typepred "min_exp")
                                    (("1" (grind-reals) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (expand "prj_ucf")
                              (("2"
                                (expand "FtoR")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite "dtor_rtod_on_er" 1 :dir rl) nil
                          nil))
                        nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use "Lexico")
            (("2" (inst -1 "given_format")
              (("2" (split -1)
                (("1" (propax) nil nil)
                 ("2" (use "EvenClosest_Monotone")
                  (("2" (expand "Monotone?")
                    (("2" (inst -1 "given_format")
                      (("2"
                        (inst -1 "x" "max_pos_value" "rnd_ucf(x)"
                         "rnd_ucf(max_pos_value)")
                        (("2" (split -1)
                          (("1" (propax) nil nil)
                           ("2" (typepred "rnd_ucf(max_pos_value)")
                            (("2" (expand "currified_closest?_ucf")
                              (("2"
                                (expand "closest?_ucf")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (typepred "rnd_ucf(x)")
                            (("3" (expand "currified_closest?_ucf")
                              (("3"
                                (expand "closest?_ucf")
                                (("3" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("4" (case "x=max_pos_value")
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (case "0 <= x")
                  (("1" (use "rnc_ucf_increasing")
                    (("1" (assert)
                      (("1" (expand "<=" -1)
                        (("1" (rewrite "FleCorrect")
                          (("1" (case "FtoR(rnd_ucf(0)) = 0")
                            (("1" (assert) nil nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (case "Fnum(rnd_ucf(0)) = 0")
                                (("1"
                                  (expand "FtoR")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (hide 2)
                                  (("2"
                                    (expand "rnd_ucf")
                                    (("2"
                                      (expand "RND_EClosest")
                                      (("2"
                                        (expand "RND_Min")
                                        (("2"
                                          (expand "RND_Max")
                                          (("2"
                                            (expand "RND_Min")
                                            (("2"
                                              (expand "RND_aux")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (grind-reals)
                                                    (("2"
                                                      (expand "Fopp")
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil)
                 ("4" (assert) nil nil) ("5" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bound_on_exp_of_rounded_erreal formula-decl nil
     extended_float_rounding__nearest_even nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float float_unbounded)
    (<= const-decl "bool" reals nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix, precision, dExp]"
     extended_float_rounding__nearest_even nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rnd_ucf_monotonic formula-decl nil float_props_rounding
     float_unbounded)
    (dtor_rtod_on_er formula-decl nil
     extended_float_rounding__nearest_even nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (FtoR const-decl "real" float float_unbounded)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min_exp const-decl "negint" extended_float nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (min_pos_value const-decl "posreal" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FleCorrect formula-decl nil float float_unbounded)
    (RND_EClosest const-decl "(Fcanonic?(b))" float float_unbounded)
    (RND_Max const-decl "(Fcanonic?(b))" float float_unbounded)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (RND_aux const-decl "(Fcanonic?(b))" float float_unbounded)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (Fopp const-decl "float" float float_unbounded)
    (minus_int_is_int application-judgement "int" integers nil)
    (zero_times1 formula-decl nil real_props nil)
    (zero_is_neg_zero formula-decl nil real_props nil)
    (TRUE const-decl "bool" booleans nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (RND_Min const-decl "(Fcanonic?(b))" float float_unbounded)
    (<= const-decl "bool" float float_unbounded)
    (rnc_ucf_increasing formula-decl nil float_props_rounding
     float_unbounded)
    (EvenClosest_Monotone formula-decl nil float float_unbounded)
    (closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Monotone? const-decl "bool" float float_unbounded)
    (Lexico formula-decl nil float float_unbounded)
    (max_pos_value const-decl "posreal" extended_float nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil))
   shostak)
  (rtod_on_ranged_pos_is_in_range-1 nil 3764931722
   ("" (skeep :preds? t)
    (("" (lemma "bound_on_exp_of_rounded_erreal")
      (("" (inst -1 "max_pos_value")
        (("1" (case "Fexp(rnd_ucf(x)) <= Fexp(rnd_ucf(max_pos_value))")
          (("1" (split 1)
            (("1" (assert) nil nil)
             ("2" (assert)
              (("2" (expand "/=")
                (("2" (lemma "rnd_ucf_monotonic")
                  (("2" (inst -1 "min_pos_value" "x")
                    (("2" (split -1)
                      (("1"
                        (case "prj_ucf(rnd_ucf(min_pos_value)) = min_pos_value")
                        (("1" (replace -1 :hide? t)
                          (("1" (case "prj_ucf(rnd_ucf(x)) = 0")
                            (("1" (replace -1 :hide? t)
                              (("1" (eval-formula -1) nil nil)) nil)
                             ("2" (expand "prj_ucf")
                              (("2"
                                (expand "FtoR")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite "dtor_rtod_on_er" 1 :dir rl)
                          (("2" (rewrite "min_pos_value_is_er") nil
                            nil))
                          nil))
                        nil)
                       ("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (use "Lexico")
            (("2" (inst -1 "given_format")
              (("2" (split -1)
                (("1" (propax) nil nil)
                 ("2" (use "EvenClosest_Monotone")
                  (("2" (expand "Monotone?")
                    (("2" (inst -1 "given_format")
                      (("2"
                        (inst -1 "x" "max_pos_value" "rnd_ucf(x)"
                         "rnd_ucf(max_pos_value)")
                        (("2" (split -1)
                          (("1" (propax) nil nil)
                           ("2" (typepred "rnd_ucf(max_pos_value)")
                            (("2" (expand "currified_closest?_ucf")
                              (("2"
                                (expand "closest?_ucf")
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("3" (typepred "rnd_ucf(x)")
                            (("3" (expand "currified_closest?_ucf")
                              (("3"
                                (expand "closest?_ucf")
                                (("3" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("4" (case "x=max_pos_value")
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (case "0 <= x")
                  (("1" (use "rnc_ucf_increasing")
                    (("1" (assert)
                      (("1" (expand "<=" -1)
                        (("1" (rewrite "FleCorrect")
                          (("1" (eval-expr "FtoR(rnd_ucf(0))")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil)
                 ("4" (assert) nil nil) ("5" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (rewrite "er_ub_correspondent" :dir rl)
          (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (min_pos_value_is_er formula-decl nil
     extended_float_exactly_representable_reals nil)
    (FtoR const-decl "real" float float_unbounded)
    (min_pos_value const-decl "posreal" extended_float nil)
    (FleCorrect formula-decl nil float float_unbounded)
    (EvenClosest_Monotone formula-decl nil float float_unbounded)
    (Monotone? const-decl "bool" float float_unbounded)
    (Lexico formula-decl nil float float_unbounded)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (max_pos_value const-decl "posreal" extended_float nil))
   shostak))
 (rtod_on_ranged_neg_is_in_range 0
  (rtod_on_ranged_neg_is_in_range-1 nil 3764931764
   ("" (skeep :preds? t)
    (("" (lemma "rtod_on_ranged_pos_is_in_range")
      (("" (inst -1 "x")
        (("" (split -1)
          (("1" (propax) nil nil) ("2" (assert) nil nil)
           ("3" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((rtod_on_ranged_pos_is_in_range formula-decl nil
     extended_float_rounding__nearest_even nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix, precision, dExp]"
     extended_float_rounding__nearest_even nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (rtod_on_near_but_not_zero_is_in_range 0
  (rtod_on_near_but_not_zero_is_in_range-1 nil 3884241732
   ("" (skeep)
    (("" (lemma "bound_on_exp_of_rounded_erreal")
      (("" (inst -1 "max_pos_value")
        (("" (split 2)
          (("1" (case "0 < FtoR(rnd_ucf(x))")
            (("1" (lemma "Lexico")
              (("1"
                (inst -1 "given_format" "rnd_ucf(x)"
                 "rnd_ucf(max_pos_value)")
                (("1" (assert)
                  (("1" (lemma "rnd_ucf_monotonic")
                    (("1" (expand "prj_ucf")
                      (("1" (inst?)
                        (("1" (assert)
                          (("1" (lemma "xef_real_upper_bound")
                            (("1" (inst -1 "min_pos_value")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case "0 <= FtoR(rnd_ucf(-x))")
              (("1" (lemma "Lexico")
                (("1"
                  (inst -1 "given_format" "rnd_ucf(-x)"
                   "rnd_ucf(max_pos_value)")
                  (("1" (assert)
                    (("1" (split -1)
                      (("1" (rewrite "rnd_opp_ucf")
                        (("1" (expand "Fopp") (("1" (assert) nil nil))
                          nil))
                        nil)
                       ("2" (lemma "rnd_ucf_monotonic")
                        (("2" (inst -1 "-x" "min_pos_value")
                          (("2" (expand "prj_ucf")
                            (("2" (lemma "rnd_ucf_monotonic")
                              (("2"
                                (inst
                                 -1
                                 "min_pos_value"
                                 "max_pos_value")
                                (("2"
                                  (split -1)
                                  (("1"
                                    (expand "prj_ucf")
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (lemma "xef_real_upper_bound")
                                    (("2"
                                      (inst -1 "min_pos_value")
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (rewrite "rnd_opp_ucf")
                (("2" (rewrite "FoppCorrect") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "/=")
            (("2" (expand "FtoR")
              (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bound_on_exp_of_rounded_erreal formula-decl nil
     extended_float_rounding__nearest_even nil)
    (<= const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (Fopp const-decl "float" float float_unbounded)
    (rnd_opp_ucf formula-decl nil float_props_rounding float_unbounded)
    (FoppCorrect formula-decl nil float float_unbounded)
    (Lexico formula-decl nil float float_unbounded)
    (minus_real_is_real application-judgement "real" reals nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix, precision, dExp]"
     extended_float_rounding__nearest_even nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (min_pos_value const-decl "posreal" extended_float nil)
    (xef_real_upper_bound formula-decl nil extended_float nil)
    (rnd_ucf_monotonic formula-decl nil float_props_rounding
     float_unbounded)
    (< const-decl "bool" reals nil)
    (float type-eq-decl nil float float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (max_pos_value const-decl "posreal" extended_float nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil))
   shostak))
 (rnd_ef_well_defined 0
  (rnd_ef_well_defined-2 "" 3884240648
   ("" (skeep* :preds? t)
    ((""
      (case "x <= max_pos_value AND
                         min_pos_value <= x")
      (("1" (flatten)
        (("1" (use "rtod_on_ranged_pos_is_in_range")
          (("1" (assert)
            (("1" (replace -7) (("1" (propax) nil nil)) nil)) nil))
          nil))
        nil)
       ("2"
        (case "x <= -min_pos_value AND
                               -max_pos_value <= x")
        (("1" (lemma "rtod_on_ranged_neg_is_in_range")
          (("1" (inst -1 "-x")
            (("1" (split -1)
              (("1" (flatten)
                (("1" (replace -7)
                  (("1" (use "rnd_opp_ucf")
                    (("1" (expand "Fopp")
                      (("1" (replace -1 :hide? t)
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil) ("3" (assert) nil nil))
              nil))
            nil))
          nil)
         ("2" (replace -4)
          (("2" (use "rtod_on_near_but_not_zero_is_in_range")
            (("2" (assert)
              (("2" (split -1)
                (("1" (propax) nil nil) ("2" (assert) nil nil)
                 ("3" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((min_pos_value const-decl "posreal" extended_float nil)
    (max_pos_value const-decl "posreal" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rtod_on_ranged_pos_is_in_range formula-decl nil
     extended_float_rounding__nearest_even nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix, precision, dExp]"
     extended_float_rounding__nearest_even nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rtod_on_near_but_not_zero_is_in_range formula-decl nil
     extended_float_rounding__nearest_even nil)
    (rtod_on_ranged_neg_is_in_range formula-decl nil
     extended_float_rounding__nearest_even nil)
    (Fopp const-decl "float" float float_unbounded)
    (minus_int_is_int application-judgement "int" integers nil)
    (rnd_opp_ucf formula-decl nil float_props_rounding float_unbounded)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)
  (rnd_ef_well_defined-1 nil 3765539256
   ("" (skeep :preds? t)
    ((""
      (case "x <= max_pos_value AND
           min_pos_value <= x")
      (("1" (flatten)
        (("1" (use "rtod_on_ranged_pos_is_in_range")
          (("1" (assert) nil nil)) nil))
        nil)
       ("2"
        (case "x <= -min_pos_value AND
             -max_pos_value <= x")
        (("1" (lemma "rtod_on_ranged_neg_is_in_range")
          (("1" (inst -1 "-x")
            (("1" (split -1)
              (("1" (flatten)
                (("1" (use "rnd_opp_ucf")
                  (("1" (expand "Fopp")
                    (("1" (replace -1 :hide? t)
                      (("1" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil) ("3" (assert) nil nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((min_pos_value const-decl "posreal" extended_float nil)
    (max_pos_value const-decl "posreal" extended_float nil)
    (rnd_opp_ucf formula-decl nil float_props_rounding float_unbounded)
    (Fopp const-decl "float" float float_unbounded))
   nil))
 (rnd_ef_TCC1 0
  (rnd_ef_TCC1-2 "" 3764929250 ("" (use "rnd_ef_well_defined") nil nil)
   ((rnd_ef_well_defined formula-decl nil
     extended_float_rounding__nearest_even nil))
   shostak
   (rnd_ef subtype "extended_float_rounding__nearest_even.rounded_x"
    "{v: float_props_rounding[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].max_exp), Fnum(v) /= 0)}"))
  (rnd_ef_TCC1-1 nil 3763829936
   (""
    (then (skeep :preds? t)
     (spread@ (case "x > 0")
      ((spread@ (case "x <= max_pos_value")
        ((then (lemma "bound_on_exp_of_rounded_erreal")
          (spread@ (inst -1 "max_pos_value")
           ((spread@
             (case "Fexp(rnd_ucf(x)) <= Fexp(rnd_ucf(max_pos_value))")
             ((spread@ (split 5)
               ((assert)
                (then (assert) (hide 4) (expand "/=")
                 (lemma "rnd_ucf_monotonic")
                 (inst -1 "min_pos_value" "x")
                 (spread@ (split -1)
                  ((spread@
                    (case "prj_ucf(rnd_ucf(min_pos_value)) = min_pos_value")
                    ((then (replace -1 :hide? t)
                      (spread@ (case "prj_ucf(rnd_ucf(x)) = 0")
                       ((then (replace -1 :hide? t) (eval-formula -1))
                        (then (expand "prj_ucf") (expand "FtoR")
                         (assert)))))
                     (spread@ (rewrite "dtor_rtod_on_er" 1 :dir rrl)
                      ((rewrite "dtor_rtod_on_er" 1 :dir rl)
                       (rewrite "min_pos_value_is_er")))))
                   (assert))))))
              (then (use "Lexico") (inst -1 "given_format")
               (spread@ (split -1)
                ((propax)
                 (then (use "EvenClosest_Monotone")
                  (expand "Monotone?") (inst -1 "given_format")
                  (inst -1 "x" "max_pos_value" "rnd_ucf(x)"
                   "rnd_ucf(max_pos_value)")
                  (spread@ (split -1)
                   ((propax)
                    (then (typepred "rnd_ucf(max_pos_value)")
                     (expand "currified_closest?_ucf")
                     (expand "closest?_ucf") (propax))
                    (then (typepred "rnd_ucf(x)")
                     (expand "currified_closest?_ucf")
                     (expand "closest?_ucf") (propax))
                    (spread@ (case "x=max_pos_value")
                     ((assert) (assert))))))
                 (then (expand ">")
                  (spread@ (case "0 <= x")
                   ((then (use "rnc_ucf_increasing") (assert)
                     (expand "<=" -1) (rewrite "FleCorrect")
                     (eval-expr "FtoR(rnd_ucf(0))") (assert))
                    (assert))))
                 (then (typepred "rnd_ucf(max_pos_value)") (propax))
                 (then (typepred "rnd_ucf(x)") (propax)))))))
            (then (rewrite "er_ub_correspondent" :dir rl) (assert)))))
         (assert)))
       (spread@ (case "x < 0")
        ((then (hide 1) (name "y" "-x")
          (spread@ (case "-y = x")
           ((then (replace -1 :dir rl :hide? t) (hide -1)
             (rewrite "rnd_opp_ucf") (expand "Fopp")
             (spread@ (case "0 < y")
              ((spread@ (case "y <= max_pos_value")
                ((then (lemma "bound_on_exp_of_rounded_erreal")
                  (spread@ (inst -1 "max_pos_value")
                   ((spread@
                     (case "Fexp(rnd_ucf(y)) <= Fexp(rnd_ucf(max_pos_value))")
                     ((spread@ (split 5)
                       ((assert)
                        (then (assert) (hide 2)
                         (lemma "rnd_ucf_monotonic")
                         (inst -1 "-y" "-min_pos_value")
                         (spread@ (split -1)
                          ((spread@
                            (case "prj_ucf(rnd_ucf(-min_pos_value)) = -min_pos_value")
                            ((then (replace -1 :hide? t)
                              (spread@
                               (case "prj_ucf(rnd_ucf(-y)) = 0")
                               ((then
                                 (replace -1 :hide? t)
                                 (eval-formula -1))
                                (spread@
                                 (case "Fnum(rnd_ucf(-y)) = 0")
                                 ((then
                                   (expand "prj_ucf")
                                   (expand "FtoR")
                                   (assert))
                                  (then
                                   (hide-all-but (-2 1))
                                   (lemma "rnd_opp_ucf")
                                   (inst -1 "-y")
                                   (spread@
                                    (case "--y=y")
                                    ((then
                                      (replace -1 :hide? t)
                                      (replace -1 :hide? t)
                                      (expand "Fopp")
                                      (assert))
                                     (assert)))))))))
                             (then
                              (rewrite "dtor_rtod_on_er" 1 :dir rl)
                              (use "exactly_representable_symm_0")
                              (assert)
                              (rewrite "min_pos_value_is_er"))))
                           (assert))))))
                      (then (use "Lexico") (inst -1 "given_format")
                       (spread@ (split -1)
                        ((propax)
                         (then (use "EvenClosest_Monotone")
                          (expand "Monotone?") (inst -1 "given_format")
                          (inst -1 "y" "max_pos_value" "rnd_ucf(y)"
                           "rnd_ucf(max_pos_value)")
                          (spread@ (split -1)
                           ((propax)
                            (then (typepred "rnd_ucf(max_pos_value)")
                             (expand "currified_closest?_ucf")
                             (expand "closest?_ucf") (propax))
                            (then (typepred "rnd_ucf(y)")
                             (expand "currified_closest?_ucf")
                             (expand "closest?_ucf") (propax))
                            (spread@ (case "y=max_pos_value")
                             ((assert) (assert))))))
                         (then (expand ">")
                          (spread@ (case "0 <= y")
                           ((then (use "rnc_ucf_increasing") (assert)
                             (expand "<=" -1) (rewrite "FleCorrect")
                             (eval-expr "FtoR(rnd_ucf(0))") (assert))
                            (assert))))
                         (then (typepred "rnd_ucf(max_pos_value)")
                          (propax))
                         (then (typepred "rnd_ucf(y)") (propax)))))))
                    (then (rewrite "er_ub_correspondent" :dir rl)
                     (assert)))))
                 (assert)))
               (assert))))
            (assert))))
         (assert))))))
    nil nil)
   nil nil
   (rnd_ef subtype "extended_float_rounding__nearest_even.rounded_x"
    "{v: float_props_rounding[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].max_exp), Fnum(v) /= 0)}")))
 (round_zero 0
  (round_zero-1 nil 3763829985
   ("" (expand "rnd_ef")
    (("" (lift-if 1)
      (("" (split 1)
        (("1" (flatten) (("1" (assert) nil nil)) nil)
         ("2" (flatten)
          (("2" (split 2)
            (("1" (propax) nil nil)
             ("2" (flatten)
              (("2" (assert)
                (("2" (use "prj_rnd_ucf_zero")
                  (("2" (expand "prj_ucf") (("2" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((prj_rnd_ucf_zero formula-decl nil float_props_rounding
     float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (poszero const-decl "efloat" extended_float nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (rnd_ef const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil))
   nil))
 (round_inverse_of_projection_on_nzfinite_TCC1 0
  (round_inverse_of_projection_on_nzfinite_TCC1-1 nil 3763829981
   ("" (subtype-tcc) nil nil)
   ((dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite? const-decl "bool" extended_float nil))
   nil
   (round_inverse_of_projection_on_nzfinite subtype
    "extended_float_rounding__nearest_even.f"
    "(extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].is_finite?)")))
 (round_inverse_of_projection_on_nzfinite 0
  (round_inverse_of_projection_on_nzfinite-1 nil 3764610474
   ("" (skeep :preds? t)
    (("" (expand "prj_ef")
      (("" (typepred "val(f)")
        (("" (case "rnd_ucf(prj_ucf(val(f))) = val(f)")
          (("1"
            (case "rnd_ef(prj_ucf(val(f))) = nzfinite(rnd_ucf(prj_ucf(val(f))))")
            (("1" (replace -1 :hide? t)
              (("1" (replace -1 :hide? t)
                (("1" (apply-extensionality 1) nil nil)) nil))
              nil)
             ("2" (hide 2)
              (("2" (expand "rnd_ef")
                (("2" (lift-if 1)
                  (("2"
                    (case "(-max_pos_value <= prj_ucf(val(f)) AND prj_ucf(val(f)) <= -min_pos_value) OR (min_pos_value<= prj_ucf(val(f)) AND prj_ucf(val(f)) <= max_pos_value)")
                    (("1" (split -1)
                      (("1" (assert)
                        (("1" (flatten)
                          (("1" (assert)
                            (("1" (split 1)
                              (("1"
                                (rewrite "rnd_prj_ucf")
                                (("1"
                                  (rewrite "ftor_zero_fnum")
                                  nil
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (assert)
                          (("2" (split 1)
                            (("1" (rewrite "rnd_prj_ucf")
                              (("1"
                                (rewrite "ftor_zero_fnum")
                                nil
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide 2)
                      (("2"
                        (lemma
                         "representability_limits_for_bounded_floats")
                        (("2"
                          (inst -1 "given_format" "max_exp" "val(f)")
                          (("2" (skoletin -1 :hide? nil)
                            (("2"
                              (rewrite
                               "min_pos_value__min_pos_unb_canonic_float__eq")
                              (("2"
                                (case
                                 "maximum_positive_bounded_value = max_pos_value")
                                (("1"
                                  (replace -1 :hide? t :dir rl)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (expand "prj_ucf")
                                      (("1"
                                        (split -1)
                                        (("1" (propax) nil nil)
                                         ("2"
                                          (use "ftor_zero_fnum")
                                          (("2" (assert) nil nil))
                                          nil)
                                         ("3" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand
                                   "maximum_positive_bounded_value")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "vNum")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "prj_ucf")
                                          (("2"
                                            (expand "max_pos_value")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (assert) nil nil))
            nil)
           ("2" (use "rnd_prj_ucf") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (f skolem-const-decl "(nzfinite?)"
     extended_float_rounding__nearest_even nil)
    (min_pos_value__min_pos_unb_canonic_float__eq formula-decl nil
     extended_float nil)
    (maximum_positive_bounded_value skolem-const-decl "int"
     extended_float_rounding__nearest_even nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (minimum_positive_bounded_value const-decl "posreal" float
     float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (posint_exp application-judgement "posint" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (minus_nzreal_is_nzreal application-judgement "nzreal" real_types
     nil)
    (^ const-decl "real" exponentiation nil)
    (vNum const-decl "posnat" float float_unbounded)
    (int_times_int_is_int application-judgement "int" integers nil)
    (representability_limits_for_bounded_floats formula-decl nil float
     float_unbounded)
    (ftor_zero_fnum formula-decl nil float float_unbounded)
    (rnd_prj_ucf formula-decl nil float_props_rounding float_unbounded)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (posinf const-decl "efloat" extended_float nil)
    (neginf const-decl "efloat" extended_float nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix, precision, dExp]"
     extended_float_rounding__nearest_even nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min_pos_value const-decl "posreal" extended_float nil)
    (max_pos_value const-decl "posreal" extended_float nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (efloat_nzfinite_extensionality formula-decl nil extended_float
     nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzfinite adt-constructor-decl
     "[{v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0} ->
   (nzfinite?)]" extended_float nil)
    (rnd_ef const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (Format type-eq-decl nil float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (efloat type-decl nil extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil))
   shostak))
 (proj_round_proj_on_finite 0
  (proj_round_proj_on_finite-1 nil 3806853926
   ("" (skeep :preds? t)
    (("" (expand "safe_prjct")
      (("" (case "zero?(f)")
        (("1" (expand "prj_ef")
          (("1" (replace -1)
            (("1" (rewrite "round_zero")
              (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (use "round_inverse_of_projection_on_nzfinite")
          (("1" (replace -1) (("1" (assert) nil nil)) nil)
           ("2" (expand "is_finite?") (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((safe_prjct const-decl "real" extended_float nil)
    (round_inverse_of_projection_on_nzfinite formula-decl nil
     extended_float_rounding__nearest_even nil)
    (f skolem-const-decl "(is_finite?)"
     extended_float_rounding__nearest_even nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (prj_ef const-decl "real" extended_float nil)
    (round_zero formula-decl nil extended_float_rounding__nearest_even
     nil)
    (poszero const-decl "efloat" extended_float nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (efloat type-decl nil extended_float nil)
    (zero? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (is_finite? const-decl "bool" extended_float nil))
   shostak))
 (rtoed_er_is_finite 0
  (rtoed_er_is_finite-1 nil 3765793922
   ("" (skeep)
    (("" (expand "rnd_ef")
      (("" (use "xef_real_lower_bound")
        (("" (lemma "xef_real_upper_bound")
          (("" (inst -1 "x")
            (("" (assert)
              (("" (expand "is_finite?") (("" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rnd_ef const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (xef_real_upper_bound formula-decl nil extended_float nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (negzero const-decl "efloat" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (xef_real_lower_bound formula-decl nil extended_float nil))
   nil))
 (round_er_eq_unb_TCC1 0
  (round_er_eq_unb_TCC1-2 nil 3799598050
   ("" (skeep :preds? t)
    (("" (split 2)
      (("1" (rewrite "bound_on_exp_of_rounded_erreal") nil nil)
       ("2" (use "er_canonic")
        (("2" (skeep :preds? t)
          (("2" (replace -3 :dir rl :hide? y)
            (("2" (lemma "rnd_prj_ucf")
              (("2" (inst -1 "f")
                (("2" (expand "prj_ucf")
                  (("2" (replace -1 :hide? t)
                    (("2" (expand "FtoR") (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (bound_on_exp_of_rounded_erreal formula-decl nil
     extended_float_rounding__nearest_even nil)
    (rnd_prj_ucf formula-decl nil float_props_rounding float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (float type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (<= const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (er_canonic formula-decl nil
     extended_float_exactly_representable_reals nil))
   nil
   (round_er_eq_unb subtype
    "float_props_rounding[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].rnd_ucf(extended_float_rounding__nearest_even.x)"
    "{v: float_props_rounding[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].max_exp), Fnum(v) /= 0)}"))
  (round_er_eq_unb_TCC1-1 nil 3799596511 ("" (subtype-tcc) nil nil) nil
   nil
   (round_er_eq_unb subtype
    "float_props_rounding[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].rnd_ucf(extended_float_rounding__nearest_even.x)"
    "{v: float_props_rounding[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].unb_canonic_float | booleans.AND(reals.<=(Fexp(v), extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].max_exp), Fnum(v) /= 0)}")))
 (round_er_eq_unb 0
  (round_er_eq_unb-2 "" 3884238318
   ("" (skeep :preds? t)
    (("" (expand "rnd_ef")
      (("" (lemma "er_lower_bound")
        (("" (inst -1 "x")
          (("" (lemma "er_upper_bound")
            (("" (inst -1 "x")
              (("" (rewrite "er_ub_correspondent")
                (("" (rewrite "er_lb_correspondent")
                  (("" (assert)
                    (("" (lift-if 2)
                      (("" (split 2)
                        (("1" (flatten)
                          (("1" (hide 1)
                            (("1" (replace -1 :dir rl :hide? t)
                              (("1"
                                (use "dtor_rtod_on_er")
                                (("1"
                                  (expand "prj_ucf")
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rnd_ef const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dtor_rtod_on_er formula-decl nil
     extended_float_rounding__nearest_even nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (emax const-decl "above(1)" extended_float nil))
   shostak)
  (round_er_eq_unb-1 nil 3799597959
   ("" (skeep :preds? t)
    (("" (expand "rnd_ef")
      (("" (use "er_lower_bound")
        (("" (use "er_upper_bound")
          (("" (rewrite "er_ub_correspondent")
            (("" (rewrite "er_lb_correspondent")
              (("" (assert)
                (("" (lift-if 2)
                  (("" (split 2)
                    (("1" (flatten)
                      (("1" (lemma "er_max_neg_prop")
                        (("1" (inst -1 "x")
                          (("1" (rewrite "er_max_neg_correspondent")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (use "er_min_pos_prop")
                            (("1" (rewrite "er_min_pos_correspondent")
                              (("1" (assert) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (use "er_upper_bound")
                                (("1"
                                  (use "er_ub_correspondent")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil))
   shostak))
 (proj_round_er_eq_unb_TCC1 0
  (proj_round_er_eq_unb_TCC1-2 nil 3799598079
   ("" (skeep :preds? t) (("" (use "rtoed_er_is_finite") nil nil)) nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (rtoed_er_is_finite formula-decl nil
     extended_float_rounding__nearest_even nil))
   nil
   (proj_round_er_eq_unb subtype
    "extended_float_rounding__nearest_even.rnd_ef(extended_float_rounding__nearest_even.x)"
    "(extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].is_finite?)"))
  (proj_round_er_eq_unb_TCC1-1 nil 3799596511
   ("" (subtype-tcc) nil nil) nil nil
   (proj_round_er_eq_unb subtype
    "extended_float_rounding__nearest_even.rnd_ef(extended_float_rounding__nearest_even.x)"
    "(extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].is_finite?)")))
 (proj_round_er_eq_unb 0
  (proj_round_er_eq_unb-2 "" 3884238486
   ("" (skeep :preds? t)
    (("" (lemma "er_lower_bound")
      (("" (inst -1 "x")
        (("" (lemma "er_upper_bound")
          (("" (inst -1 "x")
            (("" (rewrite "er_ub_correspondent")
              (("" (rewrite "er_lb_correspondent")
                (("" (expand "rnd_ef")
                  (("" (assert)
                    (("" (lift-if 1)
                      (("" (expand "prj_ef")
                        (("" (split 1)
                          (("1" (flatten)
                            (("1" (expand "prj_ucf")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rnd_ef const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (prj_ef const-decl "real" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic))
   shostak)
  (proj_round_er_eq_unb-1 nil 3799597959
   ("" (skeep :preds? t)
    (("" (use "er_lower_bound")
      (("" (use "er_upper_bound")
        (("" (rewrite "er_ub_correspondent")
          (("" (rewrite "er_lb_correspondent")
            (("" (expand "rnd_ef")
              (("" (assert)
                (("" (lift-if 1)
                  (("" (split 1)
                    (("1" (flatten)
                      (("1" (expand "prj_ef")
                        (("1" (lemma "er_max_neg_prop")
                          (("1" (inst -1 "x")
                            (("1" (rewrite "er_max_neg_correspondent")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (case "x=0")
                            (("1" (expand "prj_ef")
                              (("1"
                                (replace -1 :hide? t)
                                (("1"
                                  (rewrite "dtor_rtod_on_er")
                                  nil
                                  nil))
                                nil))
                              nil)
                             ("2" (lemma "er_min_pos_prop")
                              (("2"
                                (inst -1 "x")
                                (("1"
                                  (rewrite "er_min_pos_correspondent")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (expand "prj_ef")
                            (("2" (split 2)
                              (("1"
                                (flatten)
                                (("1"
                                  (use "er_upper_bound")
                                  (("1"
                                    (use "er_ub_correspondent")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (propax) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emax const-decl "above(1)" extended_float nil)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (prj_ef const-decl "real" extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic))
   shostak))
 (proj_round_on_er 0
  (proj_round_on_er-2 "" 3884238598
   ("" (skeep :preds? t)
    (("" (lemma "er_lower_bound")
      (("" (inst -1 "x")
        (("" (lemma "er_upper_bound")
          (("" (inst -1 "x")
            (("" (rewrite "er_ub_correspondent")
              (("" (rewrite "er_lb_correspondent")
                (("" (expand "rnd_ef")
                  (("" (assert)
                    (("" (expand "prj_ef")
                      (("" (lift-if 1)
                        (("" (split 1)
                          (("1" (flatten)
                            (("1" (replace -1 :dir rl :hide? t)
                              (("1"
                                (use "dtor_rtod_on_er")
                                (("1"
                                  (expand "prj_ucf")
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (use "dtor_rtod_on_er") nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rnd_ef const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dtor_rtod_on_er formula-decl nil
     extended_float_rounding__nearest_even nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic))
   shostak)
  (proj_round_on_er-1 nil 3799597959
   ("" (skeep :preds? t)
    (("" (use "er_lower_bound")
      (("" (use "er_upper_bound")
        (("" (rewrite "er_ub_correspondent")
          (("" (rewrite "er_lb_correspondent")
            (("" (expand "rnd_ef")
              (("" (assert)
                (("" (lift-if 1)
                  (("" (split 1)
                    (("1" (flatten)
                      (("1" (expand "prj_ef")
                        (("1" (lemma "er_max_neg_prop")
                          (("1" (inst -1 "x")
                            (("1" (rewrite "er_max_neg_correspondent")
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (split 2)
                        (("1" (flatten)
                          (("1" (case "x=0")
                            (("1" (expand "prj_ef")
                              (("1" (propax) nil nil)) nil)
                             ("2" (lemma "er_min_pos_prop")
                              (("2"
                                (inst -1 "x")
                                (("1"
                                  (rewrite "er_min_pos_correspondent")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (use "er_upper_bound")
                                (("1"
                                  (use "er_ub_correspondent")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (expand "prj_ef")
                                (("2" (use "dtor_rtod_on_er") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((emax const-decl "above(1)" extended_float nil)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (poszero const-decl "efloat" extended_float nil)
    (negzero const-decl "efloat" extended_float nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic))
   shostak))
 (round_is_injective_on_er 0
  (round_is_injective_on_er-1 nil 3799597959
   ("" (skeep :preds? t)
    (("" (case "x=0")
      (("1" (rewrite -1)
        (("1" (rewrite "round_zero")
          (("1" (expand "rnd_ef")
            (("1" (lift-if -3)
              (("1" (hide -1)
                (("1" (lemma "er_lower_bound")
                  (("1" (inst -1 "y")
                    (("1" (lemma "er_upper_bound")
                      (("1" (inst -1 "y")
                        (("1" (rewrite "er_ub_correspondent")
                          (("1" (rewrite "er_lb_correspondent")
                            (("1" (assert)
                              (("1"
                                (split -4)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (split -)
                                    (("1" (propax) nil nil)
                                     ("2"
                                      (replace -1 :dir rl :hide? t)
                                      (("2"
                                        (use "dtor_rtod_on_er")
                                        (("2"
                                          (expand "prj_ucf")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (case "y= 0")
        (("1" (rewrite -1)
          (("1" (hide 2)
            (("1" (rewrite "round_zero")
              (("1" (expand "rnd_ef")
                (("1" (lift-if -3)
                  (("1" (hide -2)
                    (("1" (lemma "er_lower_bound")
                      (("1" (inst -1 "x")
                        (("1" (lemma "er_upper_bound")
                          (("1" (inst -1 "x")
                            (("1" (rewrite "er_lb_correspondent")
                              (("1"
                                (rewrite "er_ub_correspondent")
                                (("1"
                                  (assert)
                                  (("1"
                                    (split -4)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (split -2)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (decompose-equality -2)
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (replace -1 :dir rl :hide? t)
                                          (("2"
                                            (use "dtor_rtod_on_er")
                                            (("2"
                                              (expand "prj_ucf")
                                              (("2" (propax) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (case "rnd_ucf(x) = rnd_ucf(y)")
          (("1" (hide -4)
            (("1" (typepred "rnd_ucf(x)")
              (("1" (expand "currified_closest?_ucf")
                (("1" (expand "closest?_ucf")
                  (("1" (use "EvenClosest_Unique")
                    (("1" (expand "Unique?")
                      (("1" (inst -1 "x" "rnd_ucf(x)" "rnd_ucf(y)")
                        (("1" (split -1)
                          (("1" (lemma "proj_round_on_er")
                            (("1" (inst -1 "x")
                              (("1"
                                (lemma "proj_round_on_er")
                                (("1"
                                  (inst -1 "y")
                                  (("1"
                                    (rewrite "proj_round_er_eq_unb")
                                    (("1"
                                      (rewrite "proj_round_er_eq_unb")
                                      (("1"
                                        (expand "prj_ucf")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil)
                           ("3" (propax) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (lemma "round_er_eq_unb")
            (("2" (inst -1 "x")
              (("2" (rewrite -1)
                (("2" (lemma "round_er_eq_unb")
                  (("2" (inst -1 "y")
                    (("2" (rewrite -1)
                      (("2" (decompose-equality -3) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (round_zero formula-decl nil extended_float_rounding__nearest_even
     nil)
    (poszero const-decl "efloat" extended_float nil)
    (er_lower_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_upper_bound formula-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (negzero const-decl "efloat" extended_float nil)
    (zero_exclusive formula-decl nil extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dtor_rtod_on_er formula-decl nil
     extended_float_rounding__nearest_even nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (er_lb_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (rnd_ef const-decl "efloat" extended_float_rounding__nearest_even
     nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float float_unbounded)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Unique? const-decl "bool" float float_unbounded)
    (proj_round_er_eq_unb formula-decl nil
     extended_float_rounding__nearest_even nil)
    (proj_round_on_er formula-decl nil
     extended_float_rounding__nearest_even nil)
    (EvenClosest_Unique formula-decl nil float float_unbounded)
    (x skolem-const-decl "er_real[radix, precision, emax]"
     extended_float_rounding__nearest_even nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (max_exp const-decl "posint" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil)
    (nzfinite adt-constructor-decl
     "[{v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0} ->
   (nzfinite?)]" extended_float nil)
    (y skolem-const-decl "er_real[radix, precision, emax]"
     extended_float_rounding__nearest_even nil)
    (round_er_eq_unb formula-decl nil
     extended_float_rounding__nearest_even nil)
    (TRUE const-decl "bool" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (zero adt-constructor-decl "[bool -> (zero?)]" extended_float nil)
    (positive? shared-adt-accessor-decl
     "[{x: efloat | infinite?(x) OR zero?(x)} -> bool]" extended_float
     nil)
    (zero? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (infinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (efloat type-decl nil extended_float nil))
   shostak))
 (ieee754_semantics_round_proj_interpretation_obligation_1_TCC1 0
  (ieee754_semantics_round_proj_interpretation_obligation_1_TCC1-1 nil
   3799596511 ("" (subtype-tcc) nil nil)
   ((dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_finite? const-decl "bool" extended_float nil))
   nil
   (ieee754_semantics_round_proj_interpretation_obligation_1 subtype
    "extended_float_rounding__nearest_even.f"
    "(extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].is_finite?)")))
 (ieee754_semantics_round_proj_interpretation_obligation_1 0
  (ieee754_semantics_round_proj_interpretation_obligation_1-1 nil
   3799597959
   (""
    (then (skeep) (use "round_inverse_of_projection_on_nzfinite")
     (assert))
    nil nil)
   ((posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (efloat type-decl nil extended_float nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (round_inverse_of_projection_on_nzfinite formula-decl nil
     extended_float_rounding__nearest_even nil))
   shostak))
 (ieee754_semantics_nzfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_nzfinite?_def_interpretation_obligation_1-1 nil
   3799597960
   ("" (then (skeep) (mapped-axiom-tcc) (grind-reals)) nil nil)
   ((nonzero_times3 formula-decl nil real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (/= const-decl "boolean" notequal nil)
    (is_finite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (prj_ef const-decl "real" extended_float nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil))
   shostak))
 (ieee754_semantics_pfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_pfinite?_def_interpretation_obligation_1-1 nil
   3799597960
   ("" (skeep)
    (("" (mapped-axiom-tcc)
      (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil))
    nil)
   ((even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nzpfinite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (pos_times_gt formula-decl nil real_props nil))
   shostak))
 (ieee754_semantics_nfinite?_def_interpretation_obligation_1 0
  (ieee754_semantics_nfinite?_def_interpretation_obligation_1-1 nil
   3799597960
   ("" (skeep)
    (("" (mapped-axiom-tcc)
      (("1" (grind-reals) nil nil) ("2" (grind-reals) nil nil)) nil))
    nil)
   ((even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nznfinite? const-decl "bool" extended_float nil)
    (zero_inclusive formula-decl nil extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (prj_ef const-decl "real" extended_float nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (neg_times_lt formula-decl nil real_props nil))
   shostak))
 (ieee754_semantics_add_inv_def_interpretation_obligation_1_TCC1 0
  (ieee754_semantics_add_inv_def_interpretation_obligation_1_TCC1-1 nil
   3799596511 ("" (subtype-tcc) nil nil)
   ((radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Fopp const-decl "float" float float_unbounded)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (flip_sign const-decl "efloat" extended_float nil)
    (is_finite? const-decl "bool" extended_float nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (int_times_int_is_int application-judgement "int" integers nil))
   nil
   (ieee754_semantics_add_inv_def_interpretation_obligation_1 subtype
    "extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].flip_sign(extended_float_rounding__nearest_even.f)"
    "(extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].is_finite?)")))
 (ieee754_semantics_add_inv_def_interpretation_obligation_1 0
  (ieee754_semantics_add_inv_def_interpretation_obligation_1-1 nil
   3799597960
   (""
    (then (skeep :preds? t) (expand "flip_sign") (expand "prj_ef")
     (expand "prj_ucf") (use "FoppCorrect"))
    nil nil)
   ((prj_ef const-decl "real" extended_float nil)
    (val adt-accessor-decl "[(nzfinite?) ->
   {v: unb_canonic_float | Fexp(v) <= max_exp AND Fnum(v) /= 0}]"
         extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nzfinite? adt-recognizer-decl "[efloat -> boolean]" extended_float
     nil)
    (efloat type-decl nil extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (float type-eq-decl nil float float_unbounded)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (FoppCorrect formula-decl nil float float_unbounded)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (flip_sign const-decl "efloat" extended_float nil))
   shostak))
 (proj_round_is_monotone_on_er_TCC1 0
  (proj_round_is_monotone_on_er_TCC1-2 nil 3799598110
   ("" (skeep) (("" (use "rtoed_er_is_finite") nil nil)) nil)
   ((er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (xef_real nonempty-type-eq-decl nil extended_float nil)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (rtoed_er_is_finite formula-decl nil
     extended_float_rounding__nearest_even nil))
   nil
   (proj_round_is_monotone_on_er subtype
    "extended_float_rounding__nearest_even.rnd_ef(extended_float_rounding__nearest_even.y)"
    "(extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].is_finite?)"))
  (proj_round_is_monotone_on_er_TCC1-1 nil 3799596511
   ("" (subtype-tcc) nil nil) nil nil
   (proj_round_is_monotone_on_er subtype
    "extended_float_rounding__nearest_even.rnd_ef(extended_float_rounding__nearest_even.y)"
    "(extended_float[extended_float_rounding__nearest_even.radix, extended_float_rounding__nearest_even.precision, extended_float_rounding__nearest_even.dExp].is_finite?)")))
 (proj_round_is_monotone_on_er 0
  (proj_round_is_monotone_on_er-1 nil 3799597960
   ("" (skeep :preds? t)
    (("" (rewrite "proj_round_er_eq_unb")
      (("" (rewrite "proj_round_er_eq_unb")
        (("" (typepred "rnd_ucf(x)")
          (("" (expand "currified_closest?_ucf")
            (("" (use "closest?_ucf__j")
              (("" (flatten)
                (("" (expand "rounded_mode?")
                  (("" (flatten)
                    (("" (expand "monotone?")
                      (("" (inst -5 "x" "y" "rnd_ucf(x)" "rnd_ucf(y)")
                        (("" (split -5)
                          (("1" (expand "prj_ucf")
                            (("1" (propax) nil nil)) nil)
                           ("2" (case "x=y")
                            (("1" (assert) nil nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("3" (propax) nil nil)
                           ("4" (typepred "rnd_ucf(y)")
                            (("4" (expand "currified_closest?_ucf")
                              (("4" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((proj_round_er_eq_unb formula-decl nil
     extended_float_rounding__nearest_even nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_rounding__nearest_even nil)
    (precision formal-const-decl "above(1)"
     extended_float_rounding__nearest_even nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_rounding__nearest_even nil)
    (emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (rnd_ucf_is_canonic_rounding_closest_ucf name-judgement
     "CanonicRoundingFun[radix]((# Prec := precision, dExp := dExp #),
                          closest?_ucf)"
     extended_float_rounding__nearest_even nil)
    (rnd_ucf const-decl
     "{f: unb_canonic_float | currified_closest?_ucf(x1)(f)}"
     float_props_rounding float_unbounded)
    (currified_closest?_ucf const-decl "bool" float_props_rounding
     float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_rounding__nearest_even nil)
    (closest?_ucf__j judgement-tcc nil float_props_rounding
     float_unbounded)
    (closest?_ucf__j name-judgement "{round:
   RestrictedRounding[radix]((# Prec := precision, dExp := dExp #),
                             EvenClosest?) |
   rounded_mode?((# Prec := precision, dExp := dExp #))(round)}"
     extended_float_rounding__nearest_even nil)
    (rounded_mode? const-decl "bool" float float_unbounded)
    (monotone? const-decl "bool" float float_unbounded)
    (prj_ucf const-decl "real" float_props_rounding float_unbounded)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   shostak)))


(extended_float_exactly_representable_reals
 (er_rat_to_er_int__exponent__le_max_exp 0
  (er_rat_to_er_int__exponent__le_max_exp-2 "" 3790103802
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__exponent")
      (("" (expand "max_exp")
        (("" (assert) (("" (expand "emin") (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (odd_minus_even_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (emax const-decl "above(1)" extended_float nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (max_exp const-decl "posint" extended_float nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil))
   shostak)
  (er_rat_to_er_int__exponent__le_max_exp-1 nil 3763920022
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__exponent")
      (("" (expand "max_exp")
        (("" (assert)
          (("" (expand "emin")
            (("" (expand "min_exp") (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((emax const-decl "above(1)" extended_float nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (max_exp const-decl "posint" extended_float nil))
   shostak))
 (er_rat_to_er_int__exponent__ge_min_exp 0
  (er_rat_to_er_int__exponent__ge_min_exp-1 nil 3763920022
   ("" (expand "er_rat_to_er_int__exponent")
    (("" (skeep :preds? t)
      (("" (expand "min_exp") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (max_exp const-decl "posint" extended_float nil)
    (emax const-decl "above(1)" extended_float nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (min_exp const-decl "negint" extended_float nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil))
   shostak))
 (sigma_on_nat_TCC1 0
  (sigma_on_nat_TCC1-1 nil 3790102174 ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (integer nonempty-type-from-decl nil integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sigma_on_nat assuming "sigma[nat].sigma"
    "connected_domain: ASSUMPTION (FORALL (x, y: sigma.T), (z: integers.integer): booleans.IMPLIES(booleans.AND(reals.<=(x, z), reals.<=(z, y)), sigma.T_pred(z)))")))
 (er_rat_to_er_int__significand_TCC1 0
  (er_rat_to_er_int__significand_TCC2-1 nil 3763919900
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max_exp const-decl "posint" extended_float nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (er_rat_to_er_int__significand subtype
    "((number_fields.-)((number_fields.-)(extended_float_exactly_representable_reals.precision, 1), extended_float_exactly_representable_reals.i))"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int__significand_TCC2 0
  (er_rat_to_er_int__significand_TCC1-1 nil 3763919900
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (nzreal_expt application-judgement "nzreal" exponentiation nil)
    (int_expt application-judgement "int" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (max_exp const-decl "posint" extended_float nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (^ const-decl "real" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (er_rat_to_er_int__significand subtype
    "number_fields.*(exponentiation.^(((number_fields.-)(1)), extended_float_exactly_representable_reals.s), sigma[nat].sigma(0, (number_fields.-)(extended_float_exactly_representable_reals.precision, 1), LAMBDA (i: naturalnumbers.nat): IF reals.<(i, extended_float_exactly_representable_reals.precision) THEN number_fields.*(extended_float_exactly_representable_reals.m(i), exponentiation.^(extended_float_exactly_representable_reals.radix, ((number_fields.-)((number_fields.-)(extended_float_exactly_representable_reals.precision, 1), i)))) ELSE 0 ENDIF))"
    "int")))
 (er_rat_to_er_int__significand__abs_lt_radix_pow_prec_TCC1 0
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec_TCC1-1 nil
   3765203177 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (max_exp const-decl "posint" extended_float nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (er_rat_to_er_int__significand__abs_lt_radix_pow_prec subtype
    "extended_float_exactly_representable_reals.precision"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int__significand__abs_lt_radix_pow_prec 0
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec-2 "" 3765353041
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__significand")
      (("" (invoke (name-replace "significand_value" "%1") (! 1 1 1 2))
        (("1" (case "0 <= significand_value")
          (("1"
            (case "abs((-1) ^ s * significand_value) = significand_value")
            (("1" (replace -1 :hide? t)
              (("1" (expand "significand_value")
                (("1" (hide -1)
                  (("1"
                    (case "FORALL (j: nat): j < precision IMPLIES -1 - j + precision >= 0")
                    (("1" (assert)
                      (("1" (hide -1)
                        (("1"
                          (case "sigma[nat]
                                                                    (0, precision - 1,
                                                                     LAMBDA (i: nat):
                                                                       IF i < precision THEN m(i) * radix ^ (-1 - i + precision)
                                                                       ELSE 0
                                                                       ENDIF) = sigma[nat]
                                                                    (0, precision - 1,
                                                                     LAMBDA (j: nat):
                                                                       IF j < precision THEN m(precision-1-j) * radix ^ j
                                                                       ELSE 0
                                                                       ENDIF)")
                          (("1" (replace -1 :hide? t)
                            (("1" (lemma "sigma_le[nat]")
                              (("1"
                                (inst
                                 -1
                                 "LAMBDA(j:nat): IF j < precision THEN m(precision - 1 - j) * radix ^ j
                                                           ELSE 0
                                                           ENDIF"
                                 "LAMBDA(j:nat): (radix-1) * radix ^ j"
                                 "precision-1"
                                 "0")
                                (("1"
                                  (split -1)
                                  (("1"
                                    (use "sigma_scal[nat]")
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1"
                                        (use
                                         "sigma_nat.sigma_geometric")
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (replace -1 :hide? t)
                                            (("1"
                                              (invoke
                                               (case "%1 < %2")
                                               (! -1 2)
                                               (! 1 2))
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2"
                                                  (case
                                                   "(radix - 1) *
                                                         ((radix ^ 0 - radix ^ (precision - 1 + 1)) / (1 - radix)) = ((radix - 1)/ (1 - radix)) *
                                                         (radix ^ 0 - radix ^ (precision - 1 + 1))")
                                                  (("1"
                                                    (replace
                                                     -1
                                                     :hide?
                                                     t)
                                                    (("1"
                                                      (case
                                                       "((radix - 1) / (1 - radix)) *
                                                             (radix ^ 0 - radix ^ (precision - 1 + 1)) = radix ^ precision - 1")
                                                      (("1"
                                                        (replace
                                                         -1
                                                         :hide?
                                                         t)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (grind-reals)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil)
                                           ("3" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (skeep :preds? t)
                                      (("2"
                                        (lift-if 1)
                                        (("2"
                                          (split 1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (typepred
                                               "m(precision -1 - n)")
                                              (("1"
                                                (case
                                                 "m(precision - 1 - n) <= radix-1")
                                                (("1"
                                                  (hide -2)
                                                  (("1"
                                                    (mult-by
                                                     -1
                                                     "radix^n")
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide-all-but 1)
                            (("2" (lemma "sigma_downwards[nat]")
                              (("2"
                                (inst
                                 -1
                                 "LAMBDA (j: nat):
              IF j < precision THEN m(precision - 1 - j) * radix ^ j
              ELSE 0
              ENDIF"
                                 "precision-1"
                                 "0"
                                 "precision-1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (replace -1 :hide? t)
                                    (("1"
                                      (use "sigma_eq[nat]")
                                      (("1"
                                        (split -1)
                                        (("1" (propax) nil nil)
                                         ("2" (assert) nil nil))
                                        nil)
                                       ("2"
                                        (hide 2)
                                        (("2"
                                          (skeep)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (skeep)
                                  (("2"
                                    (hide 2)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (hide 2)
                        (("2" (skeep) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but (-1 1 -2))
              (("2" (expand "abs") (("2" (grind-reals) nil nil)) nil))
              nil))
            nil)
           ("2" (hide-all-but 1)
            (("2" (expand "significand_value")
              (("2" (use "sigma_nonneg[nat]")
                (("1" (expand ">=")
                  (("1" (assert)
                    (("1" (hide 2)
                      (("1" (skeep)
                        (("1" (lift-if 1)
                          (("1" (split 1)
                            (("1" (flatten) (("1" (assert) nil nil))
                              nil)
                             ("2" (flatten) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (skeep) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (neg_times_lt formula-decl nil real_props nil)
    (int_exp application-judgement "int" exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (sigma_le formula-decl nil sigma reals)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (times_div1 formula-decl nil real_props nil)
    (div_distributes_minus formula-decl nil real_props nil)
    (div_cancel3 formula-decl nil real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (sigma_geometric formula-decl nil sigma_nat reals)
    (sigma_scal formula-decl nil sigma reals)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subrange type-eq-decl nil integers nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (sigma_downwards formula-decl nil sigma reals)
    (sigma_eq formula-decl nil sigma reals)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (significand_value skolem-const-decl "rational"
     extended_float_exactly_representable_reals nil)
    (sign type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (rat_abs_is_nonneg application-judgement "{r: nonneg_rat | r >= q}"
     real_defs nil)
    (sigma_nonneg formula-decl nil sigma reals)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (T_low type-eq-decl nil sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (sigma def-decl "real" sigma reals)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (< const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (significand type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil))
   shostak)
  (er_rat_to_er_int__significand__abs_lt_radix_pow_prec-1 nil
   3763919910
   ("" (skeep :preds? t)
    (("" (expand "er_rat_to_er_int__significand")
      ((""
        (case "sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(i) * 2 ^ (52 - i)) = sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(52 - i) * 2 ^ i)")
        (("1" (replace -1 :hide? t)
          (("1"
            (case "sigma[below(53)] (0, 52, LAMBDA (i: below(53)): m(52-i) * 2 ^ i) = sigma[nat] (0, 52, LAMBDA (i: nat): IF 52-i >= 0 AND 52-i < 53 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF)")
            (("1" (replace -1 :hide? t)
              (("1"
                (name-replace "significand_value"
                 "sigma[nat] (0, 52, LAMBDA (i: nat): IF 52-i >= 0 AND 52-i < 53 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF)")
                (("1" (case "0 <= significand_value")
                  (("1"
                    (case "abs((-1) ^ s * significand_value) = significand_value")
                    (("1" (replace -1 :hide? t)
                      (("1" (case "significand_value <= 2^53 - 1")
                        (("1" (assert) nil nil)
                         ("2" (hide 2)
                          (("2" (expand "significand_value")
                            (("2"
                              (case "sigma[nat](0, 52,  LAMBDA (i: nat): IF 52-i >= 0 THEN m(52-i) * 2 ^ i ELSE 0 ENDIF) <= sigma[nat](0, 52, LAMBDA (i: nat): 2 ^ i)")
                              (("1"
                                (use "sigma_nat.sigma_geometric")
                                (("1" (assert) nil nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (use "sigma_le[nat]")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (hide 2)
                                      (("2"
                                        (skeep :preds? t)
                                        (("2"
                                          (typepred "m(52-n)")
                                          (("2" (grind-reals) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (-1 1 -2))
                      (("2" (expand "abs")
                        (("2" (grind-reals) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (hide-all-but 1)
                    (("2" (expand "significand_value")
                      (("2" (use "sigma_nonneg[nat]")
                        (("2" (expand ">=") (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide-all-but 1)
              (("2" (for 54 (expand "sigma")) nil nil)) nil))
            nil))
          nil)
         ("2" (hide-all-but 1)
          (("2"
            (for 52
             (then (rewrite "sigma_first_ge")
              (rewrite "sigma_last_ge" 1
               ("F" "LAMBDA (i: below(53)): m(52 - i) * 2 ^ i"))
              (assert)))
            (("2" (expand "sigma")
              (("2" (expand "sigma") (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((significand type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (sigma def-decl "real" sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (sigma_nonneg formula-decl nil sigma reals)
    (sign type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (sigma_le formula-decl nil sigma reals)
    (sigma_geometric formula-decl nil sigma_nat reals)
    (sigma_first_ge formula-decl nil sigma_below reals)
    (int_below type-eq-decl nil sigma_below reals)
    (sigma_last_ge formula-decl nil sigma_below reals))
   shostak))
 (er_rat_to_er_int_value_TCC1 0
  (er_rat_to_er_int_value_TCC1-1 nil 3765203177
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (exponent type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max_exp const-decl "posint" extended_float nil)
    (/= const-decl "boolean" notequal nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (^ const-decl "real" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil))
   shostak
   (er_rat_to_er_int_value subtype
    "extended_float_exactly_representable_reals.exponent"
    "{i: integers.int | booleans.OR(extended_float_exactly_representable_reals.radix /= 0, reals.>=(i, 0))}")))
 (er_rat_to_er_int_value 0
  (er_rat_to_er_int_value-1 nil 3763919910
   ("" (skeep :preds? t)
    (("" (beta)
      (("" (expand "er_rat_to_er_int__significand")
        (("" (expand "er_rat_to_er_int__exponent")
          (("" (expand "value")
            ((""
              (case "(radix ^ (e!1 - (precision-1))) * (-1) ^ s * sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision THEN m(i) * radix ^ (-1 - i + precision)
               ELSE 0
               ENDIF) = radix ^ e!1 * (-1) ^ s * radix ^(-(precision-1)) * sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision THEN  m(i) * radix ^ (precision-1) * radix ^(- i)ELSE 0
               ENDIF)")
              (("1" (replace -1 :hide? t)
                (("1"
                  (case "radix ^ (-(precision-1)) * sigma (0, (precision-1), LAMBDA (i: nat):
                IF i < precision
                  THEN m(i) * radix ^ (precision - 1) * radix ^ (-i)
                ELSE 0
                ENDIF) = sigma(0, (precision-1), LAMBDA (i: nat): IF i < precision
                  THEN m(i) * radix ^ (-i)ELSE 0
                ENDIF)")
                  (("1" (assert) nil nil)
                   ("2" (hide 2)
                    (("2" (lemma "sigma[nat].sigma_scal")
                      (("2" (inst? -1)
                        (("1" (replace -1 :hide? t :dir rl)
                          (("1" (rewrite "sigma[nat].sigma_eq")
                            (("1" (hide-all-but 1)
                              (("1"
                                (skeep :preds? t)
                                (("1"
                                  (swap
                                   "m(n)"
                                   "*"
                                   "radix ^ (precision-1) * radix ^ (-n)")
                                  (("1"
                                    (case
                                     "radix ^ (-(precision-1)) * ((radix ^ (precision-1) * radix ^ (-n)) * (m(n))) = (radix ^ (-(precision-1)) * radix ^ (precision-1)) * radix ^ (-n) * (m(n))")
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1"
                                        (rewrite "expt_plus" :dir rl)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (skeep) (("2" (assert) nil nil)) nil)
                         ("3" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2"
                  (case "(radix ^ (e!1 - (precision-1))) = radix ^ e!1 * radix ^ (- (precision-1))")
                  (("1" (replace -1 :hide? t)
                    (("1" (lemma "sigma[nat].sigma_eq")
                      (("1" (inst? -1 :where 1)
                        (("1"
                          (inst -1
                           "LAMBDA (i: nat): IF i < precision THEN m(i) * radix ^ (precision-1) * radix ^ (-i) ELSE 0 ENDIF")
                          (("1" (split -1)
                            (("1" (assert) nil nil)
                             ("2" (hide 2)
                              (("2"
                                (skeep :preds? t)
                                (("2"
                                  (lift-if 1)
                                  (("2"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (case
                                         "(precision-1) - n = (precision-1) + -n")
                                        (("1"
                                          (replace -1 :hide? t)
                                          (("1"
                                            (rewrite "expt_plus")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil)
                                         ("2" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert) nil nil)
                           ("3" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide 2)
                    (("2"
                      (case "e!1 - (precision-1) = e!1 + -(precision-1)")
                      (("1" (replace -1 :hide? t)
                        (("1" (rewrite "expt_plus") nil nil)) nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (assert) nil nil) ("4" (assert) nil nil)
               ("5" (assert) nil nil) ("6" (assert) nil nil)
               ("7" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (significand type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (below type-eq-decl nil naturalnumbers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma def-decl "real" sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (sign type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (exponent type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (^ const-decl "real" exponentiation nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (sigma_scal formula-decl nil sigma reals)
    (subrange type-eq-decl nil integers nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (sigma_eq formula-decl nil sigma reals)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (rat_exp application-judgement "rat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (value const-decl "real" ieee754_domain float_bounded_axiomatic)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_ub_correspondent 0
  (er_ub_correspondent-1 nil 3763920022
   ("" (expand "max_pos_value")
    (("" (expand "er_ub")
      (("" (expand "value")
        (("" (expand "emax")
          (("" (expand "smax" :assert? none)
            ((""
              (case "((-1) ^ 0 * radix ^ (max_exp - 1 + precision)) *
              sigma(0, precision - 1,
                    LAMBDA (i: nat):
                      IF i < precision THEN (radix - 1) * radix ^ (-i)
                      ELSE 0
                      ENDIF) = radix ^ max_exp * (radix-1) * sigma(0, precision - 1,
                    LAMBDA (j: nat):
                      radix ^ j)")
              (("1" (replace -1 :hide? t)
                (("1" (use "sigma_nat.sigma_geometric")
                  (("1" (split -1)
                    (("1" (replace -1 :hide? t)
                      (("1" (grind-reals) nil nil)) nil)
                     ("2" (assert) nil nil) ("3" (assert) nil nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil)
               ("2" (hide 2)
                (("2" (lemma "sigma[nat].sigma_eq")
                  (("2"
                    (inst -1 "LAMBDA (i: nat):
                   IF i < precision THEN (radix - 1) * radix ^ (-i)
                   ELSE 0
                   ENDIF" "LAMBDA (i: nat): (radix - 1) * radix ^ (-i)"
                     "precision-1" "0")
                    (("1" (split -1)
                      (("1" (replace -1 :hide? t)
                        (("1" (lemma "sigma[nat].sigma_scal")
                          (("1"
                            (inst -1 "LAMBDA (i: nat):radix ^ (-i)"
                             "(radix-1)" "precision-1" "0")
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (case
                                 "radix ^ (max_exp - 1 + precision) = radix ^ max_exp * radix ^ ( - 1 + precision)")
                                (("1"
                                  (replace -1 :hide? t)
                                  (("1"
                                    (case
                                     "((-1) ^ 0 * (radix ^ max_exp * radix ^ (-1 + precision))) *
                        ((radix - 1) *
                          sigma(0, precision - 1, LAMBDA (i: nat): radix ^ (-i))) = (-1) ^ 0 * radix ^ max_exp  *
                        (radix - 1) * (radix ^ (-1 + precision) *
                          sigma(0, precision - 1, LAMBDA (i: nat): radix ^ (-i)))")
                                    (("1"
                                      (replace -1 :hide? t)
                                      (("1"
                                        (lemma "sigma[nat].sigma_scal")
                                        (("1"
                                          (inst
                                           -1
                                           "LAMBDA (i: nat): radix ^ (-i)"
                                           "radix ^ (-1 + precision)"
                                           "precision-1"
                                           "0")
                                          (("1"
                                            (replace
                                             -1
                                             :hide?
                                             rl
                                             :dir
                                             rl)
                                            (("1"
                                              (lemma
                                               "sigma[nat].sigma_eq")
                                              (("1"
                                                (inst
                                                 -1
                                                 "LAMBDA (i_1: nat): radix ^ (-1 + precision) * radix ^ (-i_1)"
                                                 "LAMBDA (i_1: nat): radix ^ (-1 + precision -i_1)"
                                                 "precision-1"
                                                 "0")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (replace
                                                     -1
                                                     :hide?
                                                     t)
                                                    (("1"
                                                      (invoke
                                                       (case "%1 = %2")
                                                       (! 1 1 4)
                                                       (! 1 2 3))
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (hide 2)
                                                        (("2"
                                                          (lemma
                                                           "sigma_downwards")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "LAMBDA (j: nat): radix ^ j"
                                                             "precision-1"
                                                             "0"
                                                             "precision-1")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (replace
                                                                 -1
                                                                 :hide?
                                                                 t)
                                                                (("1"
                                                                  (lemma
                                                                   "sigma[nat].sigma_eq")
                                                                  (("1"
                                                                    (inst?
                                                                     -1)
                                                                    (("1"
                                                                      (split
                                                                       -1)
                                                                      (("1"
                                                                        (propax)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (hide
                                                                         2)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (hide
                                                                       2)
                                                                      (("2"
                                                                        (skeep)
                                                                        (("2"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("3"
                                                                      (hide
                                                                       2)
                                                                      (("3"
                                                                        (skeep)
                                                                        (("3"
                                                                          (assert)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (hide 2)
                                                        (("3"
                                                          (skeep)
                                                          (("3"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide-all-but 1)
                                                    (("2"
                                                      (skeep :preds? t)
                                                      (("2"
                                                        (lemma
                                                         "expt_plus")
                                                        (("2"
                                                          (inst
                                                           -1
                                                           "-1+precision"
                                                           "-n"
                                                           "radix")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2" (assert) nil nil)
                                                 ("3" (assert) nil nil)
                                                 ("4"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide-all-but 1)
                                      (("2" (assert) nil nil))
                                      nil)
                                     ("3" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (lemma "expt_plus")
                                    (("2"
                                      (inst
                                       -1
                                       "max_exp"
                                       "-1+precision"
                                       "radix")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil)
                     ("2" (assert) nil nil) ("3" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("3" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((er_ub const-decl "er_real" ieee754_domain float_bounded_axiomatic)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (emax const-decl "above(1)" extended_float nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma def-decl "real" sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max_exp const-decl "posint" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (>= const-decl "bool" reals nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real nonempty-type-from-decl nil reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (int_times_int_is_int application-judgement "int" integers nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (sigma_geometric formula-decl nil sigma_nat reals)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (div_cancel3 formula-decl nil real_props nil)
    (div_distributes_minus formula-decl nil real_props nil)
    (times_div2 formula-decl nil real_props nil)
    (times_div1 formula-decl nil real_props nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (sigma_eq formula-decl nil sigma reals)
    (sigma_scal formula-decl nil sigma reals)
    (sigma_nnreal application-judgement "nnreal" sigma_nat reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (sigma_downwards formula-decl nil sigma reals)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (subrange type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (expt_plus formula-decl nil exponentiation nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (smax const-decl "significand" ieee754_domain
     float_bounded_axiomatic)
    (value const-decl "real" ieee754_domain float_bounded_axiomatic)
    (max_pos_value const-decl "posreal" extended_float nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_lb_correspondent 0
  (er_lb_correspondent-1 nil 3763920022
   ("" (expand "er_lb")
    (("" (use "er_ub_correspondent")
      (("" (expand "er_ub")
        (("" (replace -1 :hide? t :dir rl)
          (("" (expand "value") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((er_ub_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (max_pos_value_xef_real name-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (posint_exp application-judgement "posint" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (value const-decl "real" ieee754_domain float_bounded_axiomatic)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (er_ub const-decl "er_real" ieee754_domain float_bounded_axiomatic)
    (er_lb const-decl "er_real" ieee754_domain
     float_bounded_axiomatic))
   shostak))
 (er_min_pos_correspondent 0
  (er_min_pos_correspondent-1 nil 3763920022
   ("" (expand "er_min_pos")
    (("" (expand "min_pos_value")
      (("" (case "emin = min_exp + precision - 1")
        (("1" (replace -1 :hide? t)
          (("1" (expand "smin")
            (("1" (expand "value")
              (("1"
                (case "sigma(0, precision - 1,
                    LAMBDA (i_1: nat):
                      IF i_1 < precision
                        THEN IF i_1 = precision - 1 THEN 1 ELSE 0 ENDIF *
                              radix ^ (-i_1)
                      ELSE 0
                      ENDIF) = radix ^ (-precision+1)")
                (("1" (replace -1 :hide? t)
                  (("1" (assert)
                    (("1" (lemma "expt_plus")
                      (("1"
                        (inst -1 "(1 + -precision)"
                         "(min_exp - 1 + precision)" "radix")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide-all-but 1)
                  (("2" (lemma "sigma_with")
                    (("2"
                      (inst -1 "LAMBDA (i_1: nat):
                  IF i_1 < precision
                    THEN IF i_1 = precision - 1 THEN 1 ELSE 0 ENDIF *
                          radix ^ (-i_1)
                  ELSE 0
                  ENDIF" "LAMBDA(i:nat):0" "radix^(1-precision)"
                       "precision-1" "precision-1" "0")
                      (("1" (split -1)
                        (("1" (replace -1 :hide? t)
                          (("1" (rewrite "sigma_zero")
                            (("1" (assert) nil nil)) nil))
                          nil)
                         ("2" (assert) nil nil) ("3" (assert) nil nil)
                         ("4" (hide-all-but 1)
                          (("4" (apply-extensionality)
                            (("4" (hide 2) (("4" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil) ("3" (assert) nil nil)
                       ("4" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("3" (assert) nil nil) ("4" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (expand "emin")
            (("2" (expand "emax")
              (("2" (expand "min_exp")
                (("2" (expand "max_exp") (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((min_pos_value const-decl "posreal" extended_float nil)
    (max_exp const-decl "posint" extended_float nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (value const-decl "real" ieee754_domain float_bounded_axiomatic)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (expt def-decl "real" exponentiation nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnrat_plus_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (sigma_nat application-judgement "nat" sigma_nat reals)
    (sigma_zero formula-decl nil sigma reals)
    (sigma_with formula-decl nil sigma reals)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (expt_plus formula-decl nil exponentiation nil)
    (posrat_times_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (sigma def-decl "real" sigma reals)
    (T_high type-eq-decl nil sigma reals)
    (T_low type-eq-decl nil sigma reals)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (smin const-decl "significand" ieee754_domain
     float_bounded_axiomatic)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (min_exp const-decl "negint" extended_float nil)
    (er_min_pos const-decl "er_real" ieee754_domain
     float_bounded_axiomatic))
   shostak))
 (er_max_neg_correspondent 0
  (er_max_neg_correspondent-1 nil 3763920022
   ("" (expand "er_max_neg")
    (("" (use "er_min_pos_correspondent")
      (("" (expand "er_min_pos")
        (("" (expand "value") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (value const-decl "real" ieee754_domain float_bounded_axiomatic)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (nzrat_times_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (int_exp application-judgement "int" exponentiation nil)
    (nzreal_exp application-judgement "nzreal" exponentiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (sigma_rat application-judgement "rational" sigma_nat reals)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min_pos_value_xef_real name-judgement
     "xef_real[radix, precision, dExp]"
     extended_float_exactly_representable_reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (expt_x1 formula-decl nil exponentiation nil)
    (expt_x0 formula-decl nil exponentiation nil)
    (er_min_pos const-decl "er_real" ieee754_domain
     float_bounded_axiomatic)
    (er_max_neg const-decl "er_real" ieee754_domain
     float_bounded_axiomatic))
   shostak))
 (min_pos_value_is_er 0
  (min_pos_value_is_er-1 nil 3764927692
   ("" (rewrite "er_min_pos_correspondent" :dir rl)
    (("" (assert) nil nil)) nil)
   ((er_min_pos_correspondent formula-decl nil
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_rat_er_int 0
  (er_rat_er_int-1 nil 3763919911
   ("" (skeep :preds? t)
    (("" (expand "exactly_representable?")
      (("" (skeep :preds? t)
        (("" (expand "exactly_representable_as_pair_of_integers?")
          (("" (use "er_rat_to_er_int_value")
            (("" (skoletin* -1)
              (("" (inst 1 "float_pair(signific,exponent)")
                (("1" (split 1)
                  (("1" (expand "FtoR")
                    (("1" (expand "float_pair")
                      (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (use "er_rat_to_er_int__exponent__le_max_exp")
                    (("2" (assert)
                      (("2" (expand "float_pair")
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "Fbounded?")
                  (("2" (expand "float_pair")
                    (("2" (expand "given_format")
                      (("2" (expand "vNum")
                        (("2" (split 1)
                          (("1"
                            (use "er_rat_to_er_int__significand__abs_lt_radix_pow_prec")
                            (("1" (assert) nil nil)) nil)
                           ("2"
                            (use "er_rat_to_er_int__exponent__ge_min_exp")
                            (("2" (assert)
                              (("2"
                                (expand "min_exp")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (/= const-decl "boolean" notequal nil)
    (er_rat_to_er_int__exponent const-decl "int"
     extended_float_exactly_representable_reals nil)
    (er_rat_to_er_int__significand const-decl "int"
     extended_float_exactly_representable_reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (xef_real_0_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (value const-decl "real" ieee754_domain float_bounded_axiomatic)
    (^ const-decl "real" exponentiation nil)
    (vNum const-decl "posnat" float float_unbounded)
    (er_rat_to_er_int__exponent__ge_min_exp formula-decl nil
     extended_float_exactly_representable_reals nil)
    (min_exp const-decl "negint" extended_float nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (er_rat_to_er_int__significand__abs_lt_radix_pow_prec formula-decl
     nil extended_float_exactly_representable_reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FtoR const-decl "real" float float_unbounded)
    (er_rat_to_er_int__exponent__le_max_exp formula-decl nil
     extended_float_exactly_representable_reals nil)
    (exponent skolem-const-decl "int"
     extended_float_exactly_representable_reals nil)
    (signific skolem-const-decl "int"
     extended_float_exactly_representable_reals nil)
    (float_pair const-decl "float" float float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (sign type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nonpos_int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (negint nonempty-type-eq-decl nil integers nil)
    (emin const-decl "negint" ieee754_domain float_bounded_axiomatic)
    (exponent type-eq-decl nil ieee754_domain float_bounded_axiomatic)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (significand type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (er_rat_to_er_int_value formula-decl nil
     extended_float_exactly_representable_reals nil))
   shostak))
 (er_rat_er_int_j 0
  (er_rat_er_int_j-1 nil 3799163076 ("" (use "er_rat_er_int") nil nil)
   ((er_rat_er_int formula-decl nil
     extended_float_exactly_representable_reals nil))
   nil
   (er_rat_er_int_j subtype
    "extended_float_exactly_representable_reals.x"
    "xef_real[radix, precision, dExp]")))
 (er_bounded 0
  (er_bounded-2 "" 3790103824
   ("" (use "er_rat_er_int")
    (("" (expand "exactly_representable_as_pair_of_integers?")
      (("" (skeep)
        (("" (inst?) (("" (skeep) (("" (inst?) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((exactly_representable_as_pair_of_integers? const-decl "bool"
     extended_float nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (emax const-decl "above(1)" extended_float nil)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (f skolem-const-decl
     "(Fbounded?((# Prec := precision, dExp := dExp #)))"
     extended_float_exactly_representable_reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (Fbounded? const-decl "bool" float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float float_unbounded)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (er_rat_er_int formula-decl nil
     extended_float_exactly_representable_reals nil))
   shostak)
  (er_bounded-1 nil 3763919911
   (""
    (then (use "er_rat_er_int")
     (expand "exactly_representable_as_pair_of_integers?") (skeep)
     (inst?) (skeep) (inst?))
    nil nil)
   ((float type-eq-decl nil float float_unbounded)
    (Format type-eq-decl nil float float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (max_exp const-decl "posint" extended_float nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil))
   shostak))
 (er_canonic 0
  (er_canonic-1 nil 3764685365
   ("" (skeep)
    (("" (use "er_bounded")
      (("" (skeep)
        (("" (inst 1 "Fnormalize(given_format)(f)")
          (("1" (typepred "Fnormalize(given_format)(f)")
            (("1" (assert) nil nil)) nil)
           ("2" (typepred "Fnormalize(given_format)(f)")
            (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((er_bounded formula-decl nil
     extended_float_exactly_representable_reals nil)
    (er_real nonempty-type-eq-decl nil ieee754_domain
     float_bounded_axiomatic)
    (exactly_representable? const-decl "bool" ieee754_domain
     float_bounded_axiomatic)
    (emax const-decl "above(1)" extended_float nil)
    (dExp formal-const-decl "{d: posnat | d > 2 * (precision - 1) - 1}"
     extended_float_exactly_representable_reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (precision formal-const-decl "above(1)"
     extended_float_exactly_representable_reals nil)
    (radix formal-const-decl "above(1)"
           extended_float_exactly_representable_reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (xef_real_1_j number-judgement "xef_real"
     extended_float_exactly_representable_reals nil)
    (f skolem-const-decl
     "{f: (Fbounded?((# Prec := precision, dExp := dExp #))) | Fexp(f) <= max_exp}"
     extended_float_exactly_representable_reals nil)
    (max_exp const-decl "posint" extended_float nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (Fnormalize def-decl
     "{x: (Fcanonic?(b)) | FtoR(x) = FtoR(f):: real AND Fexp(x) <= Fexp(f)}"
     float float_unbounded)
    (FtoR const-decl "real" float float_unbounded)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Fcanonic? const-decl "bool" float float_unbounded)
    (Fbounded? const-decl "bool" float float_unbounded)
    (float type-eq-decl nil float float_unbounded)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float float_unbounded)
    (<= const-decl "bool" reals nil)
    (unb_canonic_float type-eq-decl nil float_props_rounding
     float_unbounded)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak)))


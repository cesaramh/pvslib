/Applications/Aquamacs.app/Contents/MacOS/Aquamacs does not support X; running in terminal mode

Setting tmp dir to value of environment variable TMPDIR:
  /var/folders/p7/6vklcyns5r75r8lbh6q8kzsm0000gp/T/
; 
; caught STYLE-WARNING:
;   Call to PVS::NAME-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   Call to PVS::NUMBER-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   Call to PVS::UNARY-APPLICATION? could not be inlined because its source code
;   was not saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in
;   effect to save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   Call to PVS::FORALL-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.

; 
; caught STYLE-WARNING:
;   Call to PVS::EXISTS-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

Defining METIT. WARNING: redefining PP* (#<STANDARD-CLASS PVS::RATIONAL-EXPR>) in DEFMETHOD
Loading prelude library NASALib/pvsio_utils (/Users/cmunoz/src/PVS.gitlab/nasalib/pvsio_utils/)

*** 
*** Processing dL (14:18:35 12/25/2023)
*** Generated by proveit 7.1.0 (Nov 05, 2020)
*** 
Context changed to /Users/cmunoz/src/PVS.gitlab/nasalib/dL/
Parsing top
top parsed in 0.00 seconds
Typechecking top
Parsing hp_def
hp_def parsed in 0.01 seconds
hp_def is already parsed
Typechecking hp_def
PVS context has bad deps: (sorting_aux total_preorder sorting sorting_seq
                           first_phase_ford_johnson ford_johnson mergesort
                           radix_sort radix_sort_nat binsertionsort maxsort
                           heapsort sorting_min insertionsort_fs insertionsort
                           quicksort)
PVS context has bad deps: (sorting_aux total_preorder sorting)
Parsing more_list_props
more_list_props parsed in 0.04 seconds
more_list_props is already parsed
Typechecking more_list_props

 LET/WHERE variable m at line 78, col 9 is given type
  nat from its value expression.


 LET/WHERE variable n at line 78, col 12 is given type
  nat from its value expression.


 In declaration every_parm:
  added conversion restrict[T, (P), bool]
             
  to Q, converting
     [T -> bool]
  to [(P) -> bool]


 LET/WHERE variable FL at line 605, col 9 is given type
  list[T] from its value expression.

more_list_props typechecked in 0.73s: 128 TCCs, 0 proved, 32 subsumed, 96 unproved; 1 conversion; 3 msgs
PVS context has bad deps: (sorting_aux total_preorder sorting sorting_seq
                           first_phase_ford_johnson ford_johnson mergesort
                           radix_sort radix_sort_nat binsertionsort maxsort
                           heapsort bubblesort sorting_min insertionsort_fs
                           insertionsort quicksort)
Parsing reals_safe_ops
reals_safe_ops parsed in 0.00 seconds
reals_safe_ops is already parsed
Typechecking reals_safe_ops
Parsing sqrt
sqrt parsed in 0.00 seconds
sqrt is already parsed
Typechecking sqrt
Parsing sq
sq parsed in 0.01 seconds
sq is already parsed
Typechecking sq
sq typechecked in 0.14s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing sign
sign parsed in 0.00 seconds
sign is already parsed
Typechecking sign
sign typechecked in 0.23s: 9 TCCs, 0 proved, 0 subsumed, 9 unproved
Parsing sqrt_exists
sqrt_exists parsed in 0.00 seconds
sqrt_exists is already parsed
Typechecking sqrt_exists
sqrt_exists typechecked in 0.04s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
sqrt typechecked in 0.85s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
reals_safe_ops typechecked in 0.96s: 5 TCCs, 0 proved, 2 subsumed, 3 unproved

 LET/WHERE variable N at line 102, col 8 is given type
  nat from its value expression.


 LET/WHERE variable k at line 195, col 8 is given type
  (index_of(me, i)) from its value expression.

hp_def typechecked in 2.936s: 19 TCCs, 0 proved, 5 subsumed, 14 unproved; 2 msgs
Parsing HP
HP parsed in 0.00 seconds
HP is already parsed
Typechecking HP
Wrote pvs file HP_adt
In DATATYPE theory HP_adt: No TCCs generated
In DATATYPE theory HP_adt_reduce: No TCCs generated
HP typechecked in 0.55s: No TCCs generated
Parsing NQBool
NQBool parsed in 0.00 seconds
NQBool is already parsed
Typechecking NQBool
Wrote pvs file NQBool_adt
In DATATYPE theory NQBool_adt: No TCCs generated
In DATATYPE theory NQBool_adt_reduce: No TCCs generated
NQBool typechecked in 0.43s: No TCCs generated
Parsing hp_expr
hp_expr parsed in 0.01 seconds
hp_expr is already parsed
Typechecking hp_expr
Parsing strategies
strategies parsed in 0.00 seconds
strategies is already parsed
Typechecking strategies
Parsing Unit
Unit parsed in 0.00 seconds
Unit is already parsed
Typechecking Unit
Wrote pvs file Unit_adt
In DATATYPE theory Unit_adt: No TCCs generated
In DATATYPE theory Unit_adt_reduce: No TCCs generated
Unit typechecked in 0.27s: No TCCs generated
Parsing deriv_domains
deriv_domains parsed in 0.00 seconds
deriv_domains is already parsed
Typechecking deriv_domains
Parsing deriv_domain
deriv_domain parsed in 0.00 seconds
deriv_domain is already parsed
Typechecking deriv_domain
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/deriv_domain_def.bin in 0.15s (load part took 0.00s)
Parsing intervals_real
intervals_real parsed in 0.00 seconds
intervals_real is already parsed
Typechecking intervals_real
intervals_real typechecked in 0.00s: No TCCs generated
deriv_domain typechecked in 0.34s: No TCCs generated
deriv_domains typechecked in 0.35s: No TCCs generated
Parsing derivatives_lam
derivatives_lam parsed in 0.02 seconds
derivatives_lam is already parsed
Typechecking derivatives_lam
Parsing derivatives
derivatives parsed in 0.00 seconds
derivatives is already parsed
Typechecking derivatives
Parsing derivatives_def
derivatives_def parsed in 0.00 seconds
derivatives_def is already parsed
Typechecking derivatives_def
Parsing lim_of_functions
lim_of_functions parsed in 0.01 seconds
lim_of_functions is already parsed
Typechecking lim_of_functions
Parsing convergence_functions
convergence_functions parsed in 0.00 seconds
convergence_functions is already parsed
Typechecking convergence_functions
Parsing real_fun_ops
real_fun_ops parsed in 0.00 seconds
real_fun_ops is already parsed
Typechecking real_fun_ops
real_fun_ops typechecked in 0.04s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing epsilon_lemmas
epsilon_lemmas parsed in 0.00 seconds
epsilon_lemmas is already parsed
Typechecking epsilon_lemmas
Parsing real_facts
real_facts parsed in 0.00 seconds
real_facts is already parsed
Typechecking real_facts
real_facts typechecked in 0.17s: 4 TCCs, 0 proved, 1 subsumed, 3 unproved
Parsing abs_lems
abs_lems parsed in 0.00 seconds
abs_lems is already parsed
Typechecking abs_lems
Parsing root
root parsed in 0.00 seconds
root is already parsed
Typechecking root
root typechecked in 0.17s: 16 TCCs, 0 proved, 4 subsumed, 12 unproved
abs_lems typechecked in 0.49s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
epsilon_lemmas typechecked in 1.33s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
convergence_functions typechecked in 1.624s: No TCCs generated

 In declaration cv_abs:
  added conversion restrict[real, T, real]
             
  to abs, converting
     [real -> real]
  to [T -> real]

lim_of_functions typechecked in 1.862s: 10 TCCs, 0 proved, 0 subsumed, 10 unproved; 1 conversion
Parsing continuous_functions
continuous_functions parsed in 0.00 seconds
continuous_functions is already parsed
Typechecking continuous_functions

 In declaration continuous_on_def:
  added conversion extend[real, T, bool, FALSE]
             
  to E, converting
     [T -> bool]
  to [real -> bool]


 In declaration continuous_def2:
  added conversion restrict[real, T, boolean]
             
  to T_pred, converting
     [real -> boolean]
  to [T -> boolean]

continuous_functions typechecked in 0.11s: 11 TCCs, 0 proved, 0 subsumed, 11 unproved; 2 conversions; 1 warning
derivatives_def typechecked in 2.262s: 14 TCCs, 0 proved, 3 subsumed, 11 unproved

 LET/WHERE variable f at line 142, col 32 is given type
  [T -> real] from its value expression.


 LET/WHERE variable f at line 154, col 29 is given type
  [T -> real] from its value expression.

derivatives typechecked in 2.429s: 24 TCCs, 0 proved, 2 subsumed, 22 unproved; 1 warning; 2 msgs
Parsing sqrt_derivative
sqrt_derivative parsed in 0.00 seconds
sqrt_derivative is already parsed
Typechecking sqrt_derivative
Parsing derivative_inverse
derivative_inverse parsed in 0.00 seconds
derivative_inverse is already parsed
Typechecking derivative_inverse
Parsing derivative_props
derivative_props parsed in 0.01 seconds
derivative_props is already parsed
Typechecking derivative_props
Parsing derivatives_alt
derivatives_alt parsed in 0.00 seconds
derivatives_alt is already parsed
Typechecking derivatives_alt
Parsing continuous_functions_props
continuous_functions_props parsed in 0.00 seconds
continuous_functions_props is already parsed
Typechecking continuous_functions_props
Parsing continuity_interval
continuity_interval parsed in 0.00 seconds
continuity_interval is already parsed
Typechecking continuity_interval
Parsing continuity_props
continuity_props parsed in 0.00 seconds
continuity_props is already parsed
Typechecking continuity_props
Parsing top_sequences
top_sequences parsed in 0.00 seconds
top_sequences is already parsed
Typechecking top_sequences
Parsing convergence_ops
convergence_ops parsed in 0.00 seconds
convergence_ops is already parsed
Typechecking convergence_ops
Parsing convergence_sequences
convergence_sequences parsed in 0.00 seconds
convergence_sequences is already parsed
Typechecking convergence_sequences
Parsing sequence_props
sequence_props parsed in 0.00 seconds
sequence_props is already parsed
Typechecking sequence_props
Parsing real_fun_supinf
real_fun_supinf parsed in 0.00 seconds
real_fun_supinf is already parsed
Typechecking real_fun_supinf
Parsing real_fun_props
real_fun_props parsed in 0.00 seconds
real_fun_props is already parsed
Typechecking real_fun_props
Parsing real_fun_preds
real_fun_preds parsed in 0.00 seconds
real_fun_preds is already parsed
Typechecking real_fun_preds
real_fun_preds typechecked in 0.00s: No TCCs generated
real_fun_props typechecked in 0.03s: No TCCs generated
real_fun_supinf typechecked in 0.33s: 5 TCCs, 0 proved, 0 subsumed, 5 unproved
sequence_props typechecked in 0.40s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing monotone_subsequence
monotone_subsequence parsed in 0.00 seconds
monotone_subsequence is already parsed
Typechecking monotone_subsequence
monotone_subsequence typechecked in 0.05s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
convergence_sequences typechecked in 0.61s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
convergence_ops typechecked in 0.79s: 14 TCCs, 0 proved, 1 subsumed, 13 unproved
top_sequences typechecked in 0.83s: No TCCs generated
continuity_props typechecked in 0.86s: No TCCs generated
continuity_interval typechecked in 0.94s: 14 TCCs, 0 proved, 5 subsumed, 9 unproved
continuous_functions_props typechecked in 1.016s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
derivatives_alt typechecked in 1.104s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved

 In declaration deriv_neg_neg:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration deriv_neg_neg:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration neg_spot:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration deriv_neg_root:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration deriv_neg_root:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]

derivative_props typechecked in 1.456s: 15 TCCs, 0 proved, 7 subsumed, 8 unproved; 5 conversions
Parsing chain_rule
chain_rule parsed in 0.00 seconds
chain_rule is already parsed
Typechecking chain_rule
Parsing lim_of_composition
lim_of_composition parsed in 0.00 seconds
lim_of_composition is already parsed
Typechecking lim_of_composition
lim_of_composition typechecked in 0.05s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
chain_rule typechecked in 0.13s: 24 TCCs, 0 proved, 10 subsumed, 13 unproved, 1 trivial
Parsing inverse_continuous_functions
inverse_continuous_functions parsed in 0.00 seconds
inverse_continuous_functions is already parsed
Typechecking inverse_continuous_functions
inverse_continuous_functions typechecked in 0.03s: No TCCs generated
Parsing composition_continuous
composition_continuous parsed in 0.00 seconds
composition_continuous is already parsed
Typechecking composition_continuous

 In declaration composition_cont_set:
  added conversion restrict[real, T1, bool]
             
  to F, converting
     [real -> bool]
  to [T1 -> bool]


 In declaration composition_cont_set:
  added conversion restrict[real, T2, bool]
             
  to Im(f, F), converting
     [real -> bool]
  to [T2 -> bool]


 In declaration composition_cont_set:
  added conversion restrict[real, T1, bool]
             
  to F, converting
     [real -> bool]
  to [T1 -> bool]

composition_continuous typechecked in 0.02s: No TCCs generated; 3 conversions
derivative_inverse typechecked in 1.993s: 12 TCCs, 0 proved, 7 subsumed, 5 unproved

 In declaration sqrt_derivable_fun:
  added conversion restrict[nonneg_real, posreal, real]
             
  to sqrt, converting
     [nonneg_real -> real]
  to [posreal -> real]


 In declaration deriv_sqrt_fun:
  added conversion restrict[nonneg_real, posreal, real]
             
  to sqrt, converting
     [nonneg_real -> real]
  to [posreal -> real]


 In declaration deriv_sqrt:
  added conversion restrict[nonneg_real, posreal, real]
             
  to sqrt, converting
     [nonneg_real -> real]
  to [posreal -> real]


 In declaration deriv_sqrt:
  added conversion restrict[nonneg_real, posreal, real]
             
  to sqrt, converting
     [nonneg_real -> real]
  to [posreal -> real]


 In declaration sqrt_continuous:
  added conversion restrict[nonneg_real, posreal, real]
             
  to sqrt, converting
     [nonneg_real -> real]
  to [posreal -> real]

sqrt_derivative typechecked in 2.145s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved; 5 conversions

 In declaration derivable_sq_lam:
  added conversion restrict[real, T, nonneg_real]
             
  to sq, converting
     [real -> nonneg_real]
  to [T -> nonneg_real]


 In declaration deriv_sq_lam:
  added conversion restrict[real, T, nonneg_real]
             
  to sq, converting
     [real -> nonneg_real]
  to [T -> nonneg_real]


 In declaration derivable_sq_lam_point:
  added conversion restrict[real, T, nonneg_real]
             
  to sq, converting
     [real -> nonneg_real]
  to [T -> nonneg_real]

derivatives_lam typechecked in 4.873s: 19 TCCs, 0 proved, 1 subsumed, 18 unproved; 3 conversions
Parsing sqrt_derivative_lam
sqrt_derivative_lam parsed in 0.00 seconds
sqrt_derivative_lam is already parsed
Typechecking sqrt_derivative_lam
sqrt_derivative_lam typechecked in 0.15s: 7 TCCs, 0 proved, 2 subsumed, 5 unproved
strategies typechecked in 6.05s: No TCCs generated
Parsing table_of_integrals
table_of_integrals parsed in 0.00 seconds
table_of_integrals is already parsed
Typechecking table_of_integrals
Parsing fundamental_theorem
fundamental_theorem parsed in 0.00 seconds
fundamental_theorem is already parsed
Typechecking fundamental_theorem
Parsing integral
integral parsed in 0.00 seconds
integral is already parsed
Typechecking integral
Parsing integral_def
integral_def parsed in 0.01 seconds
integral_def is already parsed
Typechecking integral_def
Parsing finite_sets_minmax
finite_sets_minmax parsed in 0.00 seconds
finite_sets_minmax is already parsed
Typechecking finite_sets_minmax
Parsing finite_sets_inductions
finite_sets_inductions parsed in 0.00 seconds
finite_sets_inductions is already parsed
Typechecking finite_sets_inductions
finite_sets_inductions typechecked in 0.02s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
finite_sets_minmax typechecked in 0.05s: 4 TCCs, 0 proved, 1 subsumed, 3 unproved

 LET/WHERE variable N at line 38, col 24 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 38, col 40 is given type
  [below[fs`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable xx at line 43, col 17 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable N at line 43, col 30 is given type
  nat from its value expression.


 In declaration width_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration width_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable xx at line 87, col 31 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable N at line 87, col 44 is given type
  nat from its value expression.

Parsing sigma_below
sigma_below parsed in 0.00 seconds
sigma_below is already parsed
Typechecking sigma_below
Parsing sigma
sigma parsed in 0.01 seconds
sigma is already parsed
Typechecking sigma
sigma typechecked in 0.65s: 72 TCCs, 0 proved, 28 subsumed, 44 unproved; 6 warnings
sigma_below typechecked in 0.80s: 8 TCCs, 0 proved, 0 subsumed, 8 unproved
Parsing sigma_upto
sigma_upto parsed in 0.00 seconds
sigma_upto is already parsed
Typechecking sigma_upto
sigma_upto typechecked in 0.08s: 11 TCCs, 0 proved, 3 subsumed, 8 unproved

 In declaration xis?:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration xis?:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration xis_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration xis_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable N at line 121, col 22 is given type
  int from its value expression.


 In declaration Rie_sum:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration Rie_sum:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable N at line 134, col 22 is given type
  int from its value expression.


 LET/WHERE variable N at line 144, col 39 is given type
  int from its value expression.


 In declaration pick_one:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration pick_one:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration pick_one:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration pick_one:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration gen_xis:
  added conversion finseq_appl[real]
             
  to (# length := length(P) - 1, seq := pick_one(a, b, P) #), converting
     fs: finseq[real]
  to [below[length(fs)] -> real]


 LET/WHERE variable N at line 180, col 30 is given type
  int from its value expression.


 LET/WHERE variable EP at line 181, col 30 is given type
  partition(a, b) from its value expression.

integral_def typechecked in 2.569s: 70 TCCs, 0 proved, 20 subsumed, 50 unproved; 13 conversions; 11 msgs
Parsing integral_cont
integral_cont parsed in 0.00 seconds
integral_cont is already parsed
Typechecking integral_cont
Parsing integral_cont_scaf
integral_cont_scaf parsed in 0.00 seconds
integral_cont_scaf is already parsed
Typechecking integral_cont_scaf
Parsing integral_prep
integral_prep parsed in 0.00 seconds
integral_prep is already parsed
Typechecking integral_prep

 LET/WHERE variable S1 at line 124, col 28 is given type
  real from its value expression.


 LET/WHERE variable S2 at line 125, col 28 is given type
  real from its value expression.


 In declaration gxis:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration gxis:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration gxis:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration gxis:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

integral_prep typechecked in 0.50s: 13 TCCs, 0 proved, 1 subsumed, 9 unproved, 3 trivial; 4 conversions; 2 msgs
Parsing integral_step
integral_step parsed in 0.01 seconds
integral_step is already parsed
Typechecking integral_step
Parsing step_fun_def
step_fun_def parsed in 0.00 seconds
step_fun_def is already parsed
Typechecking step_fun_def

 LET/WHERE variable N at line 30, col 32 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 30, col 47 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable N at line 51, col 24 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 51, col 39 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.

step_fun_def typechecked in 0.07s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved; 4 msgs
Parsing integral_pulse
integral_pulse parsed in 0.00 seconds
integral_pulse is already parsed
Typechecking integral_pulse
integral_pulse typechecked in 0.23s: 16 TCCs, 0 proved, 3 subsumed, 13 unproved

 In declaration integral_sumof:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration integral_sumof:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable endx at line 112, col 17 is given type
  closed_interval[T](a, b) from its value expression.


 LET/WHERE variable N at line 122, col 22 is given type
  int from its value expression.


 LET/WHERE variable N at line 137, col 25 is given type
  nat from its value expression.


 In declaration step_function_on_integral:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration step_function_on_integral:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

integral_step typechecked in 1.069s: 44 TCCs, 0 proved, 11 subsumed, 33 unproved; 4 conversions; 3 msgs
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/interval_minmax.bin in 0.09s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/unif_cont_fun.bin in 0.09s (load part took 0.00s)

 LET/WHERE variable xx at line 76, col 32 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable xx at line 84, col 32 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.

integral_cont_scaf typechecked in 2.69s: 44 TCCs, 0 proved, 26 subsumed, 18 unproved; 2 msgs
integral_cont typechecked in 2.855s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing integral_split
integral_split parsed in 0.00 seconds
integral_split is already parsed
Typechecking integral_split
Parsing integral_split_scaf
integral_split_scaf parsed in 0.01 seconds
integral_split_scaf is already parsed
Typechecking integral_split_scaf
Parsing integral_bounded
integral_bounded parsed in 0.00 seconds
integral_bounded is already parsed
Typechecking integral_bounded

 In declaration int_to_bnd:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to EP, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration int_to_bnd:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to EP, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration bounded_on_all?:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration bounded_on_all?:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

integral_bounded typechecked in 0.62s: 21 TCCs, 0 proved, 8 subsumed, 12 unproved, 1 trivial; 4 conversions

 LET/WHERE variable JJ at line 53, col 35 is given type
  {ii: below(length(P) - 1) | seq(P)(ii) <= xx AND xx <= seq(P)(1 + ii)} from its value expression.


 LET/WHERE variable JJ at line 77, col 26 is given type
  {ii: below(length(P) - 1) | seq(P)(ii) <= x AND x <= seq(P)(1 + ii)} from its value expression.


 In declaration F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable JJ at line 87, col 16 is given type
  {ii: below(length(P) - 1) | seq(P)(ii) <= x AND x <= seq(P)(1 + ii)} from its value expression.


 In declaration F2:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration F2:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable N at line 107, col 26 is given type
  int from its value expression.


 LET/WHERE variable N at line 112, col 26 is given type
  int from its value expression.


 LET/WHERE variable N at line 119, col 26 is given type
  int from its value expression.


 In declaration integral_F2_F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration integral_F2_F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable DP at line 122, col 30 is given type
  real from its value expression.


 LET/WHERE variable DELj at line 123, col 30 is given type
  real from its value expression.


 In declaration integral_F2_F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration integral_F2_F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration sigma_all_parts:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration sigma_all_parts:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

integral_split_scaf typechecked in 2.008s: 57 TCCs, 0 proved, 24 subsumed, 33 unproved; 10 conversions; 8 msgs
Parsing step_fun_props
step_fun_props parsed in 0.00 seconds
step_fun_props is already parsed
Typechecking step_fun_props
Parsing sort_seq_lems
sort_seq_lems parsed in 0.00 seconds
sort_seq_lems is already parsed
Typechecking sort_seq_lems
Parsing sort_seq
sort_seq parsed in 0.00 seconds
sort_seq is already parsed
Typechecking sort_seq
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/below_arrays.bin in 0.06s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/permutations.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/max_array_def.bin in 0.05s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/min_array_def.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/sort_array_def.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/sort_array.bin in 0.03s (load part took 0.00s)
Parsing permutations_seq
permutations_seq parsed in 0.00 seconds
permutations_seq is already parsed
Typechecking permutations_seq
Parsing finite_sets_card_eq
finite_sets_card_eq parsed in 0.00 seconds
finite_sets_card_eq is already parsed
Typechecking finite_sets_card_eq
Parsing func_composition
func_composition parsed in 0.00 seconds
func_composition is already parsed
Typechecking func_composition
func_composition typechecked in 0.01s: No TCCs generated
finite_sets_card_eq typechecked in 0.02s: No TCCs generated
Parsing finite_sets_below
finite_sets_below parsed in 0.00 seconds
finite_sets_below is already parsed
Typechecking finite_sets_below
finite_sets_below typechecked in 0.05s: 7 TCCs, 0 proved, 2 subsumed, 5 unproved
permutations_seq typechecked in 0.47s: No TCCs generated
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/seqs.bin in 0.05s (load part took 0.00s)
sort_seq typechecked in 0.88s: 10 TCCs, 0 proved, 2 subsumed, 8 unproved
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/min_seq.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/max_seq.bin in 0.03s (load part took 0.00s)
sort_seq_lems typechecked in 1.041s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved

 In declaration IMPORTING structures@sort_seq_lems[T, <=]:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]

Parsing step_fun_scaf
step_fun_scaf parsed in 0.00 seconds
step_fun_scaf is already parsed
Typechecking step_fun_scaf
Parsing partitions_scaf
partitions_scaf parsed in 0.00 seconds
partitions_scaf is already parsed
Typechecking partitions_scaf

 In declaration IMPORTING structures@sort_seq_lems[T, <=]:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration IMPORTING finite_sets@finite_sets_minmax[T, <=]:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]

Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/ints/pvsbin/max_below.bin in 0.03s (load part took 0.00s)

 In declaration gen_seq_lem:
  added conversion finseq_appl[T]
             
  to  #(x), converting
     fs: finseq[T]
  to [below[length(fs)] -> T]


 In declaration part2set_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 LET/WHERE variable SP at line 70, col 26 is given type
  finite_sequence[T] from its value expression.


 LET/WHERE variable SP at line 73, col 29 is given type
  finite_sequence[T] from its value expression.


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 LET/WHERE variable SP at line 84, col 29 is given type
  finite_sequence[T] from its value expression.


 LET/WHERE variable SP at line 88, col 31 is given type
  finite_sequence[T] from its value expression.


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 LET/WHERE variable SP at line 95, col 34 is given type
  {ss: seqs[T, restrict[[real, real], [T, T], bool](<=)] |
     permutation?[T, restrict[[real, real], [T, T], bool](<=)](set2seq(S), ss)
      AND increasing?(ss)} from its value expression.


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]

partitions_scaf typechecked in 0.73s: 25 TCCs, 0 proved, 6 subsumed, 19 unproved; 28 conversions; 5 msgs

 LET/WHERE variable UP at line 28, col 27 is given type
  finite_set[T] from its value expression.


 In declaration Union_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to UnionPart(a, b, P1, P2), converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration Union_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to UnionPart(a, b, P1, P2), converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

step_fun_scaf typechecked in 1.531s: 11 TCCs, 0 proved, 2 subsumed, 9 unproved; 2 conversions; 1 msg

 LET/WHERE variable N at line 44, col 24 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 44, col 39 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable N1 at line 54, col 20 is given type
  nat from its value expression.


 LET/WHERE variable NUU at line 55, col 20 is given type
  int from its value expression.

step_fun_props typechecked in 3.935s: 27 TCCs, 0 proved, 8 subsumed, 19 unproved; 1 conversion; 4 msgs
Parsing concat_arrays
concat_arrays parsed in 0.00 seconds
concat_arrays is already parsed
Typechecking concat_arrays
concat_arrays typechecked in 0.05s: 6 TCCs, 0 proved, 0 subsumed, 6 unproved
Parsing sigma_below_sub
sigma_below_sub parsed in 0.00 seconds
sigma_below_sub is already parsed
Typechecking sigma_below_sub
sigma_below_sub typechecked in 0.08s: 16 TCCs, 0 proved, 0 subsumed, 16 unproved
integral_split typechecked in 6.811s: 17 TCCs, 0 proved, 9 subsumed, 8 unproved
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/continuous_functions_more.bin in 0.06s (load part took 0.00s)

 LET/WHERE variable l at line 145, col 35 is given type
  {p: real | p <= a AND p <= b} from its value expression.


 LET/WHERE variable u at line 146, col 35 is given type
  {p: real | p >= a AND p >= b} from its value expression.

integral typechecked in 12.682s: 16 TCCs, 0 proved, 6 subsumed, 7 unproved, 3 trivial; 2 msgs
fundamental_theorem typechecked in 12.789s: 15 TCCs, 0 proved, 12 subsumed, 3 unproved
Parsing indefinite_integral
indefinite_integral parsed in 0.00 seconds
indefinite_integral is already parsed
Typechecking indefinite_integral
indefinite_integral typechecked in 0.17s: 10 TCCs, 0 proved, 5 subsumed, 5 unproved

 LET/WHERE variable f at line 27, col 32 is given type
  [T -> real] from its value expression.


 LET/WHERE variable F at line 28, col 32 is given type
  [T -> real] from its value expression.


 LET/WHERE variable f at line 33, col 32 is given type
  [T -> real] from its value expression.


 LET/WHERE variable F at line 35, col 29 is given type
  [T -> real] from its value expression.


 LET/WHERE variable f at line 39, col 32 is given type
  [T -> real] from its value expression.


 LET/WHERE variable F at line 41, col 29 is given type
  [T -> real] from its value expression.


 LET/WHERE variable F at line 46, col 27 is given type
  [T -> real] from its value expression.

table_of_integrals typechecked in 13.317s: 14 TCCs, 0 proved, 6 subsumed, 7 unproved, 1 trivial; 7 msgs
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/derivatives_subtype.bin in 0.08s (load part took 0.00s)
Parsing interval_def
interval_def parsed in 0.01 seconds
interval_def is already parsed
Typechecking interval_def
Parsing max_function
max_function parsed in 0.00 seconds
max_function is already parsed
Typechecking max_function
Parsing extreme_value_theorem
extreme_value_theorem parsed in 0.00 seconds
extreme_value_theorem is already parsed
Typechecking extreme_value_theorem
Parsing sequential_criterian
sequential_criterian parsed in 0.00 seconds
sequential_criterian is already parsed
Typechecking sequential_criterian
Parsing norms_equiv
norms_equiv parsed in 0.00 seconds
norms_equiv is already parsed
Typechecking norms_equiv
Parsing sum_vecs
sum_vecs parsed in 0.00 seconds
sum_vecs is already parsed
Typechecking sum_vecs
Parsing vector_arithmetic
vector_arithmetic parsed in 0.02 seconds
vector_arithmetic is already parsed
Typechecking vector_arithmetic
Parsing matrices
matrices parsed in 0.02 seconds
matrices is already parsed
Typechecking matrices
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/structures/pvsbin/listn.bin in 0.05s (load part took 0.00s)
Parsing sigma_nat
sigma_nat parsed in 0.00 seconds
sigma_nat is already parsed
Typechecking sigma_nat
sigma_nat typechecked in 0.41s: 29 TCCs, 0 proved, 10 subsumed, 19 unproved
Parsing array2list
array2list parsed in 0.00 seconds
array2list is already parsed
Typechecking array2list
array2list typechecked in 0.11s: 18 TCCs, 0 proved, 1 subsumed, 17 unproved
Parsing sigma_swap
sigma_swap parsed in 0.00 seconds
sigma_swap is already parsed
Typechecking sigma_swap
sigma_swap typechecked in 0.02s: 1 TCC, 0 proved, 0 subsumed, 1 unproved

 LET/WHERE variable N at line 300, col 8 is given type
  {x:
     {A: MatrixMN(rows(M), columns(null[list[real]])) |
        FORALL (i, j): entry(A)(i, j) = row(M)(i) * col(null[list[real]])(j)} |
     null?(x) OR
      FORALL (i, j: below(length(x))): length(nth(x, i)) = length(nth(x, j))} from its value expression.

matrices typechecked in 3.345s: 60 TCCs, 0 proved, 20 subsumed, 40 unproved; 1 msg

 In declaration greater?:
  added conversion restrict
                       [[list[real], list[real]],
                        [(cons?[real]), (cons?[real])], bool]
             
  to <<, converting
     [[list[real], list[real]] -> bool]
  to [[(cons?), (cons?)] -> bool]


 In declaration greater_eq?:
  added conversion restrict
                       [[list[real], list[real]],
                        [(cons?[real]), (cons?[real])], bool]
             
  to <<, converting
     [[list[real], list[real]] -> bool]
  to [[(cons?), (cons?)] -> bool]


 In declaration less?:
  added conversion restrict
                       [[list[real], list[real]],
                        [(cons?[real]), (cons?[real])], bool]
             
  to <<, converting
     [[list[real], list[real]] -> bool]
  to [[(cons?), (cons?)] -> bool]


 In declaration less_eq?:
  added conversion restrict
                       [[list[real], list[real]],
                        [(cons?[real]), (cons?[real])], bool]
             
  to <<, converting
     [[list[real], list[real]] -> bool]
  to [[(cons?), (cons?)] -> bool]

vector_arithmetic typechecked in 4.668s: 62 TCCs, 0 proved, 16 subsumed, 46 unproved; 4 conversions
sum_vecs typechecked in 5.007s: 26 TCCs, 0 proved, 4 subsumed, 22 unproved
Parsing norm_1_extreme_value_theorem
norm_1_extreme_value_theorem parsed in 0.02 seconds
norm_1_extreme_value_theorem is already parsed
Typechecking norm_1_extreme_value_theorem
Parsing norm_1_sequential_criterian
norm_1_sequential_criterian parsed in 0.00 seconds
norm_1_sequential_criterian is already parsed
Typechecking norm_1_sequential_criterian
Parsing norm_1_defs
norm_1_defs parsed in 0.00 seconds
norm_1_defs is already parsed
Typechecking norm_1_defs
Parsing norms
norms parsed in 0.00 seconds
norms is already parsed
Typechecking norms
Parsing cauchy_schwarz
cauchy_schwarz parsed in 0.00 seconds
cauchy_schwarz is already parsed
Typechecking cauchy_schwarz
cauchy_schwarz typechecked in 0.14s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
norms typechecked in 0.94s: 77 TCCs, 0 proved, 40 subsumed, 37 unproved
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/mv_analysis/pvsbin/domain_vec2real_def.bin in 0.21s (load part took 0.00s)
norm_1_defs typechecked in 1.324s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
norm_1_sequential_criterian typechecked in 1.421s: No TCCs generated
Parsing norm_1_bolzano_weierstrass
norm_1_bolzano_weierstrass parsed in 0.00 seconds
norm_1_bolzano_weierstrass is already parsed
Typechecking norm_1_bolzano_weierstrass
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/mv_analysis/pvsbin/subsequences.bin in 0.29s (load part took 0.00s)
norm_1_bolzano_weierstrass typechecked in 0.44s: 4 TCCs, 0 proved, 2 subsumed, 2 unproved
Parsing unconstrained_global_extrema
unconstrained_global_extrema parsed in 0.00 seconds
unconstrained_global_extrema is already parsed
Typechecking unconstrained_global_extrema
unconstrained_global_extrema typechecked in 0.12s: 8 TCCs, 0 proved, 5 subsumed, 3 unproved
norm_1_extreme_value_theorem typechecked in 2.373s: 11 TCCs, 0 proved, 3 subsumed, 7 unproved, 1 trivial
norms_equiv typechecked in 7.816s: 49 TCCs, 0 proved, 27 subsumed, 22 unproved
Parsing continuity_multivar
continuity_multivar parsed in 0.01 seconds
continuity_multivar is already parsed
Typechecking continuity_multivar
Parsing norms_equiv_general
norms_equiv_general parsed in 0.00 seconds
norms_equiv_general is already parsed
Typechecking norms_equiv_general
norms_equiv_general typechecked in 0.09s: No TCCs generated
Parsing closed_bounded_domain
closed_bounded_domain parsed in 0.00 seconds
closed_bounded_domain is already parsed
Typechecking closed_bounded_domain
Parsing vector_sequences
vector_sequences parsed in 0.00 seconds
vector_sequences is already parsed
Typechecking vector_sequences
vector_sequences typechecked in 0.24s: 14 TCCs, 0 proved, 4 subsumed, 10 unproved
closed_bounded_domain typechecked in 0.36s: 3 TCCs, 0 proved, 1 subsumed, 2 unproved
continuity_multivar typechecked in 0.89s: 18 TCCs, 0 proved, 9 subsumed, 9 unproved
sequential_criterian typechecked in 9.012s: No TCCs generated
Parsing bolzano_weierstrass
bolzano_weierstrass parsed in 0.00 seconds
bolzano_weierstrass is already parsed
Typechecking bolzano_weierstrass
bolzano_weierstrass typechecked in 0.18s: 4 TCCs, 0 proved, 2 subsumed, 2 unproved
extreme_value_theorem typechecked in 9.438s: No TCCs generated
max_function typechecked in 9.687s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
interval_def typechecked in 13.923s: 7 TCCs, 0 proved, 5 subsumed, 2 unproved

 In declaration derivable_odes?:
  added conversion restrict[real, (D), real]
             
  to fs(k), converting
     [real -> real]
  to [(D) -> real]


 In declaration continuous_odes?:
  added conversion restrict[real, (D), real]
             
  to fs(k), converting
     [real -> real]
  to [(D) -> real]


 LET/WHERE variable vi at line 90, col 43 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 90, col 46 is given type
  RealExpr from its value expression.


 LET/WHERE variable i at line 123, col 11 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 123, col 13 is given type
  RealExpr from its value expression.


 In declaration sol_at_t?:
  added conversion restrict[real, (D), real]
             
  to fs(k), converting
     [real -> real]
  to [(D) -> real]


 LET/WHERE variable l at line 163, col 26 is given type
  Assigns from its value expression.


 LET/WHERE variable vk at line 165, col 29 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 165, col 32 is given type
  RealExpr from its value expression.

hp_expr typechecked in 41.785s: 31 TCCs, 0 proved, 7 subsumed, 24 unproved; 3 conversions; 7 msgs
Parsing bounded_star_semantics
bounded_star_semantics parsed in 0.00 seconds
bounded_star_semantics is already parsed
Typechecking bounded_star_semantics
Parsing orders_nat
orders_nat parsed in 0.00 seconds
orders_nat is already parsed
Typechecking orders_nat
orders_nat typechecked in 0.00s: No TCCs generated
Parsing lex2_generic
lex2_generic parsed in 0.00 seconds
lex2_generic is already parsed
Typechecking lex2_generic
lex2_generic typechecked in 0.00s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing bool_expr
bool_expr parsed in 0.01 seconds
bool_expr is already parsed
Typechecking bool_expr
bool_expr typechecked in 0.34s: 29 TCCs, 0 proved, 12 subsumed, 17 unproved
bounded_star_semantics typechecked in 1.056s: 16 TCCs, 0 proved, 5 subsumed, 11 unproved
Parsing bound_variables_def
bound_variables_def parsed in 0.00 seconds
bound_variables_def is already parsed
Typechecking bound_variables_def
bound_variables_def typechecked in 0.29s: 16 TCCs, 0 proved, 2 subsumed, 14 unproved
Parsing hp_props
hp_props parsed in 0.00 seconds
hp_props is already parsed
Typechecking hp_props
Error reading proof file /Users/cmunoz/src/PVS.gitlab/nasalib/dL/hp_props.prf:
  Package Y does not exist.

    Stream: #<dynamic-extent STRING-INPUT-STREAM (unavailable) from "y:2464">

 LET/WHERE variable enva at line 91, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable env at line 131, col 14 is given type
  Environment from its value expression.

Parsing closed_int_ops
closed_int_ops parsed in 0.00 seconds
closed_int_ops is already parsed
Typechecking closed_int_ops
closed_int_ops typechecked in 0.00s: No TCCs generated

 In declaration star_prop:
  added conversion cnst
             
  to 1, converting
     real
  to [Environment -> real]


 In declaration while_prop:
  added conversion cnst
             
  to 1, converting
     real
  to [Environment -> real]


 LET/WHERE variable P0 at line 157, col 10 is given type
  HP from its value expression.


 In declaration while_prop:
  added conversion cnst
             
  to 1, converting
     real
  to [Environment -> real]

Error reading proof file /Users/cmunoz/src/PVS.gitlab/nasalib/dL/hp_props.prf:
  Package Y does not exist.

    Stream: #<dynamic-extent STRING-INPUT-STREAM (unavailable) from "y:2464">
hp_props typechecked in 1.072s: 17 TCCs, 0 proved, 11 subsumed, 6 unproved; 3 conversions; 3 msgs
Parsing substitution
substitution parsed in 0.01 seconds
substitution is already parsed
Typechecking substitution

 LET/WHERE variable n at line 27, col 13 is given type
  nat from its value expression.


 LET/WHERE variable r at line 28, col 13 is given type
  real from its value expression.


 LET/WHERE variable v1 at line 43, col 12 is given type
  dLVar from its value expression.


 LET/WHERE variable e1 at line 43, col 15 is given type
  RealExpr from its value expression.


 LET/WHERE variable v2 at line 44, col 12 is given type
  dLVar from its value expression.


 LET/WHERE variable e2 at line 44, col 15 is given type
  RealExpr from its value expression.


 LET/WHERE variable n at line 57, col 13 is given type
  nat from its value expression.


 LET/WHERE variable r at line 58, col 13 is given type
  real from its value expression.


 LET/WHERE variable k at line 65, col 50 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 65, col 52 is given type
  RealExpr from its value expression.


 LET/WHERE variable k at line 68, col 48 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 68, col 50 is given type
  RealExpr from its value expression.


 LET/WHERE variable k at line 65, col 50 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 65, col 52 is given type
  RealExpr from its value expression.


 LET/WHERE variable n at line 2, col 9 is given type
  nat from its value expression.


 LET/WHERE variable r at line 2, col 36 is given type
  real from its value expression.


 LET/WHERE variable k at line 76, col 55 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 76, col 57 is given type
  RealExpr from its value expression.


 LET/WHERE variable k at line 81, col 43 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 81, col 45 is given type
  RealExpr from its value expression.


 In declaration dl_subre_prod_scal2:
  added conversion cnst
             
  to k, converting
     real
  to [Environment -> real]


 In declaration dl_subre_prod_scal2:
  added conversion cnst
             
  to k, converting
     real
  to [Environment -> real]

Parsing for_examples
for_examples parsed in 0.00 seconds
for_examples is already parsed
Typechecking for_examples
Parsing for_iterate
for_iterate parsed in 0.01 seconds
for_iterate is already parsed
Typechecking for_iterate
for_iterate typechecked in 0.57s: 74 TCCs, 0 proved, 14 subsumed, 60 unproved
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/ints/pvsbin/factorial.bin in 0.02s (load part took 0.00s)
Parsing Maybe
Maybe parsed in 0.00 seconds
Maybe is already parsed
Typechecking Maybe
Maybe typechecked in 0.03s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
for_examples typechecked in 1.005s: 23 TCCs, 0 proved, 10 subsumed, 13 unproved

 LET/WHERE variable A at line 204, col 10 is given type
  (assign?) from its value expression.


 LET/WHERE variable sigma at line 205, col 9 is given type
  (cons?[[dLVar, RealExpr]]) from its value expression.


 LET/WHERE variable sigmap at line 206, col 9 is given type
  (cons?[[dLVar, [Environment -> real]]]) from its value expression.


 LET/WHERE variable A at line 213, col 10 is given type
  (assign?) from its value expression.


 LET/WHERE variable sigma at line 214, col 10 is given type
  (cons?[[dLVar, RealExpr]]) from its value expression.


 LET/WHERE variable Ap at line 215, col 10 is given type
  (assign?) from its value expression.

substitution typechecked in 2.378s: 46 TCCs, 0 proved, 18 subsumed, 28 unproved; 2 conversions; 26 msgs
Parsing ODEs_equiv
ODEs_equiv parsed in 0.01 seconds
ODEs_equiv is already parsed
Typechecking ODEs_equiv
Parsing ODE_solution_existence_uniqueness
ODE_solution_existence_uniqueness parsed in 0.01 seconds
ODE_solution_existence_uniqueness is already parsed
Typechecking ODE_solution_existence_uniqueness
Parsing continuous_function_complete_rho
continuous_function_complete_rho parsed in 0.00 seconds
continuous_function_complete_rho is already parsed
Typechecking continuous_function_complete_rho
Parsing metric_rho
metric_rho parsed in 0.00 seconds
metric_rho is already parsed
Typechecking metric_rho
Parsing r2v_continuous_extension
r2v_continuous_extension parsed in 0.00 seconds
r2v_continuous_extension is already parsed
Typechecking r2v_continuous_extension
Parsing top
top parsed in 0.00 seconds
top is already parsed
Typechecking top
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/ln_exp.bin in 0.66s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/expt.bin in 0.66s (load part took 0.00s)
Parsing hyperbolic
hyperbolic parsed in 0.01 seconds
hyperbolic is already parsed
Typechecking hyperbolic
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/restrict2_deriv.bin in 0.11s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/nth_derivatives.bin in 0.08s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/taylors.bin in 0.17s (load part took 0.00s)
Parsing polynomial_deriv
polynomial_deriv parsed in 0.00 seconds
polynomial_deriv is already parsed
Typechecking polynomial_deriv
Parsing binomial
binomial parsed in 0.00 seconds
binomial is already parsed
Typechecking binomial
Parsing factorial
factorial parsed in 0.00 seconds
factorial is already parsed
Typechecking factorial
Parsing product
product parsed in 0.01 seconds
product is already parsed
Typechecking product
product typechecked in 0.36s: 43 TCCs, 0 proved, 14 subsumed, 29 unproved; 4 warnings
factorial typechecked in 0.53s: 12 TCCs, 0 proved, 2 subsumed, 10 unproved
binomial typechecked in 0.87s: 23 TCCs, 0 proved, 2 subsumed, 21 unproved
Parsing polynomials
polynomials parsed in 0.03 seconds
polynomials is already parsed
Typechecking polynomials

 LET/WHERE variable eventzero at line 173, col 8 is given type
  [sequence[real] -> boolean] from its value expression.


 LET/WHERE variable g at line 198, col 10 is given type
  sequence[real] from its value expression.


 LET/WHERE variable idf at line 228, col 31 is given type
  [real -> real] from its value expression.


 LET/WHERE variable fk at line 448, col 8 is given type
  [real -> real] from its value expression.


 LET/WHERE variable fn1 at line 449, col 5 is given type
  [real -> real] from its value expression.


 LET/WHERE variable fk at line 469, col 8 is given type
  [real -> real] from its value expression.


 LET/WHERE variable fn1 at line 470, col 5 is given type
  [real -> real] from its value expression.

polynomials typechecked in 1.525s: 111 TCCs, 0 proved, 44 subsumed, 67 unproved; 7 msgs
polynomial_deriv typechecked in 3.581s: 9 TCCs, 0 proved, 2 subsumed, 7 unproved

 LET/WHERE variable y at line 119, col 36 is given type
  {nnz: nnreal | nnz * nnz = (cosh(x) - 1) / 2} from its value expression.


 LET/WHERE variable y at line 122, col 36 is given type
  {nnz: nnreal | nnz * nnz = (cosh(x) - 1) / (1 + cosh(x))} from its value expression.

hyperbolic typechecked in 8.023s: 89 TCCs, 0 proved, 16 subsumed, 73 unproved; 2 msgs
Parsing exp_series
exp_series parsed in 0.00 seconds
exp_series is already parsed
Typechecking exp_series
Parsing taylor_series
taylor_series parsed in 0.00 seconds
taylor_series is already parsed
Typechecking taylor_series
Parsing power_series_deriv
power_series_deriv parsed in 0.00 seconds
power_series_deriv is already parsed
Typechecking power_series_deriv
Parsing power_series_deriv_scaf
power_series_deriv_scaf parsed in 0.00 seconds
power_series_deriv_scaf is already parsed
Typechecking power_series_deriv_scaf
Parsing power_series_derivseq
power_series_derivseq parsed in 0.00 seconds
power_series_derivseq is already parsed
Typechecking power_series_derivseq
Parsing power_series_conv
power_series_conv parsed in 0.03 seconds
power_series_conv is already parsed
Typechecking power_series_conv
Parsing power_series
power_series parsed in 0.00 seconds
power_series is already parsed
Typechecking power_series
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/series/pvsbin/series.bin in 0.24s (load part took 0.00s)
Parsing exponent_props
exponent_props parsed in 0.00 seconds
exponent_props is already parsed
Typechecking exponent_props
exponent_props typechecked in 0.11s: 9 TCCs, 0 proved, 5 subsumed, 4 unproved
power_series typechecked in 0.64s: 3 TCCs, 0 proved, 1 subsumed, 2 unproved
power_series_conv typechecked in 0.75s: 5 TCCs, 0 proved, 0 subsumed, 5 unproved
power_series_derivseq typechecked in 1.055s: 13 TCCs, 0 proved, 4 subsumed, 8 unproved, 1 trivial

 LET/WHERE variable ALPH at line 71, col 38 is given type
  {z: nonneg_real | z >= abs(x) AND z >= abs(xp)} from its value expression.

power_series_deriv_scaf typechecked in 1.804s: 26 TCCs, 0 proved, 6 subsumed, 20 unproved; 1 msg

 LET/WHERE variable f at line 84, col 14 is given type
  [T -> real] from its value expression.


 LET/WHERE variable g at line 85, col 14 is given type
  [T -> real] from its value expression.

power_series_deriv typechecked in 2.064s: 13 TCCs, 0 proved, 4 subsumed, 9 unproved; 2 msgs
taylor_series typechecked in 2.491s: 21 TCCs, 0 proved, 4 subsumed, 17 unproved
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/convergence_special.bin in 0.73s (load part took 0.00s)
exp_series typechecked in 5.245s: 11 TCCs, 0 proved, 0 subsumed, 11 unproved
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/integral_diff_doms.bin in 0.28s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/analysis/pvsbin/integral_chg_var.bin in 0.28s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/series/pvsbin/power_series_integ.bin in 0.76s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/ln_series.bin in 0.87s (load part took 0.00s)
Parsing exp_approx
exp_approx parsed in 0.01 seconds
exp_approx is already parsed
Typechecking exp_approx
Parsing quad_minmax
quad_minmax parsed in 0.01 seconds
quad_minmax is already parsed
Typechecking quad_minmax
Parsing quadratic
quadratic parsed in 0.01 seconds
quadratic is already parsed
Typechecking quadratic
quadratic typechecked in 0.50s: 10 TCCs, 0 proved, 1 subsumed, 9 unproved

 LET/WHERE variable f at line 24, col 33 is given type
  [real -> real] from its value expression.


 LET/WHERE variable m at line 24, col 55 is given type
  real from its value expression.


 LET/WHERE variable f at line 27, col 33 is given type
  [real -> real] from its value expression.


 LET/WHERE variable m at line 27, col 55 is given type
  real from its value expression.


 LET/WHERE variable f at line 36, col 24 is given type
  [real -> real] from its value expression.


 LET/WHERE variable minpt at line 37, col 28 is given type
  real from its value expression.


 LET/WHERE variable f at line 41, col 27 is given type
  [real -> real] from its value expression.


 LET/WHERE variable minpt at line 42, col 27 is given type
  real from its value expression.


 LET/WHERE variable f at line 46, col 32 is given type
  [real -> real] from its value expression.


 LET/WHERE variable minpt at line 47, col 32 is given type
  real from its value expression.


 LET/WHERE variable f at line 53, col 33 is given type
  [real -> real] from its value expression.


 LET/WHERE variable minpt at line 54, col 33 is given type
  real from its value expression.


 LET/WHERE variable f at line 83, col 23 is given type
  [real -> real] from its value expression.


 LET/WHERE variable maxpt at line 84, col 23 is given type
  real from its value expression.


 LET/WHERE variable f at line 88, col 27 is given type
  [real -> real] from its value expression.


 LET/WHERE variable maxpt at line 89, col 27 is given type
  real from its value expression.


 LET/WHERE variable f at line 94, col 32 is given type
  [real -> real] from its value expression.


 LET/WHERE variable maxpt at line 95, col 32 is given type
  real from its value expression.


 LET/WHERE variable f at line 101, col 32 is given type
  [real -> real] from its value expression.


 LET/WHERE variable maxpt at line 102, col 32 is given type
  real from its value expression.


 LET/WHERE variable F at line 138, col 7 is given type
  [real -> real] from its value expression.

quad_minmax typechecked in 0.77s: 1 TCC, 0 proved, 0 subsumed, 1 unproved; 21 msgs

 LET/WHERE variable pn at line 41, col 33 is given type
  int from its value expression.


 LET/WHERE variable pn at line 43, col 33 is given type
  int from its value expression.


 LET/WHERE variable TT at line 83, col 8 is given type
  [negreal -> bool] from its value expression.


 LET/WHERE variable TT at line 87, col 8 is given type
  [negreal -> bool] from its value expression.


 LET/WHERE variable xx at line 92, col 10 is given type
  nzrat from its value expression.


 LET/WHERE variable yy at line 92, col 36 is given type
  rat from its value expression.

exp_approx typechecked in 1.918s: 18 TCCs, 0 proved, 4 subsumed, 14 unproved; 6 msgs
Parsing ln_approx
ln_approx parsed in 0.00 seconds
ln_approx is already parsed
Typechecking ln_approx
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/reals/pvsbin/prelude_aux.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/reals/pvsbin/log_nat.bin in 0.04s (load part took 0.00s)
Parsing log_int
log_int parsed in 0.00 seconds
log_int is already parsed
Typechecking log_int

 LET/WHERE variable LN at line 12, col 13 is given type
  [n: nat, {y | y < p AND 1 / x = p ^ n * y}] from its value expression.


 LET/WHERE variable z at line 19, col 9 is given type
  z: int from its value expression.


 LET/WHERE variable y at line 19, col 11 is given type
  {y: real | y < p AND y >= 1 AND x = p ^ z * y} from its value expression.

log_int typechecked in 0.20s: 7 TCCs, 0 proved, 0 subsumed, 7 unproved; 3 msgs

 LET/WHERE variable A at line 46, col 9 is given type
  {x: posreal | x <= 1/3} from its value expression.


 LET/WHERE variable N at line 78, col 13 is given type
  n: nat from its value expression.


 LET/WHERE variable Y at line 78, col 15 is given type
  {y | y < 2 AND xge1 = 2 ^ n * y} from its value expression.


 LET/WHERE variable N at line 82, col 13 is given type
  n: nat from its value expression.


 LET/WHERE variable Y at line 82, col 15 is given type
  {y | y < 2 AND xge1 = 2 ^ n * y} from its value expression.

ln_approx typechecked in 1.439s: 28 TCCs, 0 proved, 4 subsumed, 24 unproved; 5 msgs
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/ln_exp_series_alt.bin in 1.215s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/ln_exp_ineq.bin in 0.83s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/harmonic_series.bin in 0.74s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/ln_derivative_lam.bin in 0.80s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/lnexp_safe_ops.bin in 0.71s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/lnexp/pvsbin/strategies.bin in 0.82s (load part took 0.00s)
top typechecked in 27.557s: No TCCs generated
Parsing r2v_analysis
r2v_analysis parsed in 0.02 seconds
r2v_analysis is already parsed
Typechecking r2v_analysis
Parsing r2v_def
r2v_def parsed in 0.00 seconds
r2v_def is already parsed
Typechecking r2v_def
r2v_def typechecked in 0.18s: 16 TCCs, 0 proved, 3 subsumed, 13 unproved
r2v_analysis typechecked in 0.89s: 61 TCCs, 0 proved, 9 subsumed, 52 unproved
r2v_continuous_extension typechecked in 31.961s: 36 TCCs, 0 proved, 12 subsumed, 24 unproved
Parsing metric_def
metric_def parsed in 0.00 seconds
metric_def is already parsed
Typechecking metric_def
metric_def typechecked in 0.01s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved; 2 warnings
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/mv_analysis/pvsbin/composition_function.bin in 1.024s (load part took 0.00s)
metric_rho typechecked in 34.449s: 10 TCCs, 0 proved, 3 subsumed, 7 unproved
Parsing banach
banach parsed in 0.00 seconds
banach is already parsed
Typechecking banach
Parsing metric_space_def
metric_space_def parsed in 0.00 seconds
metric_space_def is already parsed
Typechecking metric_space_def
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/set_antisymmetric.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/relations_extra.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/bounded_orders.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/minmax_orders.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/indexed_sets_extra.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/relation_iterate.bin in 0.05s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/closure_ops.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/ordered_subset.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/chain.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/subset_chain.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/chain_chain.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/zorn.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/set_dichotomous.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/bounded_sets.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/upper_semilattices.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/lower_semilattices.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/lattices.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/total_lattices.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/non_empty_bounded_sets.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/bounded_integers.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/integer_enumerations.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/card_comp_set.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/card_comp_set_props.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/card_function.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/infinite_nat_def.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/countability.bin in 0.12s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/countable_props.bin in 0.13s (load part took 0.00s)
metric_space_def typechecked in 1.358s: No TCCs generated
banach typechecked in 1.468s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
Parsing r2v_sequence_convergence
r2v_sequence_convergence parsed in 0.00 seconds
r2v_sequence_convergence is already parsed
Typechecking r2v_sequence_convergence
Parsing Cauchy_seq
Cauchy_seq parsed in 0.00 seconds
Cauchy_seq is already parsed
Typechecking Cauchy_seq
Parsing euclidean
euclidean parsed in 0.00 seconds
euclidean is already parsed
Typechecking euclidean
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/pvsbin/vectors.bin in 0.20s (load part took 0.00s)
Parsing bounded_reals
bounded_reals parsed in 0.00 seconds
bounded_reals is already parsed
Typechecking bounded_reals
Parsing reals_complete_more
reals_complete_more parsed in 0.00 seconds
reals_complete_more is already parsed
Typechecking reals_complete_more
Parsing bound_defs
bound_defs parsed in 0.00 seconds
bound_defs is already parsed
Typechecking bound_defs
bound_defs typechecked in 0.00s: No TCCs generated
reals_complete_more typechecked in 0.01s: No TCCs generated
bounded_reals typechecked in 0.04s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing metric_space
metric_space parsed in 0.00 seconds
metric_space is already parsed
Typechecking metric_space
Parsing topology_def
topology_def parsed in 0.00 seconds
topology_def is already parsed
Typechecking topology_def
Parsing topology_prelim
topology_prelim parsed in 0.00 seconds
topology_prelim is already parsed
Typechecking topology_prelim
topology_prelim typechecked in 0.02s: 19 TCCs, 0 proved, 1 subsumed, 18 unproved; 6 warnings
Parsing basis
basis parsed in 0.00 seconds
basis is already parsed
Typechecking basis

 In declaration synthetic_generated_alt_def:
  added conversion extend[setof[T], (B), bool, FALSE]
             
  to {x: (B) | subset?(x, A)}, converting
     [(B) -> bool]
  to [setof[T] -> bool]

basis typechecked in 0.02s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved; 1 conversion; 2 warnings
topology_def typechecked in 0.16s: 1 TCC, 0 proved, 0 subsumed, 1 unproved; 1 warning
Parsing topology
topology parsed in 0.00 seconds
topology is already parsed
Typechecking topology
Parsing prelude_sets_aux
prelude_sets_aux parsed in 0.00 seconds
prelude_sets_aux is already parsed
Typechecking prelude_sets_aux
prelude_sets_aux typechecked in 0.01s: No TCCs generated; 1 warning

 In declaration interior:
  added conversion extend[T, (A), bool, FALSE]
             
  to {x: (A) | interior_point?(x, A)}, converting
     [(A) -> bool]
  to [T -> bool]

topology typechecked in 0.19s: 34 TCCs, 0 proved, 7 subsumed, 27 unproved; 1 conversion; 27 warnings
Parsing hausdorff_convergence
hausdorff_convergence parsed in 0.00 seconds
hausdorff_convergence is already parsed
Typechecking hausdorff_convergence
Parsing topological_convergence
topological_convergence parsed in 0.00 seconds
topological_convergence is already parsed
Typechecking topological_convergence
Parsing subseq
subseq parsed in 0.00 seconds
subseq is already parsed
Typechecking subseq
subseq typechecked in 0.01s: No TCCs generated
topological_convergence typechecked in 0.12s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
hausdorff_convergence typechecked in 0.21s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved; 1 warning
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/bounded_nats.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/bits.bin in 0.16s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/countable_set.bin in 0.24s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/countable_setofsets.bin in 0.16s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/infinite_image.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/countable_image.bin in 0.15s (load part took 0.00s)
Parsing countable_cross
countable_cross parsed in 0.00 seconds
countable_cross is already parsed
Typechecking countable_cross
Parsing cross_product
cross_product parsed in 0.00 seconds
cross_product is already parsed
Typechecking cross_product
cross_product typechecked in 0.01s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
countable_cross typechecked in 0.32s: No TCCs generated
Parsing lindelof
lindelof parsed in 0.00 seconds
lindelof is already parsed
Typechecking lindelof
lindelof typechecked in 0.11s: No TCCs generated
Parsing nat_indexed_sets
nat_indexed_sets parsed in 0.00 seconds
nat_indexed_sets is already parsed
Typechecking nat_indexed_sets
Parsing fun_preds_partial
fun_preds_partial parsed in 0.00 seconds
fun_preds_partial is already parsed
Typechecking fun_preds_partial
fun_preds_partial typechecked in 0.00s: No TCCs generated

 In declaration IMPORTING structures@fun_preds_partial[nat, set[T], reals.<=, subset?[T]]:
  added conversion restrict[[real, real], [nat, nat], bool]
             
  to reals.<=, converting
     [[real, real] -> bool]
  to [[nat, nat] -> bool]

Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/indexed_sets_aux.bin in 0.02s (load part took 0.00s)
nat_indexed_sets typechecked in 0.27s: 1 TCC, 0 proved, 0 subsumed, 1 unproved; 1 conversion
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/countable_indexed_sets.bin in 0.15s (load part took 0.00s)
metric_space typechecked in 4.623s: 10 TCCs, 0 proved, 0 subsumed, 10 unproved; 4 warnings
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/orders/pvsbin/numbers_infinite.bin in 0.02s (load part took 0.00s)
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/sets_aux/pvsbin/countable_types.bin in 0.16s (load part took 0.00s)

 In declaration ball_basis:
  added conversion extend[setof[Vector[n]], balls, bool, FALSE]
             
  to fullset[balls], converting
     [balls -> bool]
  to [setof[Vector[n]] -> bool]


 In declaration Qn_basis:
  added conversion extend[setof[Vector[n]], rational_balls, bool, FALSE]
             
  to fullset[rational_balls], converting
     [rational_balls -> bool]
  to [setof[Vector[n]] -> bool]

Parsing complete_product
complete_product parsed in 0.00 seconds
complete_product is already parsed
Typechecking complete_product
complete_product typechecked in 0.22s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing real_topology
real_topology parsed in 0.00 seconds
real_topology is already parsed
Typechecking real_topology
Parsing metric_def_real_props
metric_def_real_props parsed in 0.00 seconds
metric_def_real_props is already parsed
Typechecking metric_def_real_props
metric_def_real_props typechecked in 0.00s: No TCCs generated

 In declaration open_basis:
  added conversion extend[setof[real], open_interval, bool, FALSE]
             
  to fullset[open_interval], converting
     [open_interval -> bool]
  to [setof[real] -> bool]


 In declaration rational_basis:
  added conversion extend[setof[real], rational_open_interval, bool, FALSE]
             
  to fullset[rational_open_interval], converting
     [rational_open_interval -> bool]
  to [setof[real] -> bool]

real_topology typechecked in 0.71s: 27 TCCs, 0 proved, 1 subsumed, 26 unproved; 2 conversions; 2 warnings
euclidean typechecked in 8.024s: 12 TCCs, 0 proved, 2 subsumed, 10 unproved; 2 conversions; 3 warnings
Restored theory from /Users/cmunoz/src/PVS.gitlab/nasalib/mv_analysis/pvsbin/Vector_VectorN.bin in 0.95s (load part took 0.00s)
Cauchy_seq typechecked in 11.531s: 2 TCCs, 0 proved, 1 subsumed, 1 unproved
r2v_sequence_convergence typechecked in 13.847s: 45 TCCs, 0 proved, 29 subsumed, 16 unproved
continuous_function_complete_rho typechecked in 51.478s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing ODE_psi_contraction
ODE_psi_contraction parsed in 0.01 seconds
ODE_psi_contraction is already parsed
Typechecking ODE_psi_contraction
Parsing exp_analysis
exp_analysis parsed in 0.00 seconds
exp_analysis is already parsed
Typechecking exp_analysis
exp_analysis typechecked in 0.78s: 17 TCCs, 0 proved, 5 subsumed, 12 unproved
Parsing norm_ineq
norm_ineq parsed in 0.02 seconds
norm_ineq is already parsed
Typechecking norm_ineq
Parsing ODE_continuous_def
ODE_continuous_def parsed in 0.00 seconds
ODE_continuous_def is already parsed
Typechecking ODE_continuous_def
Parsing ODE_Lipschitz_def
ODE_Lipschitz_def parsed in 0.00 seconds
ODE_Lipschitz_def is already parsed
Typechecking ODE_Lipschitz_def
Parsing ODE_def
ODE_def parsed in 0.00 seconds
ODE_def is already parsed
Typechecking ODE_def
ODE_def typechecked in 0.34s: 11 TCCs, 0 proved, 0 subsumed, 11 unproved
ODE_Lipschitz_def typechecked in 0.67s: 17 TCCs, 0 proved, 2 subsumed, 15 unproved

 In declaration cont_Lip_2ndv:
  added conversion restrict
                       [VectorN(n), (LAMBDA (x: VectorN(n)): d(car[real](x))),
                        VectorN(n)]
             
  to LAMBDA (v: VectorN(n)): f(t, v), converting
     [VectorN(n) -> VectorN(n)]
  to [(LAMBDA (x: VectorN(n)): d(car(x))) -> VectorN(n)]

ODE_continuous_def typechecked in 2.084s: 25 TCCs, 0 proved, 9 subsumed, 16 unproved; 1 conversion
norm_ineq typechecked in 3.068s: 25 TCCs, 0 proved, 2 subsumed, 23 unproved
Parsing ODE_psi_def
ODE_psi_def parsed in 0.00 seconds
ODE_psi_def is already parsed
Typechecking ODE_psi_def
ODE_psi_def typechecked in 0.33s: 7 TCCs, 0 proved, 0 subsumed, 7 unproved
ODE_psi_contraction typechecked in 22.274s: 188 TCCs, 0 proved, 143 subsumed, 45 unproved
Parsing restrict_ode
restrict_ode parsed in 0.00 seconds
restrict_ode is already parsed
Typechecking restrict_ode
restrict_ode typechecked in 0.57s: 24 TCCs, 0 proved, 8 subsumed, 16 unproved

 In declaration Psi_contract:
  added conversion restrict[S[d](n), (fullset[S[d](n)]), S[d](n)]
             
  to Psi(d, n, f, y0), converting
     [S[d](n) -> S[d](n)]
  to [(fullset[S[d](n)]) -> S[d](n)]


 In declaration Psi_fixed_point:
  added conversion restrict[S[d](n), (fullset[S[d](n)]), S[d](n)]
             
  to Psi(d, n, f, y0), converting
     [S[d](n) -> S[d](n)]
  to [(fullset[S[d](n)]) -> S[d](n)]


 In declaration init_unique_solution:
  added conversion restrict[S[d](n), (fullset[S[d](n)]), S[d](n)]
             
  to Psi(d, n, f, y0), converting
     [S[d](n) -> S[d](n)]
  to [(fullset[S[d](n)]) -> S[d](n)]

ODE_solution_existence_uniqueness typechecked in 86.357s: 210 TCCs, 0 proved, 135 subsumed, 75 unproved; 3 conversions
Parsing r2v_diff_extension
r2v_diff_extension parsed in 0.01 seconds
r2v_diff_extension is already parsed
Typechecking r2v_diff_extension

 LET/WHERE variable g at line 52, col 6 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 63, col 6 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 79, col 6 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 90, col 6 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 107, col 6 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 119, col 6 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 137, col 6 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 149, col 6 is given type
  [real -> real] from its value expression.


 LET/WHERE variable g at line 161, col 6 is given type
  [real -> real] from its value expression.

r2v_diff_extension typechecked in 2.489s: 208 TCCs, 0 proved, 187 subsumed, 21 unproved; 9 msgs

 LET/WHERE variable i at line 47, col 9 is given type
  dLVar from its value expression.


 LET/WHERE variable re at line 47, col 11 is given type
  RealExpr from its value expression.


 In declaration fs_2_r2v:
  added conversion restrict[real, (d), (cons?[real])]
             
  to LAMBDA (r: real): (: fs(0)(r) :), converting
     [real -> (cons?)]
  to [(d) -> (cons?)]


 In declaration fs_2_r2v:
  added conversion restrict[real, (d), real]
             
  to fs(0), converting
     [real -> real]
  to [(d) -> real]


 In declaration fs_2_f2v_nth:
  added conversion restrict[real, (d), real]
             
  to fs(i), converting
     [real -> real]
  to [(d) -> real]


 In declaration fs_2_f2v_eq:
  added conversion restrict[real, (closed_interval(0, r)), VectorN(n)]
             
  to y, converting
     [real -> VectorN(n)]
  to [(closed_interval(0, r)) -> VectorN(n)]


 In declaration fs_2_f2v_eq:
  added conversion restrict[real, (closed_interval(0, r)), VectorN(n)]
             
  to y, converting
     [real -> VectorN(n)]
  to [(closed_interval(0, r)) -> VectorN(n)]

ODEs_equiv typechecked in 100.117s: 132 TCCs, 0 proved, 49 subsumed, 83 unproved; 5 conversions; 2 msgs
Parsing differentiation
differentiation parsed in 0.02 seconds
differentiation is already parsed
Typechecking differentiation

 In declaration dl_derivable_div:
  added LAMBDA conversion, converting
    div_safe(r1, r2)
  to
    LAMBDA (s: Environment): div_safe(r1(s), r2(s))


 In declaration dl_partial_div:
  added LAMBDA conversion, converting
    div_safe(r1, r2)
  to
    LAMBDA (s: Environment): div_safe(r1(s), r2(s))


 In declaration dl_partial_div:
  added LAMBDA conversion, converting
    div_safe(partial_diff(i, P)(r1) * r2 - r1 * partial_diff(i, P)(r2), r2 * r2)
  to
    LAMBDA (s: Environment):
      div_safe((partial_diff(i, P)(r1) * r2 - r1 * partial_diff(i, P)(r2))(s),
               (r2 * r2)(s))


 In declaration dl_derivable_up_div:
  added LAMBDA conversion, converting
    div_safe(re1, re2)
  to
    LAMBDA (s: Environment): div_safe(re1(s), re2(s))


 In declaration dl_derivable_comp_point:
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]


 In declaration dl_derivable_comp:
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]


 In declaration dl_partial_chain:
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]


 In declaration dl_partial_chain:
  added conversion restrict[real, (D), real]
             
  to f, converting
     [real -> real]
  to [(D) -> real]


 In declaration dl_partial_sqrt:
  added conversion cnst
             
  to 1, converting
     real
  to [Environment -> real]


 In declaration DIFT_Re:
  added conversion cnst
             
  to 0, converting
     real
  to [Environment -> real]


 In declaration DIFT_last:
  added conversion cnst
             
  to 0, converting
     real
  to [Environment -> real]


 In declaration ddt:
  added conversion cnst
             
  to 0, converting
     real
  to [Environment -> real]


 In declaration ddt_not_in_map:
  added conversion cnst
             
  to 0, converting
     real
  to [Environment -> real]


 In declaration ddt_in_map:
  added conversion extend[nat, below(length[MapExpr](ode)), bool, FALSE]
             
  to index_of(ode, x), converting
     [below(length(ode)) -> bool]
  to [nat -> bool]


 LET/WHERE variable k at line 631, col 7 is given type
  (extend[nat, below(length[MapExpr](ode)), bool, FALSE](index_of(ode, x))) from its value expression.


 In declaration ddt_in_map:
  added conversion extend[nat, below(length[MapExpr](ode)), bool, FALSE]
             
  to index_of(ode, x), converting
     [below(length(ode)) -> bool]
  to [nat -> bool]

differentiation typechecked in 3.096s: 73 TCCs, 0 proved, 20 subsumed, 53 unproved; 15 conversions; 1 msg
Parsing chain_rule_re
chain_rule_re parsed in 0.02 seconds
chain_rule_re is already parsed
Typechecking chain_rule_re
Parsing lift_real_fun_def
lift_real_fun_def parsed in 0.03 seconds
lift_real_fun_def is already parsed
Typechecking lift_real_fun_def
Parsing chain_rule_multi
chain_rule_multi parsed in 0.01 seconds
chain_rule_multi is already parsed
Typechecking chain_rule_multi
Parsing convergence_vec2vec
convergence_vec2vec parsed in 0.01 seconds
convergence_vec2vec is already parsed
Typechecking convergence_vec2vec
Parsing mat_vec_mult
mat_vec_mult parsed in 0.00 seconds
mat_vec_mult is already parsed
Typechecking mat_vec_mult
mat_vec_mult typechecked in 0.72s: 37 TCCs, 0 proved, 3 subsumed, 34 unproved
Parsing derivative_domain_multi
derivative_domain_multi parsed in 0.01 seconds
derivative_domain_multi is already parsed
Typechecking derivative_domain_multi
Parsing topology_Rn
topology_Rn parsed in 0.00 seconds
topology_Rn is already parsed
Typechecking topology_Rn

 In declaration Union_open:
  added conversion extend[setof[VectorN(n)], open_domain, bool, FALSE]
             
  to sA, converting
     [open_domain -> bool]
  to [setof[VectorN(n)] -> bool]

topology_Rn typechecked in 0.30s: 3 TCCs, 0 proved, 1 subsumed, 2 unproved; 1 conversion
derivative_domain_multi typechecked in 0.62s: 18 TCCs, 0 proved, 4 subsumed, 14 unproved
Parsing gradient_def
gradient_def parsed in 0.00 seconds
gradient_def is already parsed
Typechecking gradient_def
Parsing partial_def
partial_def parsed in 0.00 seconds
partial_def is already parsed
Typechecking partial_def
Parsing directional_deriv_def
directional_deriv_def parsed in 0.00 seconds
directional_deriv_def is already parsed
Typechecking directional_deriv_def
Parsing init_partial_def
init_partial_def parsed in 0.01 seconds
init_partial_def is already parsed
Typechecking init_partial_def
Parsing differentiable_def
differentiable_def parsed in 0.00 seconds
differentiable_def is already parsed
Typechecking differentiable_def
differentiable_def typechecked in 0.26s: 7 TCCs, 0 proved, 0 subsumed, 7 unproved

 In declaration init_partial?:
  added conversion restrict[real, (D_down(D, p, v)), real]
             
  to LAMBDA (Delta: real): f(p + Delta * v), converting
     [real -> real]
  to [(D_down(D, p, v)) -> real]


 In declaration init_partial:
  added conversion restrict[real, (D_down(D, p, v)), real]
             
  to LAMBDA (Delta: real): f(p + Delta * v), converting
     [real -> real]
  to [(D_down(D, p, v)) -> real]

init_partial_def typechecked in 1.117s: 49 TCCs, 0 proved, 11 subsumed, 38 unproved; 2 conversions

 In declaration directional_deriv?:
  added conversion restrict[real, (D_downd(D, p, v)), real]
             
  to LAMBDA (Delta: real): f(p + Delta * v), converting
     [real -> real]
  to [(D_downd(D, p, v)) -> real]


 In declaration directional_deriv:
  added conversion restrict[real, (D_downd(D, p, v)), real]
             
  to LAMBDA (Delta: real): f(p + Delta * v), converting
     [real -> real]
  to [(D_downd(D, p, v)) -> real]

directional_deriv_def typechecked in 1.947s: 49 TCCs, 0 proved, 9 subsumed, 40 unproved; 2 conversions
partial_def typechecked in 2.29s: 19 TCCs, 0 proved, 2 subsumed, 17 unproved
Parsing fundamentals_constrained_optimization
fundamentals_constrained_optimization parsed in 0.02 seconds
fundamentals_constrained_optimization is already parsed
Typechecking fundamentals_constrained_optimization
Parsing unconstrained_local_extrema
unconstrained_local_extrema parsed in 0.00 seconds
unconstrained_local_extrema is already parsed
Typechecking unconstrained_local_extrema
unconstrained_local_extrema typechecked in 0.22s: 13 TCCs, 0 proved, 9 subsumed, 4 unproved

 LET/WHERE variable FL at line 124, col 9 is given type
  list[T] from its value expression.


 LET/WHERE variable FL at line 131, col 9 is given type
  list[T] from its value expression.


 LET/WHERE variable FL at line 137, col 9 is given type
  list[vec2real_f[n]] from its value expression.


 LET/WHERE variable FL at line 144, col 9 is given type
  list[vec2real_f[n]] from its value expression.

fundamentals_constrained_optimization typechecked in 1.085s: 57 TCCs, 0 proved, 25 subsumed, 32 unproved; 4 msgs
gradient_def typechecked in 4.257s: 56 TCCs, 0 proved, 18 subsumed, 38 unproved

 In declaration diff_cont:
  added conversion restrict[VectorN(n), (D), VectorN(m)]
             
  to f, converting
     [VectorN(n) -> VectorN(m)]
  to [(D) -> VectorN(m)]

convergence_vec2vec typechecked in 7.711s: 89 TCCs, 0 proved, 23 subsumed, 66 unproved; 1 conversion
chain_rule_multi typechecked in 14.28s: 81 TCCs, 0 proved, 50 subsumed, 31 unproved
lift_real_fun_def typechecked in 15.959s: 25 TCCs, 0 proved, 13 subsumed, 12 unproved

 In declaration e2v_der_p_in_map:
  added conversion extend[nat, below(length[MapExpr](ode)), bool, FALSE]
             
  to index_of(ode, i), converting
     [below(length(ode)) -> bool]
  to [nat -> bool]


 LET/WHERE variable k at line 335, col 5 is given type
  (extend[nat, below(length[MapExpr](ode)), bool, FALSE](index_of(ode, i))) from its value expression.


 LET/WHERE variable fs at line 336, col 5 is given type
  (solution_odes_u?(D, ode, envi)) from its value expression.


 In declaration e2v_der_p_in_map:
  added conversion extend[nat, below(length[MapExpr](ode)), bool, FALSE]
             
  to index_of(ode, i), converting
     [below(length(ode)) -> bool]
  to [nat -> bool]


 In declaration e2v_der_p_in_map:
  added conversion restrict[real, (D), real]
             
  to fs(k), converting
     [real -> real]
  to [(D) -> real]


 In declaration e2v_der_p_in_map_ode:
  added conversion extend[nat, below(length[MapExpr](ode)), bool, FALSE]
             
  to index_of(ode, i), converting
     [below(length(ode)) -> bool]
  to [nat -> bool]


 LET/WHERE variable k at line 344, col 5 is given type
  (extend[nat, below(length[MapExpr](ode)), bool, FALSE](index_of(ode, i))) from its value expression.


 LET/WHERE variable re at line 345, col 5 is given type
  RealExpr from its value expression.


 LET/WHERE variable fs at line 346, col 5 is given type
  (solution_odes_u?(D, ode, envi)) from its value expression.


 In declaration e2v_der_p_in_map_ode:
  added conversion extend[nat, below(length[MapExpr](ode)), bool, FALSE]
             
  to index_of(ode, i), converting
     [below(length(ode)) -> bool]
  to [nat -> bool]


 LET/WHERE variable A at line 427, col 6 is given type
  {gg: VectorN(1 + max_var(ode)) |
     convergence_zero?[1 + max_var(ode)]
         (NQ[1 + max_var(ode)]
              (projv(max_var(ode), P),
               env_2_vec(max_var(ode), env_sol(D, envi, ode)(t))),
          NQ[1 + max_var(ode)]
              (vec_re(max_var(ode), env_sol(D, envi, ode)(t), R), gg,
               env_2_vec(max_var(ode), env_sol(D, envi, ode)(t))),
          zero_vec(1 + max_var(ode)))} from its value expression.


 LET/WHERE variable B at line 430, col 6 is given type
  VectorN(rows(der_f[1]
                   (1 + max_var(ode), lift_rd(D), (: t :))
                   (liftl(1 + max_var(ode), D,
                          (LAMBDA (tt: (D)):
                             env_2_vec(max_var(ode),
                                       env_sol(D, envi, ode)(tt))))))) from its value expression.


 LET/WHERE variable sumf at line 434, col 7 is given type
  [nat -> real] from its value expression.

chain_rule_re typechecked in 29.836s: 161 TCCs, 0 proved, 70 subsumed, 91 unproved; 5 conversions; 8 msgs
Parsing diff_re_props
diff_re_props parsed in 0.00 seconds
diff_re_props is already parsed
Typechecking diff_re_props
diff_re_props typechecked in 0.84s: 11 TCCs, 0 proved, 4 subsumed, 7 unproved
Parsing continuity_re_def
continuity_re_def parsed in 0.00 seconds
continuity_re_def is already parsed
Typechecking continuity_re_def
continuity_re_def typechecked in 1.106s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing continuity_props
continuity_props parsed in 0.00 seconds
continuity_props is already parsed
Typechecking continuity_props

 In declaration f_sol_continuous:
  added conversion restrict[real, (D), real]
             
  to fs(i), converting
     [real -> real]
  to [(D) -> real]


 In declaration min_delt:
  added conversion restrict[real, (D), real]
             
  to fs(i), converting
     [real -> real]
  to [(D) -> real]


 In declaration min_delt:
  added conversion restrict[real, (D), real]
             
  to fs(0), converting
     [real -> real]
  to [(D) -> real]


 In declaration min_delt:
  added conversion restrict[real, (D), real]
             
  to fs(0), converting
     [real -> real]
  to [(D) -> real]


 In declaration min_delt:
  added conversion restrict[real, (D), real]
             
  to fs(0), converting
     [real -> real]
  to [(D) -> real]

continuity_props typechecked in 1.471s: 11 TCCs, 0 proved, 0 subsumed, 11 unproved; 5 conversions
Parsing continuity_re_props
continuity_re_props parsed in 0.00 seconds
continuity_re_props is already parsed
Typechecking continuity_re_props
continuity_re_props typechecked in 0.48s: No TCCs generated
Parsing fresh_props
fresh_props parsed in 0.00 seconds
fresh_props is already parsed
Typechecking fresh_props
Added 3 proofs from theory fresh_props to orphaned-proofs.prf
fresh_props typechecked in 1.247s: No TCCs generated
Parsing dynamic_logic
dynamic_logic parsed in 0.03 seconds
dynamic_logic is already parsed
Typechecking dynamic_logic
Parsing more_derivative_props
more_derivative_props parsed in 0.00 seconds
more_derivative_props is already parsed
Typechecking more_derivative_props
Parsing top
top parsed in 0.00 seconds
top is already parsed
Typechecking top
Parsing top_limits
top_limits parsed in 0.00 seconds
top_limits is already parsed
Typechecking top_limits
Parsing infinite_limits
infinite_limits parsed in 0.00 seconds
infinite_limits is already parsed
Typechecking infinite_limits
infinite_limits typechecked in 0.11s: No TCCs generated
top_limits typechecked in 0.21s: No TCCs generated
Parsing top_continuity
top_continuity parsed in 0.00 seconds
top_continuity is already parsed
Typechecking top_continuity
Parsing restriction_continuous
restriction_continuous parsed in 0.00 seconds
restriction_continuous is already parsed
Typechecking restriction_continuous

 In declaration restrict_continuous:
  added conversion restrict[real, T1, real]
             
  to f, converting
     [real -> real]
  to [T1 -> real]

restriction_continuous typechecked in 0.01s: No TCCs generated; 1 conversion
Parsing restriction_cont_fun
restriction_cont_fun parsed in 0.00 seconds
restriction_cont_fun is already parsed
Typechecking restriction_cont_fun

 In declaration restrict_cont_fun:
  added conversion restrict2
             
  to f, converting
     [T2 -> real]
  to [T1 -> real]

restriction_cont_fun typechecked in 0.01s: 1 TCC, 0 proved, 0 subsumed, 1 unproved; 1 conversion
Parsing restriction_continuous2
restriction_continuous2 parsed in 0.00 seconds
restriction_continuous2 is already parsed
Typechecking restriction_continuous2

 In declaration restrict_continuous2:
  added conversion restrict2
             
  to f, converting
     [T2 -> real]
  to [T1 -> real]

restriction_continuous2 typechecked in 0.01s: 1 TCC, 0 proved, 0 subsumed, 1 unproved; 1 conversion
Parsing interm_value_thm
interm_value_thm parsed in 0.00 seconds
interm_value_thm is already parsed
Typechecking interm_value_thm

 In declaration cont_intv1:
  added conversion restrict[real, closed_interval[real](a, b), real]
             
  to f, converting
     [real -> real]
  to [closed_interval[real](a, b) -> real]


 In declaration interm_val1:
  added conversion restrict[real, closed_interval[real](a, b), real]
             
  to f, converting
     [real -> real]
  to [closed_interval[real](a, b) -> real]


 In declaration interm_val2:
  added conversion restrict[real, closed_interval[real](a, b), real]
             
  to f, converting
     [real -> real]
  to [closed_interval[real](a, b) -> real]


 In declaration interm_val3:
  added conversion restrict[real, closed_interval[real](a, b), real]
             
  to f, converting
     [real -> real]
  to [closed_interval[real](a, b) -> real]


 In declaration interm_val4:
  added conversion restrict[real, closed_interval[real](a, b), real]
             
  to f, converting
     [real -> real]
  to [closed_interval[real](a, b) -> real]

Parsing connected_set
connected_set parsed in 0.00 seconds
connected_set is already parsed
Typechecking connected_set
connected_set typechecked in 0.01s: 8 TCCs, 0 proved, 0 subsumed, 8 unproved
interm_value_thm typechecked in 0.30s: 8 TCCs, 0 proved, 4 subsumed, 4 unproved; 5 conversions
Parsing continuous_linear
continuous_linear parsed in 0.00 seconds
continuous_linear is already parsed
Typechecking continuous_linear
Parsing linear_functions
linear_functions parsed in 0.00 seconds
linear_functions is already parsed
Typechecking linear_functions
linear_functions typechecked in 0.01s: No TCCs generated

 LET/WHERE variable f at line 48, col 16 is given type
  [T -> real] from its value expression.


 In declaration top:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration top:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration bot:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration bot:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration top_lem:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration top_least:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration bot_lem:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration bot_least:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration cont_upto_lub:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration cont_downto_glb:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration on_linear_top?:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]


 In declaration on_linear_bottom?:
  added conversion extend[real, T, bool, FALSE]
             
  to fullset[T], converting
     [T -> bool]
  to [real -> bool]

continuous_linear typechecked in 0.16s: 15 TCCs, 0 proved, 11 subsumed, 4 unproved; 12 conversions; 1 msg
Parsing cont_if_fun
cont_if_fun parsed in 0.00 seconds
cont_if_fun is already parsed
Typechecking cont_if_fun
cont_if_fun typechecked in 0.06s: No TCCs generated
Parsing continuous_lambda
continuous_lambda parsed in 0.00 seconds
continuous_lambda is already parsed
Typechecking continuous_lambda
Parsing min_max
min_max parsed in 0.00 seconds
min_max is already parsed
Typechecking min_max
min_max typechecked in 0.36s: 8 TCCs, 0 proved, 2 subsumed, 6 unproved
continuous_lambda typechecked in 0.69s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
Parsing real_fun_continuity_equiv
real_fun_continuity_equiv parsed in 0.00 seconds
real_fun_continuity_equiv is already parsed
Typechecking real_fun_continuity_equiv
Parsing real_metric_space
real_metric_space parsed in 0.00 seconds
real_metric_space is already parsed
Typechecking real_metric_space
Parsing metric_spaces_def
metric_spaces_def parsed in 0.00 seconds
metric_spaces_def is already parsed
Typechecking metric_spaces_def
metric_spaces_def typechecked in 0.01s: No TCCs generated
Parsing open_sets
open_sets parsed in 0.00 seconds
open_sets is already parsed
Typechecking open_sets
open_sets typechecked in 0.02s: No TCCs generated
Parsing compactness
compactness parsed in 0.00 seconds
compactness is already parsed
Typechecking compactness
Parsing metric_spaces
metric_spaces parsed in 0.00 seconds
metric_spaces is already parsed
Typechecking metric_spaces
Parsing prelude_sets_aux
prelude_sets_aux parsed in 0.00 seconds
prelude_sets_aux is already parsed
Typechecking prelude_sets_aux
prelude_sets_aux typechecked in 0.04s: No TCCs generated

 In declaration Complement_open:
  added conversion extend[setof[T], open_set, bool, FALSE]
             
  to XS, converting
     [open_set -> bool]
  to [setof[T] -> bool]


 In declaration Complement_closed:
  added conversion extend[setof[T], closed_set, bool, FALSE]
             
  to XS, converting
     [closed_set -> bool]
  to [setof[T] -> bool]


 In declaration open_Union_open:
  added conversion extend[setof[T], open_set, bool, FALSE]
             
  to XS, converting
     [open_set -> bool]
  to [setof[T] -> bool]


 In declaration open_Intersection_open:
  added conversion extend[setof[T], open_set, bool, FALSE]
             
  to FS, converting
     [open_set -> bool]
  to [setof[T] -> bool]


 In declaration closed_Union_closed:
  added conversion extend[setof[T], closed_set, bool, FALSE]
             
  to FS, converting
     [closed_set -> bool]
  to [setof[T] -> bool]


 In declaration closed_Intersection_closed:
  added conversion extend[setof[T], closed_set, bool, FALSE]
             
  to XS, converting
     [closed_set -> bool]
  to [setof[T] -> bool]

metric_spaces typechecked in 0.11s: No TCCs generated; 6 conversions; 2 warnings

 In declaration nBalls:
  added conversion restrict[set[T], (open?[T, d]), boolean]
             
  to {s: set[T] | EXISTS (n: posnat): s = ball(p, n)}, converting
     [set[T] -> boolean]
  to [(open?) -> boolean]


 In declaration nBalls_open_cover:
  added conversion extend[set[T], (open?[T, d]), bool, FALSE]
             
  to nBalls(p), converting
     [(open?) -> bool]
  to [set[T] -> bool]


 LET/WHERE variable N at line 102, col 17 is given type
  N: nat from its value expression.


 LET/WHERE variable seq at line 102, col 19 is given type
  seq: [below[N] -> (H)] from its value expression.


 LET/WHERE variable a at line 103, col 42 is given type
  T from its value expression.


 LET/WHERE variable r at line 103, col 44 is given type
  posreal from its value expression.


 LET/WHERE variable N at line 109, col 19 is given type
  N: nat from its value expression.


 LET/WHERE variable seq at line 109, col 21 is given type
  seq: [below[N] -> (H)] from its value expression.


 In declaration IMPORTING finite_sets@finite_sets_minmax[nat, <=]:
  added conversion restrict[[real, real], [nat, nat], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[nat, nat] -> bool]

compactness typechecked in 0.28s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved; 3 conversions; 6 msgs

 LET/WHERE variable W at line 60, col 35 is given type
  [real, real] from its value expression.

real_metric_space typechecked in 0.61s: 19 TCCs, 0 proved, 12 subsumed, 7 unproved; 1 msg
Parsing continuity_ms_def
continuity_ms_def parsed in 0.00 seconds
continuity_ms_def is already parsed
Typechecking continuity_ms_def
continuity_ms_def typechecked in 0.03s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
real_fun_continuity_equiv typechecked in 0.75s: 2 TCCs, 0 proved, 1 subsumed, 1 unproved
Parsing weierstrass_approximation
weierstrass_approximation parsed in 0.00 seconds
weierstrass_approximation is already parsed
Typechecking weierstrass_approximation
Parsing bernstein_polynomials
bernstein_polynomials parsed in 0.02 seconds
bernstein_polynomials is already parsed
Typechecking bernstein_polynomials
Parsing binomial_identities
binomial_identities parsed in 0.03 seconds
binomial_identities is already parsed
Typechecking binomial_identities
binomial_identities typechecked in 0.97s: 85 TCCs, 0 proved, 25 subsumed, 60 unproved

 LET/WHERE variable m at line 57, col 6 is given type
  nat from its value expression.


 LET/WHERE variable bseq at line 58, col 6 is given type
  [upto(b`index) -> real] from its value expression.


 LET/WHERE variable msp at line 215, col 8 is given type
  {k: nat | k <= s AND k <= p} from its value expression.


 LET/WHERE variable bsl at line 256, col 9 is given type
  Bernstein_Polynomial from its value expression.


 LET/WHERE variable bsr at line 256, col 32 is given type
  Bernstein_Polynomial from its value expression.


 LET/WHERE variable bsl at line 262, col 9 is given type
  Bernstein_Polynomial from its value expression.


 LET/WHERE variable bsr at line 262, col 32 is given type
  Bernstein_Polynomial from its value expression.


 LET/WHERE variable bsl at line 268, col 9 is given type
  Bernstein_Polynomial from its value expression.


 LET/WHERE variable bsr at line 268, col 32 is given type
  Bernstein_Polynomial from its value expression.


 LET/WHERE variable bsl at line 274, col 9 is given type
  Bernstein_Polynomial from its value expression.


 LET/WHERE variable bsr at line 274, col 32 is given type
  Bernstein_Polynomial from its value expression.


 LET/WHERE variable y at line 285, col 8 is given type
  real from its value expression.


 LET/WHERE variable x at line 286, col 8 is given type
  real from its value expression.


 LET/WHERE variable y at line 292, col 7 is given type
  real from its value expression.


 LET/WHERE variable x at line 293, col 7 is given type
  real from its value expression.


 LET/WHERE variable NN at line 332, col 8 is given type
  posint from its value expression.


 LET/WHERE variable minest at line 346, col 8 is given type
  real from its value expression.


 LET/WHERE variable current_poly_min at line 361, col 8 is given type
  real from its value expression.


 LET/WHERE variable b at line 395, col 8 is given type
  Bernstein_Polynomial from its value expression.

bernstein_polynomials typechecked in 1.975s: 103 TCCs, 0 proved, 32 subsumed, 71 unproved; 19 msgs
Parsing real_fun_on_compact_sets
real_fun_on_compact_sets parsed in 0.00 seconds
real_fun_on_compact_sets is already parsed
Typechecking real_fun_on_compact_sets
real_fun_on_compact_sets typechecked in 0.07s: 3 TCCs, 0 proved, 1 subsumed, 2 unproved
Parsing uniform_continuity
uniform_continuity parsed in 0.00 seconds
uniform_continuity is already parsed
Typechecking uniform_continuity
Parsing continuity_ms
continuity_ms parsed in 0.00 seconds
continuity_ms is already parsed
Typechecking continuity_ms

 In declaration image_inverse_image:
  added conversion extend[T1, (S), bool, FALSE]
             
  to inverse_image(f, Y), converting
     [(S) -> bool]
  to [T1 -> bool]


 In declaration image_inverse_image:
  added conversion restrict[T1, (S), bool]
             
  to X, converting
     [T1 -> bool]
  to [(S) -> bool]


 In declaration image_inverse_image:
  added conversion restrict[T2, (T), bool]
             
  to Y, converting
     [T2 -> bool]
  to [(T) -> bool]


 In declaration inverse_image_image:
  added conversion restrict[T1, (S), bool]
             
  to X, converting
     [T1 -> bool]
  to [(S) -> bool]


 In declaration inverse_image_image:
  added conversion extend[T2, (T), bool, FALSE]
             
  to image(f, restrict[T1, (S), bool](X)), converting
     [(T) -> bool]
  to [T2 -> bool]


 In declaration inverse_image_image:
  added conversion extend[T1, (S), bool, FALSE]
             
  to inverse_image(f, Y), converting
     [(S) -> bool]
  to [T1 -> bool]

continuity_ms typechecked in 0.08s: 4 TCCs, 0 proved, 2 subsumed, 2 unproved; 6 conversions

 LET/WHERE variable a at line 58, col 29 is given type
  a: S from its value expression.


 LET/WHERE variable r at line 58, col 31 is given type
  r: posreal from its value expression.


 LET/WHERE variable B at line 64, col 22 is given type
  set[S] from its value expression.


 LET/WHERE variable N at line 92, col 19 is given type
  N: nat from its value expression.


 LET/WHERE variable seq at line 92, col 21 is given type
  seq: [below[N] -> (Hset(A, epsilon, f))] from its value expression.


 LET/WHERE variable a at line 94, col 26 is given type
  S from its value expression.


 LET/WHERE variable R at line 94, col 28 is given type
  posreal from its value expression.


 LET/WHERE variable N at line 99, col 27 is given type
  N: nat from its value expression.


 LET/WHERE variable seq at line 99, col 29 is given type
  seq: [below[N] -> (Hset(A, epsilon, f))] from its value expression.

Parsing finite_sets_aux
finite_sets_aux parsed in 0.00 seconds
finite_sets_aux is already parsed
Typechecking finite_sets_aux
finite_sets_aux typechecked in 0.00s: No TCCs generated

 In declaration IMPORTING finite_sets@finite_sets_minmax[posreal, <=]:
  added conversion restrict[[real, real], [posreal, posreal], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[posreal, posreal] -> bool]

uniform_continuity typechecked in 0.49s: 5 TCCs, 0 proved, 1 subsumed, 4 unproved; 1 conversion; 9 msgs
weierstrass_approximation typechecked in 3.491s: 5 TCCs, 0 proved, 2 subsumed, 3 unproved
Parsing piecewise_continuous
piecewise_continuous parsed in 0.00 seconds
piecewise_continuous is already parsed
Typechecking piecewise_continuous
piecewise_continuous typechecked in 0.26s: 19 TCCs, 0 proved, 3 subsumed, 16 unproved
top_continuity typechecked in 6.26s: No TCCs generated
Parsing top_metric_spaces
top_metric_spaces parsed in 0.00 seconds
top_metric_spaces is already parsed
Typechecking top_metric_spaces
Parsing cross_metric_spaces
cross_metric_spaces parsed in 0.00 seconds
cross_metric_spaces is already parsed
Typechecking cross_metric_spaces
cross_metric_spaces typechecked in 0.67s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
Parsing cross_metric_cont
cross_metric_cont parsed in 0.00 seconds
cross_metric_cont is already parsed
Typechecking cross_metric_cont

 In declaration product_cont_product_subset:
  added conversion extend[[T1, T2], [(X), (Y)], bool, FALSE]
             
  to fullset[[(X), (Y)]], converting
     [[(X), (Y)] -> bool]
  to [[T1, T2] -> bool]

cross_metric_cont typechecked in 0.17s: 6 TCCs, 0 proved, 2 subsumed, 4 unproved; 1 conversion
Parsing cross_metric_uniform_continuity
cross_metric_uniform_continuity parsed in 0.00 seconds
cross_metric_uniform_continuity is already parsed
Typechecking cross_metric_uniform_continuity

 In declaration multiary_Heine:
  added conversion extend[[T1, T2], [(X), (Y)], bool, FALSE]
             
  to fullset[[(X), (Y)]], converting
     [[(X), (Y)] -> bool]
  to [[T1, T2] -> bool]


 In declaration multi_Heine_Corollary1:
  added conversion extend[[T1, T2], [(X), (Y)], bool, FALSE]
             
  to fullset[[(X), (Y)]], converting
     [[(X), (Y)] -> bool]
  to [[T1, T2] -> bool]

cross_metric_uniform_continuity typechecked in 0.19s: 7 TCCs, 0 proved, 3 subsumed, 4 unproved; 2 conversions
Parsing cross_metric_real_fun
cross_metric_real_fun parsed in 0.00 seconds
cross_metric_real_fun is already parsed
Typechecking cross_metric_real_fun

 In declaration curried_min_exists:
  added conversion extend[[T1, T2], [(X), (Y)], bool, FALSE]
             
  to fullset[[(X), (Y)]], converting
     [[(X), (Y)] -> bool]
  to [[T1, T2] -> bool]


 In declaration curried_min_is_cont:
  added conversion extend[[T1, T2], [(X), (Y)], bool, FALSE]
             
  to fullset[[(X), (Y)]], converting
     [[(X), (Y)] -> bool]
  to [[T1, T2] -> bool]

cross_metric_real_fun typechecked in 0.29s: 9 TCCs, 0 proved, 3 subsumed, 4 unproved, 2 trivial; 2 conversions
Parsing continuity_of_max_min
continuity_of_max_min parsed in 0.00 seconds
continuity_of_max_min is already parsed
Typechecking continuity_of_max_min
continuity_of_max_min typechecked in 0.07s: 3 TCCs, 0 proved, 1 subsumed, 2 unproved
Parsing ms_composition_cont
ms_composition_cont parsed in 0.00 seconds
ms_composition_cont is already parsed
Typechecking ms_composition_cont
ms_composition_cont typechecked in 0.08s: 6 TCCs, 0 proved, 3 subsumed, 3 unproved
Parsing metric_space_real_fun
metric_space_real_fun parsed in 0.00 seconds
metric_space_real_fun is already parsed
Typechecking metric_space_real_fun
metric_space_real_fun typechecked in 0.06s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
Parsing inverse_fun_ms_continuous
inverse_fun_ms_continuous parsed in 0.00 seconds
inverse_fun_ms_continuous is already parsed
Typechecking inverse_fun_ms_continuous
inverse_fun_ms_continuous typechecked in 0.05s: 4 TCCs, 0 proved, 2 subsumed, 2 unproved
Parsing convex_function_props
convex_function_props parsed in 0.00 seconds
convex_function_props is already parsed
Typechecking convex_function_props
Parsing convex_functions
convex_functions parsed in 0.00 seconds
convex_functions is already parsed
Typechecking convex_functions

 LET/WHERE variable maxfun at line 154, col 37 is given type
  [t: real ->
     {p: real | p >= quadratic(a, b, c)(t) AND p >= abs(x + t * y) - H}] from its value expression.


 LET/WHERE variable maxfun at line 158, col 39 is given type
  [t: real ->
     {p: real | p >= quadratic(a, b, c)(t) AND p >= abs(x + t * y) - H}] from its value expression.


 LET/WHERE variable maxfun at line 165, col 38 is given type
  [t: real ->
     {p: real | p >= quadratic(a, b, c)(t) AND p >= abs(x + t * y) - H}] from its value expression.

convex_functions typechecked in 0.42s: 6 TCCs, 0 proved, 2 subsumed, 4 unproved; 3 msgs
convex_function_props typechecked in 0.82s: 8 TCCs, 0 proved, 4 subsumed, 4 unproved
top_metric_spaces typechecked in 2.82s: No TCCs generated
Parsing top_derivative
top_derivative parsed in 0.00 seconds
top_derivative is already parsed
Typechecking top_derivative
Parsing deriv_sign
deriv_sign parsed in 0.00 seconds
deriv_sign is already parsed
Typechecking deriv_sign

 In declaration sign_derivable:
  added conversion restrict[real, nzreal, Sign]
             
  to sign, converting
     [real -> Sign]
  to [nzreal -> Sign]


 In declaration sign_derivable_fun:
  added conversion restrict[real, nzreal, Sign]
             
  to sign, converting
     [real -> Sign]
  to [nzreal -> Sign]


 In declaration deriv_sign:
  added conversion restrict[real, nzreal, Sign]
             
  to sign, converting
     [real -> Sign]
  to [nzreal -> Sign]

deriv_sign typechecked in 0.09s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved; 3 conversions
Parsing derivatives_shift
derivatives_shift parsed in 0.00 seconds
derivatives_shift is already parsed
Typechecking derivatives_shift
derivatives_shift typechecked in 0.10s: 22 TCCs, 0 proved, 10 subsumed, 12 unproved
top_derivative typechecked in 0.53s: No TCCs generated
Parsing top_riesz_representation
top_riesz_representation parsed in 0.00 seconds
top_riesz_representation is already parsed
Typechecking top_riesz_representation
Parsing bounded_variation
bounded_variation parsed in 0.00 seconds
bounded_variation is already parsed
Typechecking bounded_variation
Parsing rs_partition
rs_partition parsed in 0.01 seconds
rs_partition is already parsed
Typechecking rs_partition
Parsing sort_fseq
sort_fseq parsed in 0.00 seconds
sort_fseq is already parsed
Typechecking sort_fseq
Parsing fseqs
fseqs parsed in 0.00 seconds
fseqs is already parsed
Typechecking fseqs
Parsing fsq
fsq parsed in 0.00 seconds
fsq is already parsed
Typechecking fsq
fsq typechecked in 0.00s: No TCCs generated

 LET/WHERE variable l1 at line 100, col 9 is given type
  nat from its value expression.


 LET/WHERE variable l2 at line 100, col 26 is given type
  nat from its value expression.


 LET/WHERE variable m at line 132, col 9 is given type
  nat from its value expression.


 LET/WHERE variable n at line 132, col 12 is given type
  nat from its value expression.


 LET/WHERE variable len at line 135, col 17 is given type
  nat from its value expression.

fseqs typechecked in 0.08s: 15 TCCs, 0 proved, 0 subsumed, 15 unproved; 1 warning; 5 msgs
Parsing permutations_fseq
permutations_fseq parsed in 0.00 seconds
permutations_fseq is already parsed
Typechecking permutations_fseq
permutations_fseq typechecked in 0.01s: No TCCs generated

 In declaration sort_fseq_lt:
  added conversion cnvfsq[T]
             
  to sort(s), converting
     fsq[T]
  to [nat -> T]


 In declaration sort_fseq_lt:
  added conversion cnvfsq[T]
             
  to sort(s), converting
     fsq[T]
  to [nat -> T]


 In declaration sort_fseq_lt:
  added conversion cnvfsq[T]
             
  to sort(s), converting
     fsq[T]
  to [nat -> T]


 In declaration sort_fseq_lt:
  added conversion cnvfsq[T]
             
  to sort(s), converting
     fsq[T]
  to [nat -> T]


 LET/WHERE variable sss at line 85, col 37 is given type
  {ss: fseq |
     strictly_increasing?(ss) AND FORALL (x: T): member(x, s) IFF member(x, ss)} from its value expression.


 LET/WHERE variable sss at line 89, col 14 is given type
  {ss: fseq |
     strictly_increasing?(ss) AND FORALL (x: T): member(x, s) IFF member(x, ss)} from its value expression.


 LET/WHERE variable sss at line 94, col 39 is given type
  {ss: fseq |
     strictly_increasing?(ss) AND FORALL (x: T): member(x, s) IFF member(x, ss)} from its value expression.


 LET/WHERE variable sq at line 100, col 10 is given type
  {sq: [below(strictly_sort(s)`length) -> below(s`length)] |
     (increasing?(s) AND strictly_sort(s)`length >= 1 IMPLIES
       sq(strictly_sort(s)`length - 1) = s`length - 1)
      AND
      FORALL (ii: below(strictly_sort(s)`length)):
        (strictly_sort(s)`seq(ii) = s`seq(sq(ii)) AND
          (increasing?(s) AND ii < strictly_sort(s)`length - 1 IMPLIES
            strictly_sort(s)`seq(1 + ii) = s`seq(1 + sq(ii))))} from its value expression.

sort_fseq typechecked in 0.35s: 12 TCCs, 0 proved, 2 subsumed, 10 unproved; 4 conversions; 4 msgs

 In declaration IMPORTING structures@sort_fseq[T, <=]:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]

Parsing fseqs_ops
fseqs_ops parsed in 0.00 seconds
fseqs_ops is already parsed
Typechecking fseqs_ops

 In declaration delete:
  added conversion cnvfsq[T]
             
  to nefs, converting
     fsq[T]
  to [nat -> T]


 In declaration delete:
  added conversion cnvfsq[T]
             
  to nefs, converting
     fsq[T]
  to [nat -> T]


 In declaration insert:
  added conversion cnvfsq[T]
             
  to fs, converting
     fsq[T]
  to [nat -> T]


 In declaration insert:
  added conversion cnvfsq[T]
             
  to fs, converting
     fsq[T]
  to [nat -> T]


 In declaration every:
  added conversion cnvfsq[T]
             
  to fs, converting
     fsq[T]
  to [nat -> T]


 In declaration every:
  added conversion cnvfsq[T]
             
  to fs, converting
     fsq[T]
  to [nat -> T]


 In declaration some:
  added conversion cnvfsq[T]
             
  to fs, converting
     fsq[T]
  to [nat -> T]


 In declaration some:
  added conversion cnvfsq[T]
             
  to fs, converting
     fsq[T]
  to [nat -> T]

fseqs_ops typechecked in 0.04s: 7 TCCs, 0 proved, 1 subsumed, 6 unproved; 8 conversions

 LET/WHERE variable N at line 40, col 16 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 40, col 31 is given type
  barray[T](fs`length) from its value expression.


 LET/WHERE variable xx at line 50, col 17 is given type
  barray[T](P`length) from its value expression.


 LET/WHERE variable N at line 50, col 29 is given type
  nat from its value expression.


 In declaration width_lem:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 In declaration width_lem:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 In declaration width_lem_exists:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 In declaration width_lem_exists:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 LET/WHERE variable xx at line 96, col 31 is given type
  barray[T](P`length) from its value expression.


 LET/WHERE variable N at line 96, col 43 is given type
  nat from its value expression.


 LET/WHERE variable N at line 124, col 30 is given type
  int from its value expression.


 LET/WHERE variable EP at line 125, col 30 is given type
  partition(a, b) from its value expression.


 LET/WHERE variable Pac at line 138, col 10 is given type
  partition(a, c) from its value expression.


 LET/WHERE variable PQ at line 186, col 14 is given type
  {PQ: partition(a, b) |
     (FORALL (x: T): member(x, PQ) IFF (member(x, P) OR member(x, Q))) AND
      strictly_increasing?(PQ)} from its value expression.


 LET/WHERE variable pum at line 187, col 8 is given type
  {pm: [below(P`length) -> below(partition_union(a, b)(P, Q)`length)] |
     FORALL (ii: below(P`length)):
       P`seq(ii) = partition_union(a, b)(P, Q)`seq(pm(ii))} from its value expression.


 LET/WHERE variable puminv at line 188, col 4 is given type
  {pm: [below(partition_union(a, b)(P, Q)`length) -> below(P`length)] |
     FORALL (jj: below(partition_union(a, b)(P, Q)`length)):
       P`seq(pm(jj)) <= partition_union(a, b)(P, Q)`seq(jj) AND
        (pm(jj) < P`length - 1 IMPLIES
          partition_union(a, b)(P, Q)`seq(jj) < P`seq(1 + pm(jj)))} from its value expression.


 LET/WHERE variable SSP at line 197, col 13 is given type
  {PQ: partition(a, b) |
     (FORALL (x: T): member(x, PQ) IFF (member(x, P) OR member(x, P))) AND
      strictly_increasing?(PQ)} from its value expression.


 LET/WHERE variable sig at line 198, col 10 is given type
  {pm: [below(partition_union(a, b)(P, P)`length) -> below(P`length)] |
     FORALL (jj: below(partition_union(a, b)(P, P)`length)):
       P`seq(pm(jj)) <= partition_union(a, b)(P, P)`seq(jj) AND
        (pm(jj) < P`length - 1 IMPLIES
          partition_union(a, b)(P, P)`seq(jj) < P`seq(1 + pm(jj)))} from its value expression.

rs_partition typechecked in 3.032s: 26 TCCs, 0 proved, 1 subsumed, 25 unproved; 5 conversions; 14 msgs

 In declaration monotonic_BV:
  added conversion restrict[T, (LAMBDA (x: T): a <= x AND x <= bb), real]
             
  to f, converting
     [T -> real]
  to [(LAMBDA (x: T): a <= x AND x <= bb) -> real]


 LET/WHERE variable CI at line 81, col 14 is given type
  [T -> bool] from its value expression.


 In declaration BV_decomposition:
  added conversion restrict[T, (CI), real]
             
  to g, converting
     [T -> real]
  to [(CI) -> real]


 In declaration BV_decomposition:
  added conversion restrict[T, (CI), real]
             
  to h, converting
     [T -> real]
  to [(CI) -> real]

bounded_variation typechecked in 3.524s: 12 TCCs, 0 proved, 0 subsumed, 12 unproved; 3 conversions; 1 msg
Parsing riesz_bounded_functionals
riesz_bounded_functionals parsed in 0.00 seconds
riesz_bounded_functionals is already parsed
Typechecking riesz_bounded_functionals
Parsing riesz_function_sets
riesz_function_sets parsed in 0.00 seconds
riesz_function_sets is already parsed
Typechecking riesz_function_sets
Parsing riesz_interval_funs
riesz_interval_funs parsed in 0.00 seconds
riesz_interval_funs is already parsed
Typechecking riesz_interval_funs

 In declaration IMPORTING metric_space_real_fun[INTab, real_dist]:
  added conversion restrict[[real, real], [INTab, INTab], nnreal]
             
  to real_dist, converting
     [[real, real] -> nnreal]
  to [[INTab, INTab] -> nnreal]


 In declaration bounded_funs_metric_space:
  added conversion restrict[[INTab -> real], (bounded_on_int?), bool]
             
  to bounded_on_int?, converting
     [[INTab -> real] -> bool]
  to [(bounded_on_int?) -> bool]


 In declaration continuous_on_int?:
  added conversion restrict[real, INTab, bool]
             
  to Intab, converting
     [real -> bool]
  to [INTab -> bool]

riesz_interval_funs typechecked in 0.20s: 9 TCCs, 0 proved, 0 subsumed, 9 unproved; 3 conversions
riesz_function_sets typechecked in 0.25s: No TCCs generated

 In declaration funs_subspace:
  added conversion extend[[INTab[a, b] -> real], Funs, bool, FALSE]
             
  to fullset[Funs], converting
     [Funs -> bool]
  to [[INTab[a, b] -> real] -> bool]

Parsing riesz_linear_functionals
riesz_linear_functionals parsed in 0.02 seconds
riesz_linear_functionals is already parsed
Typechecking riesz_linear_functionals
riesz_linear_functionals typechecked in 0.06s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
riesz_bounded_functionals typechecked in 0.58s: 8 TCCs, 0 proved, 3 subsumed, 5 unproved; 1 conversion
Parsing riesz_hahn_banach
riesz_hahn_banach parsed in 0.00 seconds
riesz_hahn_banach is already parsed
Typechecking riesz_hahn_banach
riesz_hahn_banach typechecked in 0.73s: 6 TCCs, 0 proved, 0 subsumed, 6 unproved
Parsing riesz_representation
riesz_representation parsed in 0.00 seconds
riesz_representation is already parsed
Typechecking riesz_representation
Parsing rs_integral_cont
rs_integral_cont parsed in 0.00 seconds
rs_integral_cont is already parsed
Typechecking rs_integral_cont
Parsing rs_integral_prep
rs_integral_prep parsed in 0.01 seconds
rs_integral_prep is already parsed
Typechecking rs_integral_prep
Parsing rs_integral_def
rs_integral_def parsed in 0.01 seconds
rs_integral_def is already parsed
Typechecking rs_integral_def

 In declaration xis_lem:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 In declaration xis_lem:
  added conversion cnvfsq[T]
             
  to xis, converting
     fsq[T]
  to [nat -> T]


 In declaration xis_lem:
  added conversion cnvfsq[T]
             
  to xis, converting
     fsq[T]
  to [nat -> T]


 In declaration xis_lem:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 In declaration xis_bounded:
  added conversion cnvfsq[T]
             
  to xis, converting
     fsq[T]
  to [nat -> T]


 In declaration xis_bounded:
  added conversion cnvfsq[T]
             
  to xis, converting
     fsq[T]
  to [nat -> T]


 LET/WHERE variable N at line 51, col 22 is given type
  int from its value expression.


 In declaration Rie_sum:
  added conversion cnvfsq[T]
             
  to xis, converting
     fsq[T]
  to [nat -> T]


 In declaration Rie_sec:
  added conversion cnvfsq[T]
             
  to xis, converting
     fsq[T]
  to [nat -> T]


 LET/WHERE variable N at line 63, col 22 is given type
  int from its value expression.


 LET/WHERE variable N at line 73, col 37 is given type
  int from its value expression.


 In declaration pick_one:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 In declaration pick_one:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 In declaration pick_one:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 In declaration pick_one:
  added conversion cnvfsq[T]
             
  to P, converting
     fsq[T]
  to [nat -> T]


 LET/WHERE variable PQ at line 151, col 65 is given type
  {PQ: partition[T](a, b) |
     (FORALL (x: T): member(x, PQ) IFF (member(x, P) OR member(x, Q))) AND
      strictly_increasing?(PQ)} from its value expression.


 LET/WHERE variable PQ at line 158, col 4 is given type
  {PQ: partition[T](a, b) |
     (FORALL (x: T): member(x, PQ) IFF (member(x, P) OR member(x, Q))) AND
      strictly_increasing?(PQ)} from its value expression.


 LET/WHERE variable pum at line 159, col 4 is given type
  {pm: [below(P`length) -> below(partition_union(a, b)(P, Q)`length)] |
     FORALL (ii: below(P`length)):
       P`seq(ii) = partition_union(a, b)(P, Q)`seq(pm(ii))} from its value expression.


 LET/WHERE variable CI at line 169, col 52 is given type
  [T -> bool] from its value expression.


 LET/WHERE variable PQ at line 171, col 65 is given type
  {PQ: partition[T](a, b) |
     (FORALL (x: T): member(x, PQ) IFF (member(x, P) OR member(x, Q))) AND
      strictly_increasing?(PQ)} from its value expression.


 In declaration Rie_sum_diff_extend_union:
  added conversion restrict[T, (CI), real]
             
  to g, converting
     [T -> real]
  to [(CI) -> real]

rs_integral_def typechecked in 1.311s: 30 TCCs, 0 proved, 3 subsumed, 27 unproved; 13 conversions; 8 msgs

 LET/WHERE variable S1 at line 129, col 28 is given type
  real from its value expression.


 LET/WHERE variable S2 at line 130, col 28 is given type
  real from its value expression.


 LET/WHERE variable CI at line 148, col 75 is given type
  [T -> bool] from its value expression.


 In declaration integrable_lem2_alt:
  added conversion restrict[T, (CI), real]
             
  to g, converting
     [T -> real]
  to [(CI) -> real]


 LET/WHERE variable CI at line 158, col 71 is given type
  [T -> bool] from its value expression.


 In declaration integrable_lem2:
  added conversion restrict[T, (CI), real]
             
  to g, converting
     [T -> real]
  to [(CI) -> real]

rs_integral_prep typechecked in 1.886s: 4 TCCs, 0 proved, 0 subsumed, 2 unproved, 2 trivial; 2 conversions; 4 msgs

 LET/WHERE variable CI at line 32, col 10 is given type
  [T -> bool] from its value expression.


 In declaration RS_integrable_cont_inc:
  added conversion restrict[[real, real], [T, T], nnreal]
             
  to real_dist, converting
     [[real, real] -> nnreal]
  to [[T, T] -> nnreal]


 In declaration RS_integrable_cont_inc:
  added conversion restrict[[real, real], [T, T], nnreal]
             
  to real_dist, converting
     [[real, real] -> nnreal]
  to [[T, T] -> nnreal]


 In declaration RS_integrable_cont_inc:
  added conversion restrict[[real, real], [T, T], nnreal]
             
  to real_dist, converting
     [[real, real] -> nnreal]
  to [[T, T] -> nnreal]


 In declaration RS_integrable_cont_inc:
  added conversion restrict[T, (CI), real]
             
  to g, converting
     [T -> real]
  to [(CI) -> real]


 LET/WHERE variable CI at line 38, col 10 is given type
  [T -> bool] from its value expression.


 In declaration RS_integrable_cont_BV:
  added conversion restrict[[real, real], [T, T], nnreal]
             
  to real_dist, converting
     [[real, real] -> nnreal]
  to [[T, T] -> nnreal]


 In declaration RS_integrable_cont_BV:
  added conversion restrict[[real, real], [T, T], nnreal]
             
  to real_dist, converting
     [[real, real] -> nnreal]
  to [[T, T] -> nnreal]


 In declaration RS_integrable_cont_BV:
  added conversion restrict[[real, real], [T, T], nnreal]
             
  to real_dist, converting
     [[real, real] -> nnreal]
  to [[T, T] -> nnreal]

rs_integral_cont typechecked in 2.365s: 8 TCCs, 0 proved, 4 subsumed, 4 unproved; 7 conversions; 2 msgs
riesz_representation typechecked in 3.681s: 33 TCCs, 0 proved, 19 subsumed, 14 unproved
top_riesz_representation typechecked in 9.042s: No TCCs generated
Parsing top_integral
top_integral parsed in 0.00 seconds
top_integral is already parsed
Typechecking top_integral
Parsing integral_mean_value
integral_mean_value parsed in 0.00 seconds
integral_mean_value is already parsed
Typechecking integral_mean_value
integral_mean_value typechecked in 0.11s: 8 TCCs, 0 proved, 4 subsumed, 4 unproved
Parsing integration_by_parts
integration_by_parts parsed in 0.02 seconds
integration_by_parts is already parsed
Typechecking integration_by_parts
integration_by_parts typechecked in 0.13s: 10 TCCs, 0 proved, 6 subsumed, 4 unproved
Parsing integral_split_fun
integral_split_fun parsed in 0.01 seconds
integral_split_fun is already parsed
Typechecking integral_split_fun
integral_split_fun typechecked in 0.55s: 110 TCCs, 0 proved, 86 subsumed, 24 unproved
top_integral typechecked in 1.482s: No TCCs generated
top typechecked in 20.891s: No TCCs generated
more_derivative_props typechecked in 31.309s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
Parsing linear_ode_1D
linear_ode_1D parsed in 0.00 seconds
linear_ode_1D is already parsed
Typechecking linear_ode_1D
linear_ode_1D typechecked in 2.144s: 45 TCCs, 0 proved, 20 subsumed, 24 unproved, 1 trivial

 LET/WHERE variable ng at line 85, col 11 is given type
  nat from its value expression.


 LET/WHERE variable nd at line 88, col 11 is given type
  nat from its value expression.


 In declaration dl_weakR:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_weakR:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_weakL:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_weakL:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_impliesallrunsb:
  added conversion BoolExpr2seq
             
  to (P IMPLIES Q), converting
     BoolExpr
  to bool


 In declaration dl_impliesallrunsd:
  added conversion BoolExpr2seq
             
  to (P IMPLIES Q), converting
     BoolExpr
  to bool


 In declaration dl_weak_impliesb:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesb:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesb:
  added conversion BoolExpr2list
             
  to ALLRUNS(A, Q), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesb:
  added conversion BoolExpr2list
             
  to ALLRUNS(A, P), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesd:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesd:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesd:
  added conversion BoolExpr2list
             
  to SOMERUNS(A, Q), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesd:
  added conversion BoolExpr2list
             
  to SOMERUNS(A, P), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesbE:
  added conversion BoolExpr2list
             
  to DLEXISTSR(Qe), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesbE:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesbE:
  added conversion BoolExpr2list
             
  to DLEXISTSR(LAMBDA (X: RealExpr): ALLRUNS(Ae(X), Qe(X))), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesbE:
  added conversion BoolExpr2list
             
  to DLEXISTSR(LAMBDA (X: RealExpr): ALLRUNS(Ae(X), P)), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesdE:
  added conversion BoolExpr2list
             
  to DLEXISTSR(Qe), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesdE:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesdE:
  added conversion BoolExpr2list
             
  to DLEXISTSR(LAMBDA (X: RealExpr): SOMERUNS(Ae(X), Qe(X))), converting
     BoolExpr
  to Formulas


 In declaration dl_weak_impliesdE:
  added conversion BoolExpr2list
             
  to DLEXISTSR(LAMBDA (X: RealExpr): SOMERUNS(Ae(X), P)), converting
     BoolExpr
  to Formulas


 LET/WHERE variable i at line 773, col 11 is given type
  nat from its value expression.


 In declaration dl_bounded_loop:
  added conversion BoolExpr2list
             
  to J, converting
     BoolExpr
  to Formulas


 In declaration dl_bounded_loop:
  added conversion BoolExpr2list
             
  to ALLRUNS(A, J), converting
     BoolExpr
  to Formulas


 In declaration dl_bounded_loop:
  added conversion BoolExpr2list
             
  to J, converting
     BoolExpr
  to Formulas


 In declaration dl_bounded_loop:
  added conversion BoolExpr2list
             
  to ALLRUNS(BSTAR(A, n), J), converting
     BoolExpr
  to Formulas


 In declaration dl_loop:
  added conversion BoolExpr2list
             
  to J, converting
     BoolExpr
  to Formulas


 In declaration dl_loop:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_loop:
  added conversion BoolExpr2list
             
  to J, converting
     BoolExpr
  to Formulas


 In declaration dl_loop:
  added conversion BoolExpr2list
             
  to ALLRUNS(A, J), converting
     BoolExpr
  to Formulas


 In declaration dl_MbL:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_MbL:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_MbR:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_MbR:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_MdL:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_MdL:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_MdR:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_MdR:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_MEbR:
  added conversion BoolExpr2list
             
  to DLEXISTSR(Qe), converting
     BoolExpr
  to Formulas


 In declaration dl_MEbR:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_MEbRA:
  added conversion BoolExpr2list
             
  to DLEXISTSR(Qe), converting
     BoolExpr
  to Formulas


 In declaration dl_MEbRA:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_orb:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_orb:
  added conversion BoolExpr2list
             
  to ALLRUNS(A, P), converting
     BoolExpr
  to Formulas


 In declaration dl_orb:
  added conversion BoolExpr2list
             
  to R, converting
     BoolExpr
  to Formulas


 In declaration dl_orb:
  added conversion BoolExpr2list
             
  to ALLRUNS(A, R), converting
     BoolExpr
  to Formulas


 In declaration dl_hide_restR:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_hide_restL:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_hide_restLR:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_hide_restLR:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dW:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dW:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_eq:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_eq:
  added conversion BoolExpr2list
             
  to (SUB_DIFTRe(P, ode)(re1) = SUB_DIFTRe(P, ode)(re2)), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_eq:
  added conversion BoolExpr2list
             
  to re1 = re2, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_eq:
  added conversion BoolExpr2list
             
  to ALLRUNS(DIFF(ode, DLAND(P, Q)), re1 = re2), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_neq:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_neq:
  added conversion BoolExpr2list
             
  to (SUB_DIFTRe(P, ode)(re1) = SUB_DIFTRe(P, ode)(re2)), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_neq:
  added conversion BoolExpr2list
             
  to re1 /= re2, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_neq:
  added conversion BoolExpr2list
             
  to ALLRUNS(DIFF(ode, DLAND(P, Q)), re1 /= re2), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_le:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_le:
  added conversion BoolExpr2list
             
  to (SUB_DIFTRe(P, ode)(re1) <= SUB_DIFTRe(P, ode)(re2)), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_le:
  added conversion BoolExpr2list
             
  to re1 <= re2, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_le:
  added conversion BoolExpr2list
             
  to ALLRUNS(DIFF(ode, DLAND(P, Q)), re1 <= re2), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_lt:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_lt:
  added conversion BoolExpr2list
             
  to (SUB_DIFTRe(P, ode)(re1) <= SUB_DIFTRe(P, ode)(re2)), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_lt:
  added conversion BoolExpr2list
             
  to re1 < re2, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_lt:
  added conversion BoolExpr2list
             
  to ALLRUNS(DIFF(ode, DLAND(P, Q)), re1 < re2), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_ge:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_ge:
  added conversion BoolExpr2list
             
  to (SUB_DIFTRe(P, ode)(re1) >= SUB_DIFTRe(P, ode)(re2)), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_ge:
  added conversion BoolExpr2list
             
  to re1 >= re2, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_ge:
  added conversion BoolExpr2list
             
  to ALLRUNS(DIFF(ode, DLAND(P, Q)), re1 >= re2), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_gt:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_gt:
  added conversion BoolExpr2list
             
  to (SUB_DIFTRe(P, ode)(re1) >= SUB_DIFTRe(P, ode)(re2)), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_gt:
  added conversion BoolExpr2list
             
  to re1 > re2, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_gt:
  added conversion BoolExpr2list
             
  to ALLRUNS(DIFF(ode, DLAND(P, Q)), re1 > re2), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_lite:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_lite:
  added conversion BoolExpr2list
             
  to SUB_DIFT(P, ode)(nnP), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_lite:
  added conversion BoolExpr2list
             
  to nqb_to_be(nnP), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_lite:
  added conversion BoolExpr2list
             
  to ALLRUNS(DIFF(ode, DLAND(P, Q)), nqb_to_be(nnP)), converting
     BoolExpr
  to Formulas


 In declaration dl_dI:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI:
  added conversion BoolExpr2list
             
  to SUB_DIFT(P, ode)(nnP), converting
     BoolExpr
  to Formulas


 In declaration dl_dI_dlTRUE:
  added conversion BoolExpr2list
             
  to Q, converting
     BoolExpr
  to Formulas


 In declaration dl_dI_dlTRUE:
  added conversion BoolExpr2list
             
  to SUB_DIFT(DLTRUE, ode)(nnP), converting
     BoolExpr
  to Formulas


 LET/WHERE variable i at line 1144, col 11 is given type
  nat from its value expression.

dynamic_logic typechecked in 45.76s: 43 TCCs, 0 proved, 12 subsumed, 31 unproved; 84 conversions; 4 msgs
Parsing dl_solution
dl_solution parsed in 0.01 seconds
dl_solution is already parsed
Typechecking dl_solution

 LET/WHERE variable ASSIGN_s at line 162, col 6 is given type
  [real -> (assign?)] from its value expression.


 LET/WHERE variable ASSIGN_s at line 177, col 6 is given type
  [real -> (assign?)] from its value expression.


 LET/WHERE variable Z at line 358, col 8 is given type
  [real -> MapExprInj] from its value expression.


 LET/WHERE variable ASSIGN_s at line 359, col 6 is given type
  [real -> (assign?)] from its value expression.


 LET/WHERE variable Z at line 370, col 6 is given type
  [real -> MapExprInj] from its value expression.


 LET/WHERE variable ASSIGN_s at line 371, col 6 is given type
  [real -> (assign?)] from its value expression.

Added 6 proofs from theory dl_solution to orphaned-proofs.prf
dl_solution typechecked in 4.107s: 43 TCCs, 0 proved, 11 subsumed, 32 unproved; 6 msgs
Parsing top_dtl
top_dtl parsed in 0.00 seconds
top_dtl is already parsed
Typechecking top_dtl
Parsing TraceState
TraceState parsed in 0.00 seconds
TraceState is already parsed
Typechecking TraceState
Wrote pvs file TraceState_adt
In DATATYPE theory TraceState_adt: 15 TCCs, 0 proved, 11 subsumed, 4 unproved, 0 trivial
In DATATYPE theory TraceState_adt_reduce: No TCCs generated
TraceState typechecked in 1.50s: No TCCs generated
Parsing even_more_list_props
even_more_list_props parsed in 0.00 seconds
even_more_list_props is already parsed
Typechecking even_more_list_props
even_more_list_props typechecked in 0.02s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing ltl_expr
ltl_expr parsed in 0.01 seconds
ltl_expr is already parsed
Typechecking ltl_expr
Parsing trace_semantics
trace_semantics parsed in 0.01 seconds
trace_semantics is already parsed
Typechecking trace_semantics
Parsing more_ci_props
more_ci_props parsed in 0.00 seconds
more_ci_props is already parsed
Typechecking more_ci_props
more_ci_props typechecked in 0.33s: 6 TCCs, 0 proved, 0 subsumed, 6 unproved

 LET/WHERE variable envi at line 50, col 11 is given type
  TraceState from its value expression.


 LET/WHERE variable envo at line 51, col 11 is given type
  TraceState from its value expression.


 LET/WHERE variable l at line 52, col 11 is given type
  Assigns from its value expression.


 LET/WHERE variable vari at line 56, col 19 is given type
  dLVar from its value expression.


 LET/WHERE variable rexpr at line 56, col 24 is given type
  RealExpr from its value expression.


 LET/WHERE variable env at line 64, col 12 is given type
  TraceState from its value expression.


 LET/WHERE variable envi at line 82, col 14 is given type
  TraceState from its value expression.


 LET/WHERE variable envo at line 83, col 14 is given type
  TraceState from its value expression.


 LET/WHERE variable envi at line 92, col 8 is given type
  TraceState from its value expression.


 LET/WHERE variable envo at line 93, col 8 is given type
  TraceState from its value expression.


 LET/WHERE variable envi at line 102, col 12 is given type
  TraceState from its value expression.


 LET/WHERE variable envi at line 107, col 12 is given type
  TraceState from its value expression.


 LET/WHERE variable envo at line 108, col 12 is given type
  TraceState from its value expression.


 LET/WHERE variable envi at line 147, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 148, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 155, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 156, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 163, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 164, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 171, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 172, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 180, col 14 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 181, col 14 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 186, col 14 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 187, col 14 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 192, col 12 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 193, col 12 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 200, col 14 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 201, col 14 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 206, col 14 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 207, col 14 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 212, col 12 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 213, col 12 is given type
  Environment from its value expression.


 LET/WHERE variable envi at line 233, col 10 is given type
  Environment from its value expression.


 LET/WHERE variable envo at line 234, col 10 is given type
  Environment from its value expression.

trace_semantics typechecked in 5.171s: 36 TCCs, 0 proved, 15 subsumed, 21 unproved; 35 msgs

 LET/WHERE variable c at line 17, col 6 is given type
  TraceState from its value expression.


 LET/WHERE variable c at line 74, col 12 is given type
  TraceState from its value expression.


 LET/WHERE variable c at line 88, col 8 is given type
  TraceState from its value expression.


 LET/WHERE variable c at line 135, col 4 is given type
  TraceState from its value expression.


 LET/WHERE variable c at line 155, col 4 is given type
  TraceState from its value expression.


 LET/WHERE variable c at line 174, col 4 is given type
  TraceState from its value expression.


 LET/WHERE variable c at line 195, col 4 is given type
  TraceState from its value expression.

ltl_expr typechecked in 6.596s: 35 TCCs, 0 proved, 14 subsumed, 21 unproved; 7 msgs
Parsing solution_odes_props
solution_odes_props parsed in 0.01 seconds
solution_odes_props is already parsed
Typechecking solution_odes_props

 LET/WHERE variable fsh at line 32, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 LET/WHERE variable fsh at line 45, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 LET/WHERE variable fsh at line 57, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 LET/WHERE variable fcat at line 70, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 In declaration diff_odes_cat_hp:
  added conversion restrict[real, (hp(0)), real]
             
  to fs1(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration diff_odes_cat_hp:
  added conversion restrict[real, (hp(0)), real]
             
  to fs2(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 LET/WHERE variable fcat at line 85, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 In declaration diff_odes_cat_ci:
  added conversion restrict[real, (hp(0)), real]
             
  to fs1(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration diff_odes_cat_ci:
  added conversion restrict[real, (closed_interval(0, b)), real]
             
  to fs2(k), converting
     [real -> real]
  to [(closed_interval(0, b)) -> real]


 LET/WHERE variable fcat at line 100, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 In declaration der_odes_cat_hp:
  added conversion restrict[real, (hp(0)), real]
             
  to fs1(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration der_odes_cat_hp:
  added conversion restrict[real, (hp(0)), real]
             
  to fs2(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration der_odes_cat_hp:
  added conversion restrict[real, (hp(0)), real]
             
  to fs1(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration der_odes_cat_hp:
  added conversion restrict[real, (hp(0)), real]
             
  to fs2(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 LET/WHERE variable fcat at line 119, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 In declaration der_odes_cat_ci:
  added conversion restrict[real, (hp(0)), real]
             
  to fs1(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration der_odes_cat_ci:
  added conversion restrict[real, (closed_interval(0, b)), real]
             
  to fs2(k), converting
     [real -> real]
  to [(closed_interval(0, b)) -> real]


 In declaration der_odes_cat_ci:
  added conversion restrict[real, (closed_interval(0, b + T)), real]
             
  to fcat(k), converting
     [real -> real]
  to [(closed_interval(0, b + T)) -> real]


 In declaration der_odes_cat_ci:
  added conversion restrict[real, (hp(0)), real]
             
  to fs1(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration der_odes_cat_ci:
  added conversion restrict[real, (closed_interval(0, b)), real]
             
  to fs2(k), converting
     [real -> real]
  to [(closed_interval(0, b)) -> real]


 In declaration solution_odes_deriv_at_T_hp:
  added conversion restrict[real, (hp(0)), real]
             
  to fs1(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration solution_odes_deriv_at_T_hp:
  added conversion restrict[real, (hp(0)), real]
             
  to fs2(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration solution_odes_deriv_at_T_ci:
  added conversion restrict[real, (hp(0)), real]
             
  to fs1(k), converting
     [real -> real]
  to [(hp(0)) -> real]


 In declaration solution_odes_deriv_at_T_ci:
  added conversion restrict[real, (closed_interval(0, b)), real]
             
  to fs2(k), converting
     [real -> real]
  to [(closed_interval(0, b)) -> real]


 LET/WHERE variable fcat at line 168, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 LET/WHERE variable fcat at line 182, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.


 LET/WHERE variable fsh at line 199, col 6 is given type
  [below(length(ode)) -> [real -> real]] from its value expression.

solution_odes_props typechecked in 1.351s: 103 TCCs, 0 proved, 58 subsumed, 45 unproved; 17 conversions; 10 msgs
Parsing temporal_logic
temporal_logic parsed in 0.01 seconds
temporal_logic is already parsed
Typechecking temporal_logic
Parsing trace_bounded_star_semantics
trace_bounded_star_semantics parsed in 0.01 seconds
trace_bounded_star_semantics is already parsed
Typechecking trace_bounded_star_semantics
trace_bounded_star_semantics typechecked in 0.83s: 11 TCCs, 0 proved, 2 subsumed, 9 unproved

 In declaration dltl_SEQcap:
  added conversion BoolExpr2list
             
  to ALLRUNS_tr(A, normDLGLOBALLY(ALLRUNS_tr(B, normDLGLOBALLY(P, Q)), Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_SEQcap:
  added conversion BoolExpr2list
             
  to ALLRUNS_tr(SEQ(A, B), normDLGLOBALLY(P, Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_SEQcap_con:
  added conversion BoolExpr2list
             
  to ALLRUNS_tr(SEQ(A, B), normDLGLOBALLY(P, Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_SEQcap_con:
  added conversion BoolExpr2list
             
  to DLOR(SOMERUNS_st(A, ALLRUNS_tr(B, normDLGLOBALLY(P, Q))),
          ALLRUNS_tr(A, normDLGLOBALLY(DLTRUE, Q))), converting
     BoolExpr
  to Formulas


 In declaration dltl_SEQcup_dual:
  added conversion BoolExpr2list
             
  to DLOR(SOMERUNS_st(A, SOMERUNS_tr(B, normDLEVENTUALLY(P, Q))),
          SOMERUNS_tr(SEQ(A, TEST(DLFALSE)), normDLEVENTUALLY(P, Q))), converting
     BoolExpr
  to Formulas


 In declaration dltl_SEQcup_dual:
  added conversion BoolExpr2list
             
  to SOMERUNS_tr(SEQ(A, B), normDLEVENTUALLY(P, Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_SEQcup_dual_con:
  added conversion BoolExpr2list
             
  to SOMERUNS_tr(SEQ(A, B), normDLEVENTUALLY(P, Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_SEQcup_dual_con:
  added conversion BoolExpr2list
             
  to SOMERUNS_tr(A, normDLEVENTUALLY(SOMERUNS_tr(B, normDLEVENTUALLY(P, Q)), Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_DIFFcap:
  added conversion BoolExpr2list
             
  to DLAND(P, ALLRUNS_st(DIFF(f, Q), R AND P)), converting
     BoolExpr
  to Formulas


 In declaration dltl_DIFFcap:
  added conversion BoolExpr2list
             
  to ALLRUNS_tr(DIFF(f, Q), normDLGLOBALLY(R, P)), converting
     BoolExpr
  to Formulas


 In declaration dltl_DIFFcup_dual:
  added conversion BoolExpr2list
             
  to SOMERUNS_tr(DIFF(f, Q), normDLEVENTUALLY(R, P)), converting
     BoolExpr
  to Formulas


 In declaration dltl_DIFFcup_dual:
  added conversion BoolExpr2list
             
  to DLOR(P, SOMERUNS_st(DIFF(f, Q), R OR P)), converting
     BoolExpr
  to Formulas


 In declaration dltl_BSTARindcup:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dltl_BSTARindcup:
  added conversion BoolExpr2list
             
  to ALLRUNS_tr(A, normDLEVENTUALLY(P, Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_BSTARindcup:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dltl_BSTARindcup:
  added conversion BoolExpr2list
             
  to ALLRUNS_tr(BSTAR(A, n), normDLEVENTUALLY(P, Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_STARindcup:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dltl_STARindcup:
  added conversion BoolExpr2list
             
  to ALLRUNS_tr(A, normDLEVENTUALLY(P, Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_STARindcup:
  added conversion BoolExpr2list
             
  to P, converting
     BoolExpr
  to Formulas


 In declaration dltl_STARindcup:
  added conversion BoolExpr2list
             
  to ALLRUNS_tr(STAR(A), normDLEVENTUALLY(P, Q)), converting
     BoolExpr
  to Formulas


 In declaration dltl_STARconcap:
  added conversion BoolExpr2list
             
  to qQ(r), converting
     BoolExpr
  to Formulas


 In declaration dltl_STARconcap:
  added conversion BoolExpr2list
             
  to SOMERUNS_tr(A, normDLGLOBALLY(qQ(r - 1), P)), converting
     BoolExpr
  to Formulas


 In declaration dltl_STARconcap:
  added conversion BoolExpr2list
             
  to DLAND(DLEXISTS(qQ), P), converting
     BoolExpr
  to Formulas


 In declaration dltl_STARconcap:
  added conversion BoolExpr2list
             
  to SOMERUNS_tr(STAR(A),
                 normDLGLOBALLY(LAMBDA (env: Environment):
                                  EXISTS (r: nonpos_real): qQ(r)(env),
                                P)), converting
     BoolExpr
  to Formulas

temporal_logic typechecked in 2.934s: 8 TCCs, 0 proved, 7 subsumed, 1 unproved; 24 conversions
top_dtl typechecked in 15.679s: No TCCs generated
Parsing sem_rel_diff_star
sem_rel_diff_star parsed in 0.00 seconds
sem_rel_diff_star is already parsed
Typechecking sem_rel_diff_star
sem_rel_diff_star typechecked in 1.054s: 5 TCCs, 0 proved, 4 subsumed, 1 unproved
top typechecked in 262.377s: No TCCs generated
Context file /Users/cmunoz/src/PVS.gitlab/nasalib/dL/.pvscontext written

Defining VECT-DISTR. 
Defining VECT-DISTR$. 
Defining VECT-DISTR-OFF. 
Defining VECT-DISTR-OFF$. 
Defining MANIP-VECTORS. 
Defining MANIP-VECTORS$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in: DEFUN REFRESH-VECTOR-TYPES
;     (ERROR (PVS::CONDITION) NIL)
; 
; caught STYLE-WARNING:
;   The variable CONDITION is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

;  Registering Manip extensions for library vectors.
;---------
Extends several Manip strategies to work with vectors.
Invoke (help manip-vectors) to see full documentation.
;---------

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in:
;      DEFMETHOD MULT/DIV-BY-STEPS (PVS-TYPE-VECTOR PVS-TYPE-REAL T T T T T T)
;     (PVS::MULT-BY-SCAL TERM:TERM PVS::FNUM PVS:FORMULA)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT-BY-SCAL

;     (PVS::MULT-BY-SCAL/DOT TERM:TERM PVS::FNUM PVS:FORMULA)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT-BY-SCAL/DOT
; 
; compilation unit finished
;   Undefined functions:
;     MULT-BY-SCAL MULT-BY-SCAL/DOT
;   caught 2 STYLE-WARNING conditions

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in:
;      DEFMETHOD MULT/DIV-BY-STEPS (PVS-TYPE-REAL PVS-TYPE-VECTOR T T T T T T)
;     (PVS::MULT-BY-SCAL TERM:TERM PVS::FNUM PVS:FORMULA T)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT-BY-SCAL

;     (PVS::MULT-BY-SCAL/DOT TERM:TERM PVS::FNUM PVS:FORMULA T)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT-BY-SCAL/DOT
; 
; compilation unit finished
;   Undefined functions:
;     MULT-BY-SCAL MULT-BY-SCAL/DOT
;   caught 2 STYLE-WARNING conditions

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in:
;      DEFMETHOD MULT/DIV-BY-STEPS (PVS-TYPE-VECT2 PVS-TYPE-VECT2 T T T T T T)
;     (PVS::MULT/DIV-BY-DOT/NORM PVS::OP TERM:TERM PVS::FNUM PVS::SIGN PVS:FORMULA
;      PVS::RELATION)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT/DIV-BY-DOT/NORM
; 
; compilation unit finished
;   Undefined function:
;     MULT/DIV-BY-DOT/NORM
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in:
;      DEFMETHOD MULT/DIV-BY-STEPS (PVS-TYPE-VECT3 PVS-TYPE-VECT3 T T T T T T)
;     (PVS::MULT/DIV-BY-DOT/NORM PVS::OP TERM:TERM PVS::FNUM PVS::SIGN PVS:FORMULA
;      PVS::RELATION)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT/DIV-BY-DOT/NORM
; 
; compilation unit finished
;   Undefined function:
;     MULT/DIV-BY-DOT/NORM
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in:
;      DEFMETHOD MULT/DIV-BY-STEPS (PVS-TYPE-VECTN PVS-TYPE-VECTN T T T T T T)
;     (PVS::MULT/DIV-BY-DOT/NORM PVS::OP TERM:TERM PVS::FNUM PVS::SIGN PVS:FORMULA
;      PVS::RELATION)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT/DIV-BY-DOT/NORM
; 
; compilation unit finished
;   Undefined function:
;     MULT/DIV-BY-DOT/NORM
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in: DEFUN MULT/DIV-BY-DOT/NORM
;     (DEFUN PVS::MULT/DIV-BY-DOT/NORM
;            (PVS::OP TERM:TERM PVS::FNUM PVS::SIGN PVS:FORMULA PVS::RELATION)
;       (COND
;        ((AND (EQ PVS::RELATION '=) (EQ PVS::OP '*) (< PVS::FNUM 0))
;         (PVS::MULT-BY-SCAL/DOT TERM:TERM PVS::FNUM PVS:FORMULA))
;        ((AND (EQ PVS::RELATION '=) (EQ PVS::OP '/) (< PVS::FNUM 0))
;         (PVS::MULT-BY-SCAL/DOT (FORMAT NIL "(1/norm(~A))" TERM:TERM) PVS::FNUM
;          PVS:FORMULA))
;        ((AND (EQ PVS::RELATION '=) (EQ PVS::OP '/))
;         (PVS::MULT-BY-SCAL (FORMAT NIL "(1/norm(~A))" TERM:TERM) PVS::FNUM
;          PVS:FORMULA))
;        (T (PVS::MANIP-UNSUITABLE-FNUM 'PVS::MULT/DIV-BY PVS::FNUM))))
; 
; caught STYLE-WARNING:
;   The variable SIGN is defined but never used.

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in: DEFUN MULT/DIV-BY-DOT/NORM
;     (PVS::MULT-BY-SCAL (FORMAT NIL "(1/norm(~A))" TERM:TERM) PVS::FNUM
;      PVS:FORMULA)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT-BY-SCAL

;     (PVS::MULT-BY-SCAL/DOT TERM:TERM PVS::FNUM PVS:FORMULA)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MULT-BY-SCAL/DOT
; 
; compilation unit finished
;   Undefined functions:
;     MULT-BY-SCAL MULT-BY-SCAL/DOT
;   caught 3 STYLE-WARNING conditions

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in: DEFMETHOD MOVE-TERMS-JUST-STEP (PVS-TYPE-VECTOR T T T T T)
;     (PVS::MOVE-PERMUTE-JUST-STEP PVS::SIDE PVS::FNUM PVS::FROM-LIST PVS::TO-LIST
;      PVS::TNUMS)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::MOVE-PERMUTE-JUST-STEP
; 
; compilation unit finished
;   Undefined function:
;     MOVE-PERMUTE-JUST-STEP
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in: DEFUN MOVE-PERMUTE-JUST-STEP
;     (DEFUN PVS::MOVE-PERMUTE-JUST-STEP
;            (PVS::SIDE PVS::FNUM PVS::FROM-LIST PVS::TO-LIST PVS::TNUMS)
;       (LET* ((PVS::JUST-STEP `(PVS::THEN # # #))
;              (PVS::BACK-UP-MSG
;               (PVS::GEN-MANIP-RESPONSE 'PVS::MOVE-TERMS
;                                        "Unable to prove justification.")))
;         `(PVS::THEN (PVS::HIDE-ALL-BUT 1)
;           (PVS::TRY (PVS::THEN ,PVS::JUST-STEP ,PVS::BACK-UP-MSG #) (PVS::SKIP)
;            (PVS::SKIP)))))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable FNUM is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable FROM-LIST is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable TO-LIST is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable TNUMS is defined but never used.
; 
; compilation unit finished
;   caught 5 STYLE-WARNING conditions

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in: DEFUN COLLECT-SCALAR-TERMS
;     #'(LAMBDA (PVS::A PVS::B)
;         (PVS:SUBTYPE-OF? (PVS:TYPE PVS::A) PVS:*NUMBER_FIELD*))
; 
; caught STYLE-WARNING:
;   The variable B is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in: DEFMETHOD DISTRIB-STEP (PVS-TYPE-REAL PVS-TYPE-VECTOR T T)
;     (PVS::DISTRIB-NAME-STEPS PVS::EXPR-OBJ PVS::FNUM
;      (PVS::GET-VECTOR-LEMMAS PVS::RIGHT-CL PVS::LEMMAS))
; 
; caught STYLE-WARNING:
;   undefined function: PVS::DISTRIB-NAME-STEPS
; 
; compilation unit finished
;   Undefined function:
;     DISTRIB-NAME-STEPS
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/vectors/manip-vectors.lisp
; in: DEFMETHOD DISTRIB-STEP (PVS-TYPE-VECTOR PVS-TYPE-VECTOR T T)
;     (PVS::DISTRIB-NAME-STEPS PVS::EXPR-OBJ PVS::FNUM
;      (PVS::GET-VECTOR-LEMMAS PVS::RIGHT-CL PVS::LEMMAS))
; 
; caught STYLE-WARNING:
;   undefined function: PVS::DISTRIB-NAME-STEPS
; 
; compilation unit finished
;   Undefined function:
;     DISTRIB-NAME-STEPS
;   caught 1 STYLE-WARNING condition

Defining DERIVABLE__. 
Defining DERIVABLE__$. 
Defining DERIV-DOMAIN__. 
Defining DERIV-DOMAIN__$. ; 
; caught STYLE-WARNING:
;   Call to PVS::TUPLE-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DERIVABLE. 
Defining DERIVABLE$. 
Defining DIFFERENTIABLE. 
Defining DERIV__. 
Defining DERIV__$. ; 
; caught STYLE-WARNING:
;   Call to PVS::INFIX-EQUATION? could not be inlined because its source code was
;   not saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in
;   effect to save function definitions for inlining.

; 
; caught STYLE-WARNING:
;   Call to PVS::FUNTYPE? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.

; file: //Users/cmunoz/src/PVS.gitlab/nasalib/analysis//pvs-strategies
; in: DEFSTEP DERIV
;     (PVS::EXTRA-GET-FNUM PVS::FN!)
; 
; caught WARNING:
;   undefined variable: PVS::FN!

;     (PVS::EXTRA-GET-FORMULA PVS::FN!)
; 
; caught WARNING:
;   undefined variable: PVS::FN!
; 
; compilation unit finished
;   Undefined variable:
;     FN!
;   caught 2 WARNING conditions
;   caught 2 STYLE-WARNING conditions

Defining DERIV. 
Defining DERIV$. 
Defining DERIVATIVE. 
Defining SQRT-REW. 
Defining SQRT-REW$. 
Defining SQRT-REW-OFF. 
Defining SQRT-REW-OFF$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: LOAD-OTHER-STRAT-FILES "dl-diffghost.lisp"
;     (PVS::LOAD-OTHER-STRAT-FILES "dl-diffghost.lisp")
; --> HANDLER-CASE SB-INT:DX-FLET FLET 
; ==>
;   (#:FUN1 (PVS::C)
;    (DECLARE
;     (SB-C::SOURCE-FORM
;      (ERROR (PVS::C) (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE))))
;    (PROGN (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE)))
; 
; caught STYLE-WARNING:
;   The variable C is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Should probably rename arg NAME in DL-DIFFGHOST: it appears in the body as a possible strategy

Should probably rename arg NAME in DL-DIFFGHOST: it appears in the body as a possible strategy

Should probably rename arg NAME in DL-DIFFGHOST: it appears in the body as a possible strategy

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-diffghost.lisp
; in: DEFSTEP DL-DIFFGHOST
;     (PVS::DL-INDICES* PVS::STUB-CUT)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::DL-INDICES*

;     (PVS::GET-FRESH-IDX-FROM-ID-IDX-ALIST PVS::STUB-CUT-INDICES)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::GET-FRESH-IDX-FROM-ID-IDX-ALIST

;     (PVS::GET-FRESH-INDEX PVS::E1 PVS::E2)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::GET-FRESH-INDEX

;     (PVS::NAME-COLLISION? PVS::STUB-CUT-INDICES (INTERN PVS:NAME))
; 
; caught STYLE-WARNING:
;   undefined function: PVS::NAME-COLLISION?
; 
; compilation unit finished
;   Undefined functions:
;     DL-INDICES* GET-FRESH-IDX-FROM-ID-IDX-ALIST GET-FRESH-INDEX NAME-COLLISION?
;   caught 4 STYLE-WARNING conditions

Defining DL-DIFFGHOST. 
Defining DL-DIFFGHOST$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-diffghost.lisp
; in: DEFUN GET-FRESH-INDEX
;     (PVS::DL-INDICES* (PVS:FORMULA PVS::S-FORM))
; 
; caught STYLE-WARNING:
;   undefined function: PVS::DL-INDICES*
; 
; compilation unit finished
;   Undefined function:
;     DL-INDICES*
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-diffghost.lisp
; in: DEFUN GET-DE-BRUIJN-NAMES
;     (PVS::DL-INDICES* PVS:EXPR)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::DL-INDICES*
; 
; compilation unit finished
;   Undefined function:
;     DL-INDICES*
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   Call to PVS:CONST-DECL? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
; 
; caught STYLE-WARNING:
;   Call to PVS::SKOLEM-CONST-DECL? could not be inlined because its source code
;   was not saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in
;   effect to save function definitions for inlining.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-diffghost.lisp
; in: DEFMETHOD DL-INDICES* (TUPLE-EXPR)
;     (LOOP PVS::FOR PVS:EXPR PVS::IN PVS:EXPRS
;           PVS::COLLECT (PVS::DL-INDICES* PVS:EXPR))
; --> LET SB-KERNEL:THE* 
; ==>
;   PVS:EXPRS
; 
; caught WARNING:
;   undefined variable: PVS:EXPRS
; 
; compilation unit finished
;   Undefined variable:
;     EXPRS
;   caught 1 WARNING condition

; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: LOAD-OTHER-STRAT-FILES "dl-diffinv.lisp"
;     (PVS::LOAD-OTHER-STRAT-FILES "dl-diffinv.lisp")
; --> HANDLER-CASE SB-INT:DX-FLET FLET 
; ==>
;   (#:FUN1 (PVS::C)
;    (DECLARE
;     (SB-C::SOURCE-FORM
;      (ERROR (PVS::C) (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE))))
;    (PROGN (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE)))
; 
; caught STYLE-WARNING:
;   The variable C is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-diffinv.lisp
; in: DEFSTEP DL-DIFFINV
;     #'PVS::DL-DIFF-LMBD
; 
; caught STYLE-WARNING:
;   undefined function: PVS::DL-DIFF-LMBD

;     (PVS::DL-FNUM (CDR PVS::DLSEQ) PVS::DLFNUM 1 #'PVS::DL-DIFF-LMBD)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::DL-FNUM

;     (PVS::DL-TRANSLATE2NQB PVS::BEXPR)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::DL-TRANSLATE2NQB

;     (PVS::IS-DL-SEQ PVS::FNUM)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::IS-DL-SEQ

;     (FORMAT NIL "(~a)=nqb_to_be(~a)" PVS::BEXPR PVS::NNQB_)
; 
; caught WARNING:
;   undefined variable: PVS::NNQB_
; 
; compilation unit finished
;   Undefined functions:
;     DL-DIFF-LMBD DL-FNUM DL-TRANSLATE2NQB IS-DL-SEQ
;   Undefined variable:
;     NNQB_
;   caught 1 WARNING condition
;   caught 4 STYLE-WARNING conditions

Defining DL-DIFFINV. 
Defining DL-DIFFINV$. 
Defining DL-SUBDIFT__. 
Defining DL-SUBDIFT__$. 
Defining DL-SUBDDT__. 
Defining DL-SUBDDT__$. 
Defining DL-NQBOOLDER__. 
Defining DL-NQBOOLDER__$. ; 
; caught STYLE-WARNING:
;   Call to PVS::INFIX-APPLICATION? could not be inlined because its source code
;   was not saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in
;   effect to save function definitions for inlining.

; 
; caught STYLE-WARNING:
;   Call to PVS::APPLICATION? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.

; 
; caught STYLE-WARNING:
;   Call to PVS::LAMBDA-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.
; 
; compilation unit finished
;   caught 3 STYLE-WARNING conditions

Defining SIMPLIFY-DIFT_RE-EXPRESSION. 
Defining SIMPLIFY-DIFT_RE-EXPRESSION$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: LOAD-OTHER-STRAT-FILES "dl-solve.lisp"
;     (PVS::LOAD-OTHER-STRAT-FILES "dl-solve.lisp")
; --> HANDLER-CASE SB-INT:DX-FLET FLET 
; ==>
;   (#:FUN1 (PVS::C)
;    (DECLARE
;     (SB-C::SOURCE-FORM
;      (ERROR (PVS::C) (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE))))
;    (PROGN (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE)))
; 
; caught STYLE-WARNING:
;   The variable C is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-CNSTLINS. 
Defining DL-CNSTLINS$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFSTEP BROKEN-DL-SOLVE
;     (PVS::FORM PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J

; in: DEFSTEP BROKEN-DL-SOLVE => DEFTACTIC SIMPLIFY_Y_SOL_EX
;     (PVS::ITE PVS::$AJ)
; 
; caught WARNING:
;   undefined variable: PVS::$AJ

; in: DEFSTEP BROKEN-DL-SOLVE => DEFTACTIC SIMPLIFY_EVALUABLE_ITES
;     (PVS::ITE PVS::$AJ)
; 
; caught WARNING:
;   undefined variable: PVS::$AJ

; in: DEFSTEP BROKEN-DL-SOLVE
;     (PVS::IS-DL-SEQ PVS::FNUM)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::IS-DL-SEQ

;     (PVS::PP-LENGTH PVS::LEXPR)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::PP-LENGTH
; 
; compilation unit finished
;   Undefined functions:
;     IS-DL-SEQ PP-LENGTH
;   Undefined variables:
;     $1J $AJ
;   caught 3 WARNING conditions
;   caught 2 STYLE-WARNING conditions

Defining BROKEN-DL-SOLVE. 
Defining BROKEN-DL-SOLVE$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFSTEP SIMPLIFY_NTH
;     (PVS::NTH-EXPR PVS::$AJ)
; 
; caught WARNING:
;   undefined variable: PVS::$AJ

;     (PVS::PVSLIST2LIST PVS::PVS-LIST)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::PVSLIST2LIST
; 
; compilation unit finished
;   Undefined function:
;     PVSLIST2LIST
;   Undefined variable:
;     $AJ
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

Defining SIMPLIFY_NTH. 
Defining SIMPLIFY_NTH$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFSTEP DL-SOLVE
;     (PVS::APPLY-SUBSTITUTION-ON-DLFORALL PVS::DLFORALL)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::APPLY-SUBSTITUTION-ON-DLFORALL

;     (PVS::IS-DL-SEQ PVS::FNUM)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::IS-DL-SEQ

;     (PVS::PP-LENGTH PVS::LEXPR)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::PP-LENGTH

;     (PVS::EXTRA-GET-FNUM PVS::SOLUTION_LEMMA)
; 
; caught WARNING:
;   undefined variable: PVS::SOLUTION_LEMMA
; 
; caught WARNING:
;   undefined variable: PVS::SOLUTION_LEMMA

; in: DEFSTEP DL-SOLVE => DEFTACTIC SIMPLIFY_Y_SOL_EX
;     (PVS::EXTRA-GET-FNUM PVS::TAC-FNUM)
; 
; caught WARNING:
;   undefined variable: PVS::TAC-FNUM
; 
; compilation unit finished
;   Undefined functions:
;     APPLY-SUBSTITUTION-ON-DLFORALL IS-DL-SEQ PP-LENGTH
;   Undefined variables:
;     SOLUTION_LEMMA TAC-FNUM
;   caught 3 WARNING conditions
;   caught 3 STYLE-WARNING conditions

Defining DL-SOLVE. 
Defining DL-SOLVE$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFUN APPLY-SUBSTITUTION-ON-DLFORALL
;     (PVS::APPLY-SUBSTITUTION-ON-SUBS-APP PVS::SUBS-APP)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::APPLY-SUBSTITUTION-ON-SUBS-APP
; 
; compilation unit finished
;   Undefined function:
;     APPLY-SUBSTITUTION-ON-SUBS-APP
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFUN APPLY-SUBSTITUTION-ON-SUBS-APP
;     (PVS::RESOLVE-SUB-RE PVS::ARG2 PVS::NEW-SUBS-OP)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::RESOLVE-SUB-RE
; 
; compilation unit finished
;   Undefined function:
;     RESOLVE-SUB-RE
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFUN RESOLVE-SUB-RE
;     (PVS::EVALUATE_SUB_MAPVAR (CDR (PVS::PVSLIST2LIST PVS::SIGMA)) PVS::VAR)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::EVALUATE_SUB_MAPVAR

;     (PVS::PVSLIST2LIST PVS::SIGMA)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::PVSLIST2LIST

;     (ERROR "Unexpected arity for RealExpr ~a" PVS::RE)
; 
; caught WARNING:
;   undefined variable: PVS::RE
; 
; compilation unit finished
;   Undefined functions:
;     EVALUATE_SUB_MAPVAR PVSLIST2LIST
;   Undefined variable:
;     RE
;   caught 1 WARNING condition
;   caught 2 STYLE-WARNING conditions

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFHELPER DL-SIMPLIFY-ZIP-SOL
;     (PVS:ARGS1 PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J

;     (PVS:ARGS2 PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J
; 
; compilation unit finished
;   Undefined variable:
;     $1J
;   caught 2 WARNING conditions

Defining DL-SIMPLIFY-ZIP-SOL. 
Defining DL-SIMPLIFY-ZIP-SOL$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFHELPER DL-PP-ZIP-SOL
;     (PVS::ORIGINAL-FORMULA PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J

;     (PVS::PVSLIST2LIST PVS::ORIGINAL-PVS-LIST)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::PVSLIST2LIST
; 
; compilation unit finished
;   Undefined function:
;     PVSLIST2LIST
;   Undefined variable:
;     $1J
;   caught 1 WARNING condition
;   caught 1 STYLE-WARNING condition

Defining DL-PP-ZIP-SOL. 
Defining DL-PP-ZIP-SOL$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: LOAD-OTHER-STRAT-FILES "dl-pp.lisp"
;     (PVS::LOAD-OTHER-STRAT-FILES "dl-pp.lisp")
; --> HANDLER-CASE SB-INT:DX-FLET FLET 
; ==>
;   (#:FUN1 (PVS::C)
;    (DECLARE
;     (SB-C::SOURCE-FORM
;      (ERROR (PVS::C) (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE))))
;    (PROGN (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE)))
; 
; caught STYLE-WARNING:
;   The variable C is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-pp.lisp
; in: DEFSTEP DL-PP
;     (PVS::IS-DL-SEQ PVS::FNUM)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::IS-DL-SEQ

;     (PVS::PVSLIST2LIST (PVS:ARGS2 PVS:EXPR))
; 
; caught STYLE-WARNING:
;   undefined function: PVS::PVSLIST2LIST
; 
; compilation unit finished
;   Undefined functions:
;     IS-DL-SEQ PVSLIST2LIST
;   caught 2 STYLE-WARNING conditions

Defining DL-PP. 
Defining DL-PP$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-pp.lisp
; in: DEFSTEP DL-PP-LIST-TO-LISTEXPR
;     (PVS::ORIGINAL-CONS PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J

;     (PVS::ERROR-FORMAT-IF "Cannot transform ~a to a list-expr"
;                           PVS::ORIGINAL-PVS-LIST)
; --> IF PVS::SET-STRATEGY-ERRORS 
; ==>
;   (FORMAT NIL "Cannot transform ~a to a list-expr" PVS::ORIGINAL-PVS-LIST)
; 
; caught WARNING:
;   undefined variable: PVS::ORIGINAL-PVS-LIST

;     (PVS::PVSLIST2LIST PVS::ORIGINAL-CONS)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::PVSLIST2LIST
; 
; compilation unit finished
;   Undefined function:
;     PVSLIST2LIST
;   Undefined variables:
;     $1J ORIGINAL-PVS-LIST
;   caught 2 WARNING conditions
;   caught 1 STYLE-WARNING condition

Defining DL-PP-LIST-TO-LISTEXPR. 
Defining DL-PP-LIST-TO-LISTEXPR$. 
Defining DL-UNROLL. 
Defining DL-UNROLL$. ; 
; caught STYLE-WARNING:
;   Call to PVS::NULL-EXPR? could not be inlined because its source code was not
;   saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to
;   save function definitions for inlining.

; 
; caught STYLE-WARNING:
;   Call to PVS::CONSTRUCTOR-NAME-EXPR? could not be inlined because its source
;   code was not saved. A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be
;   in effect to save function definitions for inlining.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions

Defining DL-ISDLFNUM__. 
Defining DL-ISDLFNUM__$. 
Defining DL-MOVE__. 
Defining DL-MOVE__$. 
Defining DL-MOVE. 
Defining DL-MOVE$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN ANYTERM-LMBD
;     (DEFUN PVS::ANYTERM-LMBD (PVS:EXPR PVS::SIDE) T)
; 
; caught STYLE-WARNING:
;   The variable EXPR is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
; 
; caught STYLE-WARNING:
;   Call to PVS::EXPR? could not be inlined because its source code was not saved.
;   A global INLINE or SB-EXT:MAYBE-INLINE proclamation must be in effect to save
;   function definitions for inlining.

; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFSTEP DL-LEMMA__
;     `(PVS::! ,PVS::FN!
;       ,(IF (> PVS::DLFN 0)
;            1
;            2))
; 
; caught WARNING:
;   undefined variable: PVS::FN!

;     `(PVS::! ,PVS::FN!
;       ,(IF (> PVS::DLFN 0)
;            2
;            1)
;       2)
; 
; caught WARNING:
;   undefined variable: PVS::FN!

;     `(PVS::! ,PVS::FN!
;       ,(IF (> PVS::DLFN 0)
;            1
;            2))
; 
; caught WARNING:
;   undefined variable: PVS::FN!
; 
; compilation unit finished
;   Undefined variable:
;     FN!
;   caught 3 WARNING conditions
;   caught 1 STYLE-WARNING condition

Defining DL-LEMMA__. 
Defining DL-LEMMA__$. 
Defining DL-HIDE. 
Defining DL-HIDE$. 
Defining DL-HIDEREST. 
Defining DL-HIDEREST$. 
Defining DL-SUBS. 
Defining DL-SUBS$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-ANYB-LMBD
;     (DEFUN PVS::DL-ANYB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "ANY")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-ANYB. 
Defining DL-ANYB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-ANYD-LMBD
;     (DEFUN PVS::DL-ANYD-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "ANY")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-ANYD. 
Defining DL-ANYD$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-ASSIGNB-LMBD
;     (DEFUN PVS::DL-ASSIGNB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "ASSIGN")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-ASSIGNB. 
Defining DL-ASSIGNB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-ASSIGND-LMBD
;     (DEFUN PVS::DL-ASSIGND-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "ASSIGN")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-ASSIGND. 
Defining DL-ASSIGND$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-COMPOSEB-LMBD
;     (DEFUN PVS::DL-COMPOSEB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "SEQ")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-COMPOSEB. 
Defining DL-COMPOSEB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-COMPOSED-LMBD
;     (DEFUN PVS::DL-COMPOSED-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "SEQ")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-COMPOSED. 
Defining DL-COMPOSED$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-CHOICEB-LMBD
;     (DEFUN PVS::DL-CHOICEB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "UNION")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-CHOICEB. 
Defining DL-CHOICEB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-CHOICED-LMBD
;     (DEFUN PVS::DL-CHOICED-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "UNION")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-CHOICED. 
Defining DL-CHOICED$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-ITERATED-LMBD
;     (DEFUN PVS::DL-ITERATED-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "STAR")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-ITERATED. 
Defining DL-ITERATED$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-DIAMONDOR-LMBD
;     (DEFUN PVS::DL-DIAMONDOR-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS2 PVS:EXPR) "DLOR")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-DIAMONDOR. 
Defining DL-DIAMONDOR$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-TESTB-LMBD
;     (DEFUN PVS::DL-TESTB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "TEST")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-TESTB. 
Defining DL-TESTB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-TESTD-LMBD
;     (DEFUN PVS::DL-TESTD-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "TEST")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-TESTD. 
Defining DL-TESTD$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-DUALB-LMBD
;     (DEFUN PVS::DL-DUALB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "DUAL")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-DUALB. 
Defining DL-DUALB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-DUALD-LMBD
;     (DEFUN PVS::DL-DUALD-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "DUAL")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-DUALD. 
Defining DL-DUALD$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-TRUE-LMBD
;     (DEFUN PVS::DL-TRUE-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLBOOL")
;            (PVS:PS-EQ PVS:*TRUE* (PVS:ARGS1 PVS:EXPR))))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-TRUER. 
Defining DL-TRUER$. 
Defining DL-TRUEL. 
Defining DL-TRUEL$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-FALSE-LMBD
;     (DEFUN PVS::DL-FALSE-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLBOOL")
;            (PVS:PS-EQ PVS:*FALSE* (PVS:ARGS1 PVS:EXPR))))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-FALSER. 
Defining DL-FALSER$. 
Defining DL-FALSEL. 
Defining DL-FALSEL$. 
Defining DL-ANDR. 
Defining DL-ANDR$. 
Defining DL-ANDL. 
Defining DL-ANDL$. 
Defining DL-ORR. 
Defining DL-ORR$. 
Defining DL-ORL. 
Defining DL-ORL$. 
Defining DL-IMPLIESR. 
Defining DL-IMPLIESR$. 
Defining DL-IMPLIESL. 
Defining DL-IMPLIESL$. 
Defining DL-NOTR. 
Defining DL-NOTR$. 
Defining DL-NOTL. 
Defining DL-NOTL$. 
Defining DL-SKOLEM. 
Defining DL-SKOLEM$. 
Defining DL-INSTT. 
Defining DL-INSTT$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFSTEP DL-FORALLR
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLFORALL"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-FORALLR. 
Defining DL-FORALLR$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFSTEP DL-FORALLL
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLFORALL"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-FORALLL. 
Defining DL-FORALLL$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFSTEP DL-EXISTSR
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLEXISTS"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-EXISTSR. 
Defining DL-EXISTSR$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFSTEP DL-EXISTSL
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLEXISTS"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-EXISTSL. 
Defining DL-EXISTSL$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-EXISTSR-LMBD
;     (DEFUN PVS::DL-EXISTSR-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLEXISTSR"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-EXISTSRR. 
Defining DL-EXISTSRR$. 
Defining DL-EXISTSRL. 
Defining DL-EXISTSRL$. 
Defining DL-CASE. 
Defining DL-CASE$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFSTEP DL-AXIOM
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS:TC-EQ PVS:EXPR (CDR PVS::DLFEN1)))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-AXIOM. 
Defining DL-AXIOM$. 
Defining DL-WEAK. 
Defining DL-WEAK$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-ALLRUNS-LMBD
;     (DEFUN PVS::DL-ALLRUNS-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-MONOB. 
Defining DL-MONOB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-SOMERUNS-LMBD
;     (DEFUN PVS::DL-SOMERUNS-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-MONOD. 
Defining DL-MONOD$. 
Defining DL-LOOP. 
Defining DL-LOOP$. 
Defining DL-ANDB. 
Defining DL-ANDB$. 
Defining DL-ORB. 
Defining DL-ORB$. 
Defining DL-GHOST. 
Defining DL-GHOST$. 
Defining DL-DIFFINIT. 
Defining DL-DIFFINIT$. 
Defining DL-DIFFCASE. 
Defining DL-DIFFCASE$. 
Defining DL-DERUP. 
Defining DL-DERUP$. 
Defining DL-DIFFRE. 
Defining DL-DIFFRE$. 
Defining PROVE-DERIVABLE_UP-GOAL. 
Defining PROVE-DERIVABLE_UP-GOAL$. 
Defining PROVE-DIFF_RE-GOAL. 
Defining PROVE-DIFF_RE-GOAL$. 
Defining PROVE-CONT_RE-GOAL. 
Defining PROVE-CONT_RE-GOAL$. 
Defining PROVE-FRESH_RE-GOAL. 
Defining PROVE-FRESH_RE-GOAL$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFSTEP PROVE-PREDICATE-ON-RE
;     (PVS::IS-TCC-GOAL?)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::IS-TCC-GOAL?
; 
; compilation unit finished
;   Undefined function:
;     IS-TCC-GOAL?
;   caught 1 STYLE-WARNING condition

Defining PROVE-PREDICATE-ON-RE. 
Defining PROVE-PREDICATE-ON-RE$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN IS-TCC-GOAL?
;     (DEFUN PVS::IS-TCC-GOAL? (&OPTIONAL (PVS::PS PVS:*PS*))
;       "Determines if PS is a goal generated from a TCC. PS default value is the current proofstate."
;       (TYPEP PVS:*PS* 'PVS::TCC-PROOFSTATE))
; 
; caught STYLE-WARNING:
;   The variable PS is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining ERROR. 
UNWIND-PROTECT exists as a defined rule from NIL.
Redefining UNWIND-PROTECT. 
UNWIND-PROTECT$ exists as a strategy from NIL.
Redefining UNWIND-PROTECT$. 
Defining WARNING. 
Defining WITH-VERBOSITY. 
Defining DL-DIFFWEAK. 
Defining DL-DIFFWEAK$. 
Defining DL-STEP-SIDE__. 
Defining DL-STEP-SIDE__$. 
Defining DL-FLATTENR__. 
Defining DL-FLATTENR__$. 
Defining DL-FLATTENL__. 
Defining DL-FLATTENL__$. 
Defining DL-FLATTEN. 
Defining DL-FLATTEN$. 
Defining DL-GROUND. 
Defining DL-GROUND$. 
Defining DL-SMT. 
Defining DL-SMT$. 
Defining DL-GRIND__. 
Defining DL-GRIND__$. 
Defining DL-GRIND. 
Defining DL-GRIND$. 
Defining DL-AUTO__. 
Defining DL-AUTO__$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFSTEP DL-ASSERT
;     (PVS::IS-DL-SEQ PVS::FN!)
; 
; caught WARNING:
;   undefined variable: PVS::FN!
; 
; compilation unit finished
;   Undefined variable:
;     FN!
;   caught 1 WARNING condition

Defining DL-ASSERT. 
Defining DL-ASSERT$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFHELPER MAKE-DLSEQ-GRINDABLE
;     (LAMBDA (PVS:EXPR PVS::SIDE) (PVS::EXPRS-GRINDABLE (LIST PVS:EXPR) NIL))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining MAKE-DLSEQ-GRINDABLE. 
Defining MAKE-DLSEQ-GRINDABLE$. 
Defining DL-HELP. 
Defining DL-FRESH-RE-CHECK. 
Defining BOOL-SA-CHECK. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-INSTF-LMBD
;     (DEFUN PVS::DL-INSTF-LMBD (PVS:EXPR PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLEXISTSRf"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-INSTF. 
Defining DL-INSTF$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-SUBF-LMBD
;     (DEFUN PVS::DL-SUBF-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "SUB"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-SUBF. 
Defining DL-SUBF$. 
Defining DL-INST. 
Defining DL-INST$. 
Defining DL-BOXD. 
Defining DL-BOXD$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-ITERATEB-LMBD
;     (DEFUN PVS::DL-ITERATEB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "STAR")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-ITERATEB. 
Defining DL-ITERATEB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-ITERATED-LMBD
;     (DEFUN PVS::DL-ITERATED-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "STAR")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

DL-ITERATED exists as a defined rule from NIL.
Redefining DL-ITERATED. 
DL-ITERATED$ exists as a strategy from NIL.
Redefining DL-ITERATED$. 
Defining DL-IFFR. 
Defining DL-IFFR$. 
Defining DL-IFFL. 
Defining DL-IFFL$. 
Defining DL-GB. 
Defining DL-GB$. 
Defining DL-GD. 
Defining DL-GD$. 
Defining DL-K. 
Defining DL-K$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-MB-LMBD
;     (DEFUN PVS::DL-MB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLIMPIES"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-MB. 
Defining DL-MB$. 
; file: //Users/cmunoz/src/PVS.gitlab/nasalib/dL//pvs-strategies
; in: DEFUN DL-MD-LMBD
;     (DEFUN PVS::DL-MD-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLIMPLIES"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Defining DL-MD. 
Defining DL-MD$. 
Defining DL-VB. 
Defining DL-VB$. 
Defining DL-VD. 
Defining DL-VD$. WARNING: redefining PVS::LOAD-OTHER-STRAT-FILES in DEFMACRO

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: LOAD-OTHER-STRAT-FILES "dl-diffghost.lisp"
;     (PVS::LOAD-OTHER-STRAT-FILES "dl-diffghost.lisp")
; --> HANDLER-CASE SB-INT:DX-FLET FLET 
; ==>
;   (#:FUN1 (PVS::C)
;    (DECLARE
;     (SB-C::SOURCE-FORM
;      (ERROR (PVS::C) (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE))))
;    (PROGN (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE)))
; 
; caught STYLE-WARNING:
;   The variable C is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

Should probably rename arg NAME in DL-DIFFGHOST: it appears in the body as a possible strategy

Should probably rename arg NAME in DL-DIFFGHOST: it appears in the body as a possible strategy

Should probably rename arg NAME in DL-DIFFGHOST: it appears in the body as a possible strategy

DL-DIFFGHOST exists as a defined rule from NIL.
Redefining DL-DIFFGHOST. 
DL-DIFFGHOST$ exists as a strategy from NIL.
Redefining DL-DIFFGHOST$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-diffghost.lisp
; in: DEFMETHOD DL-INDICES* (TUPLE-EXPR)
;     (LOOP PVS::FOR PVS:EXPR PVS::IN PVS:EXPRS
;           PVS::COLLECT (PVS::DL-INDICES* PVS:EXPR))
; --> LET SB-KERNEL:THE* 
; ==>
;   PVS:EXPRS
; 
; caught WARNING:
;   undefined variable: PVS:EXPRS
; 
; compilation unit finished
;   Undefined variable:
;     EXPRS
;   caught 1 WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: LOAD-OTHER-STRAT-FILES "dl-diffinv.lisp"
;     (PVS::LOAD-OTHER-STRAT-FILES "dl-diffinv.lisp")
; --> HANDLER-CASE SB-INT:DX-FLET FLET 
; ==>
;   (#:FUN1 (PVS::C)
;    (DECLARE
;     (SB-C::SOURCE-FORM
;      (ERROR (PVS::C) (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE))))
;    (PROGN (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE)))
; 
; caught STYLE-WARNING:
;   The variable C is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-diffinv.lisp
; in: DEFSTEP DL-DIFFINV
;     (FORMAT NIL "(~a)=nqb_to_be(~a)" PVS::BEXPR PVS::NNQB_)
; 
; caught WARNING:
;   undefined variable: PVS::NNQB_
; 
; compilation unit finished
;   Undefined variable:
;     NNQB_
;   caught 1 WARNING condition

DL-DIFFINV exists as a defined rule from NIL.
Redefining DL-DIFFINV. 
DL-DIFFINV$ exists as a strategy from NIL.
Redefining DL-DIFFINV$. 
DL-SUBDIFT__ exists as a defined rule from NIL.
Redefining DL-SUBDIFT__. 
DL-SUBDIFT__$ exists as a strategy from NIL.
Redefining DL-SUBDIFT__$. 
DL-SUBDDT__ exists as a defined rule from NIL.
Redefining DL-SUBDDT__. 
DL-SUBDDT__$ exists as a strategy from NIL.
Redefining DL-SUBDDT__$. 
DL-NQBOOLDER__ exists as a defined rule from NIL.
Redefining DL-NQBOOLDER__. 
DL-NQBOOLDER__$ exists as a strategy from NIL.
Redefining DL-NQBOOLDER__$. 
SIMPLIFY-DIFT_RE-EXPRESSION exists as a defined rule from NIL.
Redefining SIMPLIFY-DIFT_RE-EXPRESSION. 
SIMPLIFY-DIFT_RE-EXPRESSION$ exists as a strategy from NIL.
Redefining SIMPLIFY-DIFT_RE-EXPRESSION$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: LOAD-OTHER-STRAT-FILES "dl-solve.lisp"
;     (PVS::LOAD-OTHER-STRAT-FILES "dl-solve.lisp")
; --> HANDLER-CASE SB-INT:DX-FLET FLET 
; ==>
;   (#:FUN1 (PVS::C)
;    (DECLARE
;     (SB-C::SOURCE-FORM
;      (ERROR (PVS::C) (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE))))
;    (PROGN (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE)))
; 
; caught STYLE-WARNING:
;   The variable C is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

DL-CNSTLINS exists as a defined rule from NIL.
Redefining DL-CNSTLINS. 
DL-CNSTLINS$ exists as a strategy from NIL.
Redefining DL-CNSTLINS$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFSTEP BROKEN-DL-SOLVE
;     (PVS::FORM PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J

; in: DEFSTEP BROKEN-DL-SOLVE => DEFTACTIC SIMPLIFY_Y_SOL_EX
;     (PVS::ITE PVS::$AJ)
; 
; caught WARNING:
;   undefined variable: PVS::$AJ

; in: DEFSTEP BROKEN-DL-SOLVE => DEFTACTIC SIMPLIFY_EVALUABLE_ITES
;     (PVS::ITE PVS::$AJ)
; 
; caught WARNING:
;   undefined variable: PVS::$AJ
; 
; compilation unit finished
;   Undefined variables:
;     $1J $AJ
;   caught 3 WARNING conditions

BROKEN-DL-SOLVE exists as a defined rule from NIL.
Redefining BROKEN-DL-SOLVE. 
BROKEN-DL-SOLVE$ exists as a strategy from NIL.
Redefining BROKEN-DL-SOLVE$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFSTEP SIMPLIFY_NTH
;     (PVS::NTH-EXPR PVS::$AJ)
; 
; caught WARNING:
;   undefined variable: PVS::$AJ
; 
; compilation unit finished
;   Undefined variable:
;     $AJ
;   caught 1 WARNING condition

SIMPLIFY_NTH exists as a defined rule from NIL.
Redefining SIMPLIFY_NTH. 
SIMPLIFY_NTH$ exists as a strategy from NIL.
Redefining SIMPLIFY_NTH$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFSTEP DL-SOLVE
;     (PVS::EXTRA-GET-FNUM PVS::SOLUTION_LEMMA)
; 
; caught WARNING:
;   undefined variable: PVS::SOLUTION_LEMMA
; 
; caught WARNING:
;   undefined variable: PVS::SOLUTION_LEMMA

; in: DEFSTEP DL-SOLVE => DEFTACTIC SIMPLIFY_Y_SOL_EX
;     (PVS::EXTRA-GET-FNUM PVS::TAC-FNUM)
; 
; caught WARNING:
;   undefined variable: PVS::TAC-FNUM
; 
; compilation unit finished
;   Undefined variables:
;     SOLUTION_LEMMA TAC-FNUM
;   caught 3 WARNING conditions

DL-SOLVE exists as a defined rule from NIL.
Redefining DL-SOLVE. 
DL-SOLVE$ exists as a strategy from NIL.
Redefining DL-SOLVE$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFUN RESOLVE-SUB-RE
;     (ERROR "Unexpected arity for RealExpr ~a" PVS::RE)
; 
; caught WARNING:
;   undefined variable: PVS::RE
; 
; compilation unit finished
;   Undefined variable:
;     RE
;   caught 1 WARNING condition

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFHELPER DL-SIMPLIFY-ZIP-SOL
;     (PVS:ARGS1 PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J

;     (PVS:ARGS2 PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J
; 
; compilation unit finished
;   Undefined variable:
;     $1J
;   caught 2 WARNING conditions

DL-SIMPLIFY-ZIP-SOL exists as a defined rule from NIL.
Redefining DL-SIMPLIFY-ZIP-SOL. 
DL-SIMPLIFY-ZIP-SOL$ exists as a strategy from NIL.
Redefining DL-SIMPLIFY-ZIP-SOL$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-solve.lisp
; in: DEFHELPER DL-PP-ZIP-SOL
;     (PVS::ORIGINAL-FORMULA PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J
; 
; compilation unit finished
;   Undefined variable:
;     $1J
;   caught 1 WARNING condition

DL-PP-ZIP-SOL exists as a defined rule from NIL.
Redefining DL-PP-ZIP-SOL. 
DL-PP-ZIP-SOL$ exists as a strategy from NIL.
Redefining DL-PP-ZIP-SOL$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: LOAD-OTHER-STRAT-FILES "dl-pp.lisp"
;     (PVS::LOAD-OTHER-STRAT-FILES "dl-pp.lisp")
; --> HANDLER-CASE SB-INT:DX-FLET FLET 
; ==>
;   (#:FUN1 (PVS::C)
;    (DECLARE
;     (SB-C::SOURCE-FORM
;      (ERROR (PVS::C) (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE))))
;    (PROGN (FORMAT T "~&Error loading \"~a\".~%" PVS::FILE)))
; 
; caught STYLE-WARNING:
;   The variable C is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

DL-PP exists as a defined rule from NIL.
Redefining DL-PP. 
DL-PP$ exists as a strategy from NIL.
Redefining DL-PP$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/dl-pp.lisp
; in: DEFSTEP DL-PP-LIST-TO-LISTEXPR
;     (PVS::ORIGINAL-CONS PVS::$1J)
; 
; caught WARNING:
;   undefined variable: PVS::$1J

;     (PVS::ERROR-FORMAT-IF "Cannot transform ~a to a list-expr"
;                           PVS::ORIGINAL-PVS-LIST)
; --> IF PVS::SET-STRATEGY-ERRORS 
; ==>
;   (FORMAT NIL "Cannot transform ~a to a list-expr" PVS::ORIGINAL-PVS-LIST)
; 
; caught WARNING:
;   undefined variable: PVS::ORIGINAL-PVS-LIST
; 
; compilation unit finished
;   Undefined variables:
;     $1J ORIGINAL-PVS-LIST
;   caught 2 WARNING conditions

DL-PP-LIST-TO-LISTEXPR exists as a defined rule from NIL.
Redefining DL-PP-LIST-TO-LISTEXPR. 
DL-PP-LIST-TO-LISTEXPR$ exists as a strategy from NIL.
Redefining DL-PP-LIST-TO-LISTEXPR$. 
DL-UNROLL exists as a defined rule from NIL.
Redefining DL-UNROLL. 
DL-UNROLL$ exists as a strategy from NIL.
Redefining DL-UNROLL$. WARNING: redefining PVS::IS-NULL-PVSLIST in DEFUN
WARNING: redefining PVS::PVSLIST2LIST in DEFUN
WARNING: redefining PVS::PP-LIST in DEFUN
WARNING: redefining PVS::PP-LENGTH in DEFUN
WARNING: redefining PVS::PP-NTH in DEFUN
WARNING: redefining PVS::DL-FIND in DEFUN
WARNING: redefining PVS::DL-FNUMS-TO-KEEP in DEFUN
WARNING: redefining PVS::IS-DL-SEQ in DEFUN
WARNING: redefining PVS::DL-FNUM-SIDE in DEFUN
WARNING: redefining PVS::DL-FNUM in DEFUN
WARNING: redefining PVS::DLFNUM-INCR in DEFUN
WARNING: redefining PVS::|(DEFHELPER) DL-ISDLFNUM__| in DEFUN

DL-ISDLFNUM__ exists as a defined rule from NIL.
Redefining DL-ISDLFNUM__. 
DL-ISDLFNUM__$ exists as a strategy from NIL.
Redefining DL-ISDLFNUM__$. 
DL-MOVE__ exists as a defined rule from NIL.
Redefining DL-MOVE__. 
DL-MOVE__$ exists as a strategy from NIL.
Redefining DL-MOVE__$. WARNING: redefining PVS::|(defstep) DL-MOVE| in DEFUN

DL-MOVE exists as a defined rule from NIL.
Redefining DL-MOVE. 
DL-MOVE$ exists as a strategy from NIL.
Redefining DL-MOVE$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN ANYTERM-LMBD
;     (DEFUN PVS::ANYTERM-LMBD (PVS:EXPR PVS::SIDE) T)
; 
; caught STYLE-WARNING:
;   The variable EXPR is defined but never used.
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 2 STYLE-WARNING conditions
WARNING: redefining PVS::ANYTERM-LMBD in DEFUN

; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFSTEP DL-LEMMA__
;     `(PVS::! ,PVS::FN!
;       ,(IF (> PVS::DLFN 0)
;            1
;            2))
; 
; caught WARNING:
;   undefined variable: PVS::FN!

;     `(PVS::! ,PVS::FN!
;       ,(IF (> PVS::DLFN 0)
;            2
;            1)
;       2)
; 
; caught WARNING:
;   undefined variable: PVS::FN!

;     `(PVS::! ,PVS::FN!
;       ,(IF (> PVS::DLFN 0)
;            1
;            2))
; 
; caught WARNING:
;   undefined variable: PVS::FN!
; 
; compilation unit finished
;   Undefined variable:
;     FN!
;   caught 3 WARNING conditions
WARNING: redefining PVS::|(defstep) DL-LEMMA__| in DEFUN

DL-LEMMA__ exists as a defined rule from NIL.
Redefining DL-LEMMA__. 
DL-LEMMA__$ exists as a strategy from NIL.
Redefining DL-LEMMA__$. WARNING: redefining PVS::DL-GET-DLFNUMS in DEFUN
WARNING: redefining PVS::|(defstep) DL-HIDE| in DEFUN

DL-HIDE exists as a defined rule from NIL.
Redefining DL-HIDE. 
DL-HIDE$ exists as a strategy from NIL.
Redefining DL-HIDE$. WARNING: redefining PVS::|(defstep) DL-HIDEREST| in DEFUN

DL-HIDEREST exists as a defined rule from NIL.
Redefining DL-HIDEREST. 
DL-HIDEREST$ exists as a strategy from NIL.
Redefining DL-HIDEREST$. WARNING: redefining PVS::|(defstep) DL-SUBS| in DEFUN

DL-SUBS exists as a defined rule from NIL.
Redefining DL-SUBS. 
DL-SUBS$ exists as a strategy from NIL.
Redefining DL-SUBS$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-ANYB-LMBD
;     (DEFUN PVS::DL-ANYB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "ANY")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-ANYB-LMBD in DEFUN

DL-ANYB exists as a defined rule from NIL.
Redefining DL-ANYB. 
DL-ANYB$ exists as a strategy from NIL.
Redefining DL-ANYB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-ANYD-LMBD
;     (DEFUN PVS::DL-ANYD-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "ANY")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-ANYD-LMBD in DEFUN

DL-ANYD exists as a defined rule from NIL.
Redefining DL-ANYD. 
DL-ANYD$ exists as a strategy from NIL.
Redefining DL-ANYD$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-ASSIGNB-LMBD
;     (DEFUN PVS::DL-ASSIGNB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "ASSIGN")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-ASSIGNB-LMBD in DEFUN

DL-ASSIGNB exists as a defined rule from NIL.
Redefining DL-ASSIGNB. 
DL-ASSIGNB$ exists as a strategy from NIL.
Redefining DL-ASSIGNB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-ASSIGND-LMBD
;     (DEFUN PVS::DL-ASSIGND-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "ASSIGN")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-ASSIGND-LMBD in DEFUN

DL-ASSIGND exists as a defined rule from NIL.
Redefining DL-ASSIGND. 
DL-ASSIGND$ exists as a strategy from NIL.
Redefining DL-ASSIGND$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-COMPOSEB-LMBD
;     (DEFUN PVS::DL-COMPOSEB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "SEQ")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-COMPOSEB-LMBD in DEFUN

DL-COMPOSEB exists as a defined rule from NIL.
Redefining DL-COMPOSEB. 
DL-COMPOSEB$ exists as a strategy from NIL.
Redefining DL-COMPOSEB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-COMPOSED-LMBD
;     (DEFUN PVS::DL-COMPOSED-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "SEQ")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-COMPOSED-LMBD in DEFUN

DL-COMPOSED exists as a defined rule from NIL.
Redefining DL-COMPOSED. 
DL-COMPOSED$ exists as a strategy from NIL.
Redefining DL-COMPOSED$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-CHOICEB-LMBD
;     (DEFUN PVS::DL-CHOICEB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "UNION")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-CHOICEB-LMBD in DEFUN

DL-CHOICEB exists as a defined rule from NIL.
Redefining DL-CHOICEB. 
DL-CHOICEB$ exists as a strategy from NIL.
Redefining DL-CHOICEB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-CHOICED-LMBD
;     (DEFUN PVS::DL-CHOICED-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "UNION")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-CHOICED-LMBD in DEFUN

DL-CHOICED exists as a defined rule from NIL.
Redefining DL-CHOICED. 
DL-CHOICED$ exists as a strategy from NIL.
Redefining DL-CHOICED$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-ITERATED-LMBD
;     (DEFUN PVS::DL-ITERATED-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "STAR")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-ITERATED-LMBD in DEFUN

DL-ITERATED exists as a defined rule from NIL.
Redefining DL-ITERATED. 
DL-ITERATED$ exists as a strategy from NIL.
Redefining DL-ITERATED$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-DIAMONDOR-LMBD
;     (DEFUN PVS::DL-DIAMONDOR-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS2 PVS:EXPR) "DLOR")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-DIAMONDOR-LMBD in DEFUN

DL-DIAMONDOR exists as a defined rule from NIL.
Redefining DL-DIAMONDOR. 
DL-DIAMONDOR$ exists as a strategy from NIL.
Redefining DL-DIAMONDOR$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-TESTB-LMBD
;     (DEFUN PVS::DL-TESTB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "TEST")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-TESTB-LMBD in DEFUN

DL-TESTB exists as a defined rule from NIL.
Redefining DL-TESTB. 
DL-TESTB$ exists as a strategy from NIL.
Redefining DL-TESTB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-TESTD-LMBD
;     (DEFUN PVS::DL-TESTD-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "TEST")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-TESTD-LMBD in DEFUN

DL-TESTD exists as a defined rule from NIL.
Redefining DL-TESTD. 
DL-TESTD$ exists as a strategy from NIL.
Redefining DL-TESTD$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-DUALB-LMBD
;     (DEFUN PVS::DL-DUALB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "DUAL")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-DUALB-LMBD in DEFUN

DL-DUALB exists as a defined rule from NIL.
Redefining DL-DUALB. 
DL-DUALB$ exists as a strategy from NIL.
Redefining DL-DUALB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-DUALD-LMBD
;     (DEFUN PVS::DL-DUALD-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "DUAL")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-DUALD-LMBD in DEFUN

DL-DUALD exists as a defined rule from NIL.
Redefining DL-DUALD. 
DL-DUALD$ exists as a strategy from NIL.
Redefining DL-DUALD$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-TRUE-LMBD
;     (DEFUN PVS::DL-TRUE-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLBOOL")
;            (PVS:PS-EQ PVS:*TRUE* (PVS:ARGS1 PVS:EXPR))))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-TRUE-LMBD in DEFUN

DL-TRUER exists as a defined rule from NIL.
Redefining DL-TRUER. 
DL-TRUER$ exists as a strategy from NIL.
Redefining DL-TRUER$. 
DL-TRUEL exists as a defined rule from NIL.
Redefining DL-TRUEL. 
DL-TRUEL$ exists as a strategy from NIL.
Redefining DL-TRUEL$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-FALSE-LMBD
;     (DEFUN PVS::DL-FALSE-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLBOOL")
;            (PVS:PS-EQ PVS:*FALSE* (PVS:ARGS1 PVS:EXPR))))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-FALSE-LMBD in DEFUN

DL-FALSER exists as a defined rule from NIL.
Redefining DL-FALSER. 
DL-FALSER$ exists as a strategy from NIL.
Redefining DL-FALSER$. 
DL-FALSEL exists as a defined rule from NIL.
Redefining DL-FALSEL. 
DL-FALSEL$ exists as a strategy from NIL.
Redefining DL-FALSEL$. WARNING: redefining PVS::|(defstep) DL-ANDR| in DEFUN

DL-ANDR exists as a defined rule from NIL.
Redefining DL-ANDR. 
DL-ANDR$ exists as a strategy from NIL.
Redefining DL-ANDR$. WARNING: redefining PVS::|(defstep) DL-ANDL| in DEFUN

DL-ANDL exists as a defined rule from NIL.
Redefining DL-ANDL. 
DL-ANDL$ exists as a strategy from NIL.
Redefining DL-ANDL$. WARNING: redefining PVS::|(defstep) DL-ORR| in DEFUN

DL-ORR exists as a defined rule from NIL.
Redefining DL-ORR. 
DL-ORR$ exists as a strategy from NIL.
Redefining DL-ORR$. WARNING: redefining PVS::|(defstep) DL-ORL| in DEFUN

DL-ORL exists as a defined rule from NIL.
Redefining DL-ORL. 
DL-ORL$ exists as a strategy from NIL.
Redefining DL-ORL$. WARNING: redefining PVS::|(defstep) DL-IMPLIESR| in DEFUN

DL-IMPLIESR exists as a defined rule from NIL.
Redefining DL-IMPLIESR. 
DL-IMPLIESR$ exists as a strategy from NIL.
Redefining DL-IMPLIESR$. WARNING: redefining PVS::|(defstep) DL-IMPLIESL| in DEFUN

DL-IMPLIESL exists as a defined rule from NIL.
Redefining DL-IMPLIESL. 
DL-IMPLIESL$ exists as a strategy from NIL.
Redefining DL-IMPLIESL$. WARNING: redefining PVS::|(defstep) DL-NOTR| in DEFUN

DL-NOTR exists as a defined rule from NIL.
Redefining DL-NOTR. 
DL-NOTR$ exists as a strategy from NIL.
Redefining DL-NOTR$. WARNING: redefining PVS::|(defstep) DL-NOTL| in DEFUN

DL-NOTL exists as a defined rule from NIL.
Redefining DL-NOTL. 
DL-NOTL$ exists as a strategy from NIL.
Redefining DL-NOTL$. WARNING: redefining PVS::DL-SKOLEM-LMBD in DEFUN
WARNING: redefining PVS::|(defstep) DL-SKOLEM| in DEFUN

DL-SKOLEM exists as a defined rule from NIL.
Redefining DL-SKOLEM. 
DL-SKOLEM$ exists as a strategy from NIL.
Redefining DL-SKOLEM$. WARNING: redefining PVS::DL-INST-LMBD in DEFUN
WARNING: redefining PVS::|(defstep) DL-INSTT| in DEFUN

DL-INSTT exists as a defined rule from NIL.
Redefining DL-INSTT. 
DL-INSTT$ exists as a strategy from NIL.
Redefining DL-INSTT$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFSTEP DL-FORALLR
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLFORALL"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::|(defstep) DL-FORALLR| in DEFUN

DL-FORALLR exists as a defined rule from NIL.
Redefining DL-FORALLR. 
DL-FORALLR$ exists as a strategy from NIL.
Redefining DL-FORALLR$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFSTEP DL-FORALLL
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLFORALL"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::|(defstep) DL-FORALLL| in DEFUN

DL-FORALLL exists as a defined rule from NIL.
Redefining DL-FORALLL. 
DL-FORALLL$ exists as a strategy from NIL.
Redefining DL-FORALLL$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFSTEP DL-EXISTSR
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLEXISTS"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::|(defstep) DL-EXISTSR| in DEFUN

DL-EXISTSR exists as a defined rule from NIL.
Redefining DL-EXISTSR. 
DL-EXISTSR$ exists as a strategy from NIL.
Redefining DL-EXISTSR$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFSTEP DL-EXISTSL
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLEXISTS"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::|(defstep) DL-EXISTSL| in DEFUN

DL-EXISTSL exists as a defined rule from NIL.
Redefining DL-EXISTSL. 
DL-EXISTSL$ exists as a strategy from NIL.
Redefining DL-EXISTSL$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-EXISTSR-LMBD
;     (DEFUN PVS::DL-EXISTSR-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLEXISTSR"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-EXISTSR-LMBD in DEFUN
WARNING: redefining PVS::|(defstep) DL-EXISTSRR| in DEFUN

DL-EXISTSRR exists as a defined rule from NIL.
Redefining DL-EXISTSRR. 
DL-EXISTSRR$ exists as a strategy from NIL.
Redefining DL-EXISTSRR$. WARNING: redefining PVS::|(defstep) DL-EXISTSRL| in DEFUN

DL-EXISTSRL exists as a defined rule from NIL.
Redefining DL-EXISTSRL. 
DL-EXISTSRL$ exists as a strategy from NIL.
Redefining DL-EXISTSRL$. WARNING: redefining PVS::|(defstep) DL-CASE| in DEFUN

DL-CASE exists as a defined rule from NIL.
Redefining DL-CASE. 
DL-CASE$ exists as a strategy from NIL.
Redefining DL-CASE$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFSTEP DL-AXIOM
;     #'(LAMBDA (PVS:EXPR PVS::SIDE) (PVS:TC-EQ PVS:EXPR (CDR PVS::DLFEN1)))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::|(defstep) DL-AXIOM| in DEFUN

DL-AXIOM exists as a defined rule from NIL.
Redefining DL-AXIOM. 
DL-AXIOM$ exists as a strategy from NIL.
Redefining DL-AXIOM$. WARNING: redefining PVS::|(defstep) DL-WEAK| in DEFUN

DL-WEAK exists as a defined rule from NIL.
Redefining DL-WEAK. 
DL-WEAK$ exists as a strategy from NIL.
Redefining DL-WEAK$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-ALLRUNS-LMBD
;     (DEFUN PVS::DL-ALLRUNS-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-ALLRUNS-LMBD in DEFUN
WARNING: redefining PVS::|(defstep) DL-MONOB| in DEFUN

DL-MONOB exists as a defined rule from NIL.
Redefining DL-MONOB. 
DL-MONOB$ exists as a strategy from NIL.
Redefining DL-MONOB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-SOMERUNS-LMBD
;     (DEFUN PVS::DL-SOMERUNS-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-SOMERUNS-LMBD in DEFUN
WARNING: redefining PVS::|(defstep) DL-MONOD| in DEFUN

DL-MONOD exists as a defined rule from NIL.
Redefining DL-MONOD. 
DL-MONOD$ exists as a strategy from NIL.
Redefining DL-MONOD$. WARNING: redefining PVS::DL-LOOP-LMBD in DEFUN
WARNING: redefining PVS::|(defstep) DL-LOOP| in DEFUN

DL-LOOP exists as a defined rule from NIL.
Redefining DL-LOOP. 
DL-LOOP$ exists as a strategy from NIL.
Redefining DL-LOOP$. WARNING: redefining PVS::DL-ANDB-LMBD in DEFUN

DL-ANDB exists as a defined rule from NIL.
Redefining DL-ANDB. 
DL-ANDB$ exists as a strategy from NIL.
Redefining DL-ANDB$. WARNING: redefining PVS::DL-ORB-LMBD in DEFUN

DL-ORB exists as a defined rule from NIL.
Redefining DL-ORB. 
DL-ORB$ exists as a strategy from NIL.
Redefining DL-ORB$. WARNING: redefining PVS::|(defstep) DL-GHOST| in DEFUN

DL-GHOST exists as a defined rule from NIL.
Redefining DL-GHOST. 
DL-GHOST$ exists as a strategy from NIL.
Redefining DL-GHOST$. WARNING: redefining PVS::DL-DIFF-LMBD in DEFUN

DL-DIFFINIT exists as a defined rule from NIL.
Redefining DL-DIFFINIT. 
DL-DIFFINIT$ exists as a strategy from NIL.
Redefining DL-DIFFINIT$. WARNING: redefining PVS::|(defstep) DL-DIFFCASE| in DEFUN

DL-DIFFCASE exists as a defined rule from NIL.
Redefining DL-DIFFCASE. 
DL-DIFFCASE$ exists as a strategy from NIL.
Redefining DL-DIFFCASE$. WARNING: redefining PVS::|(defstep) DL-DERUP| in DEFUN

DL-DERUP exists as a defined rule from NIL.
Redefining DL-DERUP. 
DL-DERUP$ exists as a strategy from NIL.
Redefining DL-DERUP$. WARNING: redefining PVS::|(defstep) DL-DIFFRE| in DEFUN

DL-DIFFRE exists as a defined rule from NIL.
Redefining DL-DIFFRE. 
DL-DIFFRE$ exists as a strategy from NIL.
Redefining DL-DIFFRE$. WARNING: redefining PVS::|(defstep) PROVE-DERIVABLE_UP-GOAL| in DEFUN

PROVE-DERIVABLE_UP-GOAL exists as a defined rule from NIL.
Redefining PROVE-DERIVABLE_UP-GOAL. 
PROVE-DERIVABLE_UP-GOAL$ exists as a strategy from NIL.
Redefining PROVE-DERIVABLE_UP-GOAL$. WARNING: redefining PVS::|(defstep) PROVE-DIFF_RE-GOAL| in DEFUN

PROVE-DIFF_RE-GOAL exists as a defined rule from NIL.
Redefining PROVE-DIFF_RE-GOAL. 
PROVE-DIFF_RE-GOAL$ exists as a strategy from NIL.
Redefining PROVE-DIFF_RE-GOAL$. 
PROVE-CONT_RE-GOAL exists as a defined rule from NIL.
Redefining PROVE-CONT_RE-GOAL. 
PROVE-CONT_RE-GOAL$ exists as a strategy from NIL.
Redefining PROVE-CONT_RE-GOAL$. WARNING: redefining PVS::|(defstep) PROVE-FRESH_RE-GOAL| in DEFUN

PROVE-FRESH_RE-GOAL exists as a defined rule from NIL.
Redefining PROVE-FRESH_RE-GOAL. 
PROVE-FRESH_RE-GOAL$ exists as a strategy from NIL.
Redefining PROVE-FRESH_RE-GOAL$. WARNING: redefining PVS::|(defstep) PROVE-PREDICATE-ON-RE| in DEFUN

PROVE-PREDICATE-ON-RE exists as a defined rule from NIL.
Redefining PROVE-PREDICATE-ON-RE. 
PROVE-PREDICATE-ON-RE$ exists as a strategy from NIL.
Redefining PROVE-PREDICATE-ON-RE$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN IS-TCC-GOAL?
;     (DEFUN PVS::IS-TCC-GOAL? (&OPTIONAL (PVS::PS PVS:*PS*))
;       "Determines if PS is a goal generated from a TCC. PS default value is the current proofstate."
;       (TYPEP PVS:*PS* 'PVS::TCC-PROOFSTATE))
; 
; caught STYLE-WARNING:
;   The variable PS is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::IS-TCC-GOAL? in DEFUN

ERROR exists as a strategy from NIL.
Redefining ERROR. 
UNWIND-PROTECT exists as a defined rule from NIL.
Redefining UNWIND-PROTECT. 
UNWIND-PROTECT$ exists as a strategy from NIL.
Redefining UNWIND-PROTECT$. 
WARNING exists as a strategy from NIL.
Redefining WARNING. 
WITH-VERBOSITY exists as a strategy from NIL.
Redefining WITH-VERBOSITY. WARNING: redefining PVS::DL-TRANSLATE-REL in DEFUN
WARNING: redefining PVS::DL-TRANSLATE2NQB in DEFUN

DL-DIFFWEAK exists as a defined rule from NIL.
Redefining DL-DIFFWEAK. 
DL-DIFFWEAK$ exists as a strategy from NIL.
Redefining DL-DIFFWEAK$. WARNING: redefining PVS::|(DEFHELPER) DL-STEP-SIDE__| in DEFUN

DL-STEP-SIDE__ exists as a defined rule from NIL.
Redefining DL-STEP-SIDE__. 
DL-STEP-SIDE__$ exists as a strategy from NIL.
Redefining DL-STEP-SIDE__$. 
DL-FLATTENR__ exists as a defined rule from NIL.
Redefining DL-FLATTENR__. 
DL-FLATTENR__$ exists as a strategy from NIL.
Redefining DL-FLATTENR__$. 
DL-FLATTENL__ exists as a defined rule from NIL.
Redefining DL-FLATTENL__. 
DL-FLATTENL__$ exists as a strategy from NIL.
Redefining DL-FLATTENL__$. WARNING: redefining PVS::|(defstep) DL-FLATTEN| in DEFUN

DL-FLATTEN exists as a defined rule from NIL.
Redefining DL-FLATTEN. 
DL-FLATTEN$ exists as a strategy from NIL.
Redefining DL-FLATTEN$. WARNING: redefining PVS::|(defstep) DL-GROUND| in DEFUN

DL-GROUND exists as a defined rule from NIL.
Redefining DL-GROUND. 
DL-GROUND$ exists as a strategy from NIL.
Redefining DL-GROUND$. WARNING: redefining PVS::EXPRS-GRINDABLE in DEFUN
WARNING: redefining PVS::IS-DLSEQ-GRINDABLE in DEFUN

DL-SMT exists as a defined rule from NIL.
Redefining DL-SMT. 
DL-SMT$ exists as a strategy from NIL.
Redefining DL-SMT$. WARNING: redefining PVS::|(DEFHELPER) DL-GRIND__| in DEFUN

DL-GRIND__ exists as a defined rule from NIL.
Redefining DL-GRIND__. 
DL-GRIND__$ exists as a strategy from NIL.
Redefining DL-GRIND__$. WARNING: redefining PVS::|(defstep) DL-GRIND| in DEFUN

DL-GRIND exists as a defined rule from NIL.
Redefining DL-GRIND. 
DL-GRIND$ exists as a strategy from NIL.
Redefining DL-GRIND$. WARNING: redefining PVS::|(defstep) DL-AUTO__| in DEFUN

DL-AUTO__ exists as a defined rule from NIL.
Redefining DL-AUTO__. 
DL-AUTO__$ exists as a strategy from NIL.
Redefining DL-AUTO__$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFSTEP DL-ASSERT
;     (PVS::IS-DL-SEQ PVS::FN!)
; 
; caught WARNING:
;   undefined variable: PVS::FN!
; 
; compilation unit finished
;   Undefined variable:
;     FN!
;   caught 1 WARNING condition
WARNING: redefining PVS::|(defstep) DL-ASSERT| in DEFUN

DL-ASSERT exists as a defined rule from NIL.
Redefining DL-ASSERT. 
DL-ASSERT$ exists as a strategy from NIL.
Redefining DL-ASSERT$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFHELPER MAKE-DLSEQ-GRINDABLE
;     (LAMBDA (PVS:EXPR PVS::SIDE) (PVS::EXPRS-GRINDABLE (LIST PVS:EXPR) NIL))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::|(DEFHELPER) MAKE-DLSEQ-GRINDABLE| in DEFUN

MAKE-DLSEQ-GRINDABLE exists as a defined rule from NIL.
Redefining MAKE-DLSEQ-GRINDABLE. 
MAKE-DLSEQ-GRINDABLE$ exists as a strategy from NIL.
Redefining MAKE-DLSEQ-GRINDABLE$. WARNING: redefining PVS::DL-STRHELP-REC in DEFUN
WARNING: redefining PVS::DL-STRHELP in DEFUN

DL-HELP exists as a strategy from NIL.
Redefining DL-HELP. 
DL-FRESH-RE-CHECK exists as a strategy from NIL.
Redefining DL-FRESH-RE-CHECK. 
BOOL-SA-CHECK exists as a strategy from NIL.
Redefining BOOL-SA-CHECK. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-INSTF-LMBD
;     (DEFUN PVS::DL-INSTF-LMBD (PVS:EXPR PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLEXISTSRf"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-INSTF-LMBD in DEFUN
WARNING: redefining PVS::|(defstep) DL-INSTF| in DEFUN

DL-INSTF exists as a defined rule from NIL.
Redefining DL-INSTF. 
DL-INSTF$ exists as a strategy from NIL.
Redefining DL-INSTF$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-SUBF-LMBD
;     (DEFUN PVS::DL-SUBF-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "SUB"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-SUBF-LMBD in DEFUN

DL-SUBF exists as a defined rule from NIL.
Redefining DL-SUBF. 
DL-SUBF$ exists as a strategy from NIL.
Redefining DL-SUBF$. 
DL-INST exists as a defined rule from NIL.
Redefining DL-INST. 
DL-INST$ exists as a strategy from NIL.
Redefining DL-INST$. 
DL-BOXD exists as a defined rule from NIL.
Redefining DL-BOXD. 
DL-BOXD$ exists as a strategy from NIL.
Redefining DL-BOXD$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-ITERATEB-LMBD
;     (DEFUN PVS::DL-ITERATEB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "ALLRUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "STAR")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-ITERATEB-LMBD in DEFUN

DL-ITERATEB exists as a defined rule from NIL.
Redefining DL-ITERATEB. 
DL-ITERATEB$ exists as a strategy from NIL.
Redefining DL-ITERATEB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-ITERATED-LMBD
;     (DEFUN PVS::DL-ITERATED-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (AND (PVS::IS-FUNCTION-EXPR PVS:EXPR "SOMERUNS")
;            (PVS::IS-FUNCTION-EXPR (PVS:ARGS1 PVS:EXPR) "STAR")))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition

DL-ITERATED exists as a defined rule from NIL.
Redefining DL-ITERATED. 
DL-ITERATED$ exists as a strategy from NIL.
Redefining DL-ITERATED$. WARNING: redefining PVS::|(defstep) DL-IFFR| in DEFUN

DL-IFFR exists as a defined rule from NIL.
Redefining DL-IFFR. 
DL-IFFR$ exists as a strategy from NIL.
Redefining DL-IFFR$. WARNING: redefining PVS::|(defstep) DL-IFFL| in DEFUN

DL-IFFL exists as a defined rule from NIL.
Redefining DL-IFFL. 
DL-IFFL$ exists as a strategy from NIL.
Redefining DL-IFFL$. 
DL-GB exists as a defined rule from NIL.
Redefining DL-GB. 
DL-GB$ exists as a strategy from NIL.
Redefining DL-GB$. 
DL-GD exists as a defined rule from NIL.
Redefining DL-GD. 
DL-GD$ exists as a strategy from NIL.
Redefining DL-GD$. 
DL-K exists as a defined rule from NIL.
Redefining DL-K. 
DL-K$ exists as a strategy from NIL.
Redefining DL-K$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-MB-LMBD
;     (DEFUN PVS::DL-MB-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLIMPIES"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-MB-LMBD in DEFUN

DL-MB exists as a defined rule from NIL.
Redefining DL-MB. 
DL-MB$ exists as a strategy from NIL.
Redefining DL-MB$. 
; file: /Users/cmunoz/src/PVS.gitlab/nasalib/dL/pvs-strategies
; in: DEFUN DL-MD-LMBD
;     (DEFUN PVS::DL-MD-LMBD (PVS:EXPR &OPTIONAL PVS::SIDE)
;       (PVS::IS-FUNCTION-EXPR PVS:EXPR "DLIMPLIES"))
; 
; caught STYLE-WARNING:
;   The variable SIDE is defined but never used.
; 
; compilation unit finished
;   caught 1 STYLE-WARNING condition
WARNING: redefining PVS::DL-MD-LMBD in DEFUN

DL-MD exists as a defined rule from NIL.
Redefining DL-MD. 
DL-MD$ exists as a strategy from NIL.
Redefining DL-MD$. 
DL-VB exists as a defined rule from NIL.
Redefining DL-VB. 
DL-VB$ exists as a strategy from NIL.
Redefining DL-VB$. 
DL-VD exists as a defined rule from NIL.
Redefining DL-VD. 
DL-VD$ exists as a strategy from NIL.
Redefining DL-VD$. 
Proving theory top
Proving theory hp_def
dlvar_inj has no proof
dlvar_eq has no proof
Rerunning proof of hp_def.mapexpr_inj_TCC1
hp_def.mapexpr_inj_TCC1 proved in 0.17 real, 0.17 cpu seconds
Rerunning proof of hp_def.mapexpr_inj_TCC2
hp_def.mapexpr_inj_TCC2 proved in 0.10 real, 0.10 cpu seconds
Rerunning proof of hp_def.mapexpr_inj_cons
hp_def.mapexpr_inj_cons proved in 0.24 real, 0.24 cpu seconds
Rerunning proof of hp_def.mapexpr_inj_eq
hp_def.mapexpr_inj_eq proved in 0.16 real, 0.16 cpu seconds
mapexpr_inj_eq_index has no proof
Rerunning proof of hp_def.null_MapExprInj
hp_def.null_MapExprInj proved in 0.13 real, 0.13 cpu seconds
Rerunning proof of hp_def.cdr_is_MapExprInj
hp_def.cdr_is_MapExprInj proved in 0.18 real, 0.18 cpu seconds
Rerunning proof of hp_def.sub_mapexpr_inj_is_mapexpr_inj
hp_def.sub_mapexpr_inj_is_mapexpr_inj proved in 0.18 real, 0.18 cpu seconds
Rerunning proof of hp_def.in_map_cons
***Warning: in_map_cons.1.1.1 has fewer subproofs (0) than subgoals (1)
***Warning: in_map_cons.1.2 has fewer subproofs (0) than subgoals (1)
hp_def.in_map_cons unproved in 0.22 real, 0.22 cpu seconds
Rerunning proof of hp_def.in_map_null_false
hp_def.in_map_null_false proved in 0.05 real, 0.05 cpu seconds
Rerunning proof of hp_def.not_in_map_null
hp_def.not_in_map_null proved in 0.07 real, 0.07 cpu seconds
Rerunning proof of hp_def.index_of_j
***Warning: index_of_j.1 has fewer subproofs (0) than subgoals (1)
hp_def.index_of_j unproved in 0.09 real, 0.09 cpu seconds
Rerunning proof of hp_def.expr_car_TCC1
hp_def.expr_car_TCC1 proved in 0.08 real, 0.08 cpu seconds
Rerunning proof of hp_def.expr_car
second argument to index_of has the wrong type
     Found: dLVar
  Expected: (in_map(me))
   second argument is (mapexpr`1)
Restoring the state.
hp_def.expr_car unproved in 0.06 real, 0.06 cpu seconds
Rerunning proof of hp_def.expr_not_car_TCC1
hp_def.expr_not_car_TCC1 proved in 0.13 real, 0.13 cpu seconds
Rerunning proof of hp_def.expr_not_car
***Warning: expr_not_car.2.2.1 has fewer subproofs (0) than subgoals (1)
hp_def.expr_not_car unproved in 0.25 real, 0.25 cpu seconds
same_var_eq has no proof
Rerunning proof of hp_def.distinct_var?_TCC1
hp_def.distinct_var?_TCC1 proved in 0.04 real, 0.04 cpu seconds
Rerunning proof of hp_def.distinct_var?_TCC2
hp_def.distinct_var?_TCC2 proved in 0.07 real, 0.07 cpu seconds
Rerunning proof of hp_def.distinct_var?_TCC3
***Warning: distinct_var?_TCC3 has fewer subproofs (0) than subgoals (6)
hp_def.distinct_var?_TCC3 unproved in 0.21 real, 0.21 cpu seconds

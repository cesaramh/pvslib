
Setting tmp dir to value of environment variable TMPDIR:
  /var/folders/c5/_vh2p4714fggt43wwpxsvmlh0000gp/T/

; file: /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/MetiTarski/metit.lisp
; in: DEFUN TRANSLATE-TO-METITARSKI-GLOBAL-VARIABLE
;     (PVS::METIT-ID-NAME "V")
; 
; caught STYLE-WARNING:
;   undefined function: PVS::METIT-ID-NAME
; 
; compilation unit finished
;   Undefined function:
;     METIT-ID-NAME
;   caught 1 STYLE-WARNING condition

; file: /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/MetiTarski/metit.lisp
; in: DEFMETHOD TRANSLATE-TO-METITARSKI* (NAME-EXPR T)
;     (PVS::METIT-INTERPRETATION PVS:EXPR)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::METIT-INTERPRETATION
; 
; compilation unit finished
;   Undefined function:
;     METIT-INTERPRETATION
;   caught 1 STYLE-WARNING condition

; file: /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/MetiTarski/metit.lisp
; in: DEFMETHOD TRANSLATE-TO-METITARSKI* (APPLICATION T)
;     (PVS::METIT-INTERPRETATION PVS:OPERATOR)
; 
; caught STYLE-WARNING:
;   undefined function: PVS::METIT-INTERPRETATION
; 
; compilation unit finished
;   Undefined function:
;     METIT-INTERPRETATION
;   caught 1 STYLE-WARNING condition

Defining METIT. 
*** 
*** Processing exact_real_arith (1:30:49 6/16/2023)
*** Generated by proveit 7.1.0 (Nov 05, 2020)
*** 
Context changed to /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/exact_real_arith/
Parsing top
top parsed in 0.00 seconds
Typechecking top
Parsing prelude_aux
prelude_aux parsed in 0.02 seconds
prelude_aux is already parsed
Typechecking prelude_aux
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/reals/pvsbin/sqrt_exists.bin in 0.24s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/reals/pvsbin/sq.bin in 0.08s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/reals/pvsbin/sign.bin in 0.06s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/reals/pvsbin/sqrt.bin in 0.06s (load part took 0.00s)
Parsing ln_exp
ln_exp parsed in 0.01 seconds
ln_exp is already parsed
Typechecking ln_exp
Parsing integral
integral parsed in 0.02 seconds
integral is already parsed
Typechecking integral
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/deriv_domain_def.bin in 0.04s (load part took 0.00s)
Parsing integral_def
integral_def parsed in 0.04 seconds
integral_def is already parsed
Typechecking integral_def
Parsing finite_sets_minmax
finite_sets_minmax parsed in 0.03 seconds
finite_sets_minmax is already parsed
Typechecking finite_sets_minmax
Parsing finite_sets_inductions
finite_sets_inductions parsed in 0.00 seconds
finite_sets_inductions is already parsed
Typechecking finite_sets_inductions
finite_sets_inductions typechecked in 0.06s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
finite_sets_minmax typechecked in 0.11s: 4 TCCs, 0 proved, 1 subsumed, 3 unproved
Parsing intervals_real
intervals_real parsed in 0.00 seconds
intervals_real is already parsed
Typechecking intervals_real
intervals_real typechecked in 0.01s: No TCCs generated

 LET/WHERE variable N at line 38, col 24 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 38, col 40 is given type
  [below[fs`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable xx at line 43, col 17 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable N at line 43, col 30 is given type
  nat from its value expression.


 In declaration width_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration width_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable xx at line 87, col 31 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable N at line 87, col 44 is given type
  nat from its value expression.

Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/reals/pvsbin/sigma.bin in 0.12s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/reals/pvsbin/sigma_below.bin in 0.06s (load part took 0.00s)
Parsing sigma_upto
sigma_upto parsed in 0.01 seconds
sigma_upto is already parsed
Typechecking sigma_upto
sigma_upto typechecked in 0.12s: 11 TCCs, 0 proved, 3 subsumed, 8 unproved

 In declaration xis?:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration xis?:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration xis_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration xis_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable N at line 121, col 22 is given type
  int from its value expression.


 In declaration Rie_sum:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration Rie_sum:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable N at line 134, col 22 is given type
  int from its value expression.


 LET/WHERE variable N at line 144, col 39 is given type
  int from its value expression.


 In declaration pick_one:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration pick_one:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration pick_one:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration pick_one:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration gen_xis:
  added conversion finseq_appl[real]
             
  to (# length := length(P) - 1, seq := pick_one(a, b, P) #), converting
     fs: finseq[real]
  to [below[length(fs)] -> real]


 LET/WHERE variable N at line 180, col 30 is given type
  int from its value expression.


 LET/WHERE variable EP at line 181, col 30 is given type
  partition(a, b) from its value expression.

integral_def typechecked in 2.722s: 66 TCCs, 0 proved, 17 subsumed, 49 unproved; 13 conversions; 11 msgs
Parsing integral_cont
integral_cont parsed in 0.00 seconds
integral_cont is already parsed
Typechecking integral_cont
Parsing integral_cont_scaf
integral_cont_scaf parsed in 0.00 seconds
integral_cont_scaf is already parsed
Typechecking integral_cont_scaf
Parsing integral_prep
integral_prep parsed in 0.00 seconds
integral_prep is already parsed
Typechecking integral_prep
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/reals/pvsbin/real_fun_ops.bin in 0.03s (load part took 0.00s)
Parsing continuous_functions
continuous_functions parsed in 0.02 seconds
continuous_functions is already parsed
Typechecking continuous_functions
Parsing lim_of_functions
lim_of_functions parsed in 0.05 seconds
lim_of_functions is already parsed
Typechecking lim_of_functions
Parsing convergence_functions
convergence_functions parsed in 0.00 seconds
convergence_functions is already parsed
Typechecking convergence_functions
Parsing epsilon_lemmas
epsilon_lemmas parsed in 0.00 seconds
epsilon_lemmas is already parsed
Typechecking epsilon_lemmas
Parsing real_facts
real_facts parsed in 0.00 seconds
real_facts is already parsed
Typechecking real_facts
real_facts typechecked in 0.17s: 4 TCCs, 0 proved, 1 subsumed, 3 unproved
Parsing abs_lems
abs_lems parsed in 0.01 seconds
abs_lems is already parsed
Typechecking abs_lems
Parsing root
root parsed in 0.00 seconds
root is already parsed
Typechecking root
root typechecked in 0.17s: 16 TCCs, 0 proved, 4 subsumed, 12 unproved
abs_lems typechecked in 0.47s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
epsilon_lemmas typechecked in 1.60s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
convergence_functions typechecked in 1.74s: No TCCs generated

 In declaration cv_abs:
  added conversion restrict[real, T, real]
             
  to abs, converting
     [real -> real]
  to [T -> real]

lim_of_functions typechecked in 2.019s: 10 TCCs, 0 proved, 0 subsumed, 10 unproved; 1 conversion

 In declaration continuous_on_def:
  added conversion extend[real, T, bool, FALSE]
             
  to E, converting
     [T -> bool]
  to [real -> bool]


 In declaration continuous_def2:
  added conversion restrict[real, T, boolean]
             
  to T_pred, converting
     [real -> boolean]
  to [T -> boolean]

continuous_functions typechecked in 2.233s: 11 TCCs, 0 proved, 0 subsumed, 11 unproved; 2 conversions; 1 warning
Parsing convergence_sequences
convergence_sequences parsed in 0.00 seconds
convergence_sequences is already parsed
Typechecking convergence_sequences
Parsing sequence_props
sequence_props parsed in 0.00 seconds
sequence_props is already parsed
Typechecking sequence_props
Parsing real_fun_supinf
real_fun_supinf parsed in 0.00 seconds
real_fun_supinf is already parsed
Typechecking real_fun_supinf
Parsing real_fun_props
real_fun_props parsed in 0.00 seconds
real_fun_props is already parsed
Typechecking real_fun_props
Parsing real_fun_preds
real_fun_preds parsed in 0.00 seconds
real_fun_preds is already parsed
Typechecking real_fun_preds
real_fun_preds typechecked in 0.00s: No TCCs generated
real_fun_props typechecked in 0.04s: No TCCs generated
real_fun_supinf typechecked in 0.58s: 5 TCCs, 0 proved, 0 subsumed, 5 unproved
sequence_props typechecked in 0.67s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing monotone_subsequence
monotone_subsequence parsed in 0.00 seconds
monotone_subsequence is already parsed
Typechecking monotone_subsequence
monotone_subsequence typechecked in 0.07s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
convergence_sequences typechecked in 0.90s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved

 LET/WHERE variable S1 at line 124, col 28 is given type
  real from its value expression.


 LET/WHERE variable S2 at line 125, col 28 is given type
  real from its value expression.


 In declaration gxis:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration gxis:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration gxis:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration gxis:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

integral_prep typechecked in 3.958s: 9 TCCs, 0 proved, 0 subsumed, 6 unproved, 3 trivial; 4 conversions; 2 msgs
Parsing integral_step
integral_step parsed in 0.01 seconds
integral_step is already parsed
Typechecking integral_step
Parsing step_fun_def
step_fun_def parsed in 0.00 seconds
step_fun_def is already parsed
Typechecking step_fun_def

 LET/WHERE variable N at line 30, col 32 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 30, col 47 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable N at line 51, col 24 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 51, col 39 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.

step_fun_def typechecked in 0.12s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved; 4 msgs
Parsing integral_pulse
integral_pulse parsed in 0.00 seconds
integral_pulse is already parsed
Typechecking integral_pulse
integral_pulse typechecked in 0.32s: 16 TCCs, 0 proved, 3 subsumed, 13 unproved

 In declaration integral_sumof:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration integral_sumof:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable endx at line 112, col 17 is given type
  closed_interval[T](a, b) from its value expression.


 LET/WHERE variable N at line 122, col 22 is given type
  int from its value expression.


 LET/WHERE variable N at line 137, col 25 is given type
  nat from its value expression.


 In declaration step_function_on_integral:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration step_function_on_integral:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

integral_step typechecked in 1.489s: 42 TCCs, 0 proved, 10 subsumed, 32 unproved; 4 conversions; 3 msgs
Parsing interval_minmax
interval_minmax parsed in 0.04 seconds
interval_minmax is already parsed
Typechecking interval_minmax
Parsing continuity_interval
continuity_interval parsed in 0.00 seconds
continuity_interval is already parsed
Typechecking continuity_interval
Parsing continuity_props
continuity_props parsed in 0.00 seconds
continuity_props is already parsed
Typechecking continuity_props
Parsing top_sequences
top_sequences parsed in 0.00 seconds
top_sequences is already parsed
Typechecking top_sequences
Parsing convergence_ops
convergence_ops parsed in 0.02 seconds
convergence_ops is already parsed
Typechecking convergence_ops
convergence_ops typechecked in 0.21s: 14 TCCs, 0 proved, 1 subsumed, 13 unproved
top_sequences typechecked in 0.27s: No TCCs generated
continuity_props typechecked in 0.32s: No TCCs generated
continuity_interval typechecked in 0.42s: 14 TCCs, 0 proved, 5 subsumed, 9 unproved
interval_minmax typechecked in 0.50s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
Parsing unif_cont_fun
unif_cont_fun parsed in 0.00 seconds
unif_cont_fun is already parsed
Typechecking unif_cont_fun

 LET/WHERE variable D at line 45, col 28 is given type
  [T -> boolean] from its value expression.

unif_cont_fun typechecked in 0.06s: No TCCs generated; 1 msg

 LET/WHERE variable xx at line 76, col 32 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable xx at line 84, col 32 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.

integral_cont_scaf typechecked in 7.147s: 44 TCCs, 0 proved, 26 subsumed, 18 unproved; 2 msgs
integral_cont typechecked in 7.338s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing integral_split
integral_split parsed in 0.06 seconds
integral_split is already parsed
Typechecking integral_split
Parsing integral_split_scaf
integral_split_scaf parsed in 0.01 seconds
integral_split_scaf is already parsed
Typechecking integral_split_scaf
Parsing integral_bounded
integral_bounded parsed in 0.00 seconds
integral_bounded is already parsed
Typechecking integral_bounded

 In declaration int_to_bnd:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to EP, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration int_to_bnd:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to EP, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration bounded_on_all?:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration bounded_on_all?:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

integral_bounded typechecked in 0.79s: 19 TCCs, 0 proved, 7 subsumed, 11 unproved, 1 trivial; 4 conversions

 LET/WHERE variable JJ at line 53, col 35 is given type
  {ii: below(length(P) - 1) | seq(P)(ii) <= xx AND xx <= seq(P)(1 + ii)} from its value expression.


 LET/WHERE variable JJ at line 77, col 26 is given type
  {ii: below(length(P) - 1) | seq(P)(ii) <= x AND x <= seq(P)(1 + ii)} from its value expression.


 In declaration F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable JJ at line 87, col 16 is given type
  {ii: below(length(P) - 1) | seq(P)(ii) <= x AND x <= seq(P)(1 + ii)} from its value expression.


 In declaration F2:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration F2:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable N at line 107, col 26 is given type
  int from its value expression.


 LET/WHERE variable N at line 112, col 26 is given type
  int from its value expression.


 LET/WHERE variable N at line 119, col 26 is given type
  int from its value expression.


 In declaration integral_F2_F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration integral_F2_F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 LET/WHERE variable DP at line 122, col 30 is given type
  real from its value expression.


 LET/WHERE variable DELj at line 123, col 30 is given type
  real from its value expression.


 In declaration integral_F2_F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration integral_F2_F1:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration sigma_all_parts:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration sigma_all_parts:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

integral_split_scaf typechecked in 2.494s: 54 TCCs, 0 proved, 23 subsumed, 31 unproved; 10 conversions; 8 msgs
Parsing step_fun_props
step_fun_props parsed in 0.00 seconds
step_fun_props is already parsed
Typechecking step_fun_props
Parsing sort_seq_lems
sort_seq_lems parsed in 0.00 seconds
sort_seq_lems is already parsed
Typechecking sort_seq_lems
Parsing sort_seq
sort_seq parsed in 0.01 seconds
sort_seq is already parsed
Typechecking sort_seq
Parsing sort_array
sort_array parsed in 0.00 seconds
sort_array is already parsed
Typechecking sort_array
Parsing sort_array_def
sort_array_def parsed in 0.00 seconds
sort_array_def is already parsed
Typechecking sort_array_def
Parsing min_array_def
min_array_def parsed in 0.00 seconds
min_array_def is already parsed
Typechecking min_array_def
Parsing below_arrays
below_arrays parsed in 0.00 seconds
below_arrays is already parsed
Typechecking below_arrays
below_arrays typechecked in 0.00s: No TCCs generated
Parsing max_array_def
max_array_def parsed in 0.00 seconds
max_array_def is already parsed
Typechecking max_array_def
max_array_def typechecked in 0.03s: 6 TCCs, 0 proved, 0 subsumed, 6 unproved
min_array_def typechecked in 0.07s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing permutations
permutations parsed in 0.00 seconds
permutations is already parsed
Typechecking permutations
permutations typechecked in 0.01s: No TCCs generated
sort_array_def typechecked in 0.16s: 10 TCCs, 0 proved, 5 subsumed, 5 unproved
sort_array typechecked in 0.22s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
Parsing permutations_seq
permutations_seq parsed in 0.00 seconds
permutations_seq is already parsed
Typechecking permutations_seq
Parsing finite_sets_card_eq
finite_sets_card_eq parsed in 0.00 seconds
finite_sets_card_eq is already parsed
Typechecking finite_sets_card_eq
Parsing func_composition
func_composition parsed in 0.04 seconds
func_composition is already parsed
Typechecking func_composition
func_composition typechecked in 0.01s: No TCCs generated
finite_sets_card_eq typechecked in 0.08s: No TCCs generated
Parsing finite_sets_below
finite_sets_below parsed in 0.00 seconds
finite_sets_below is already parsed
Typechecking finite_sets_below
finite_sets_below typechecked in 0.04s: 7 TCCs, 0 proved, 2 subsumed, 5 unproved
permutations_seq typechecked in 0.84s: No TCCs generated
Parsing seqs
seqs parsed in 0.00 seconds
seqs is already parsed
Typechecking seqs
seqs typechecked in 0.03s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
sort_seq typechecked in 1.26s: 10 TCCs, 0 proved, 2 subsumed, 8 unproved
Parsing min_seq
min_seq parsed in 0.00 seconds
min_seq is already parsed
Typechecking min_seq
min_seq typechecked in 0.08s: 10 TCCs, 0 proved, 2 subsumed, 8 unproved
Parsing max_seq
max_seq parsed in 0.00 seconds
max_seq is already parsed
Typechecking max_seq
max_seq typechecked in 0.08s: 10 TCCs, 0 proved, 2 subsumed, 8 unproved
sort_seq_lems typechecked in 1.527s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved

 In declaration IMPORTING structures@sort_seq_lems[T, <=]:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]

Parsing step_fun_scaf
step_fun_scaf parsed in 0.00 seconds
step_fun_scaf is already parsed
Typechecking step_fun_scaf
Parsing partitions_scaf
partitions_scaf parsed in 0.00 seconds
partitions_scaf is already parsed
Typechecking partitions_scaf

 In declaration IMPORTING structures@sort_seq_lems[T, <=]:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration IMPORTING finite_sets@finite_sets_minmax[T, <=]:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]

Parsing max_below
max_below parsed in 0.00 seconds
max_below is already parsed
Typechecking max_below
max_below typechecked in 0.01s: 1 TCC, 0 proved, 0 subsumed, 1 unproved

 In declaration gen_seq_lem:
  added conversion finseq_appl[T]
             
  to  #(x), converting
     fs: finseq[T]
  to [below[length(fs)] -> T]


 In declaration part2set_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to P, converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_part2set:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 LET/WHERE variable SP at line 70, col 26 is given type
  finite_sequence[T] from its value expression.


 LET/WHERE variable SP at line 73, col 29 is given type
  finite_sequence[T] from its value expression.


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration minmax_set2seq:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 LET/WHERE variable SP at line 84, col 29 is given type
  finite_sequence[T] from its value expression.


 LET/WHERE variable SP at line 88, col 31 is given type
  finite_sequence[T] from its value expression.


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part_prep:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 LET/WHERE variable SP at line 95, col 34 is given type
  {ss: seqs[T, restrict[[real, real], [T, T], bool](<=)] |
     permutation?[T, restrict[[real, real], [T, T], bool](<=)](set2seq(S), ss)
      AND increasing?(ss)} from its value expression.


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]


 In declaration set2part:
  added conversion restrict[[real, real], [T, T], bool]
             
  to <=, converting
     [[real, real] -> bool]
  to [[T, T] -> bool]

partitions_scaf typechecked in 1.269s: 25 TCCs, 0 proved, 6 subsumed, 19 unproved; 28 conversions; 5 msgs

 LET/WHERE variable UP at line 28, col 27 is given type
  finite_set[T] from its value expression.


 In declaration Union_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to UnionPart(a, b, P1, P2), converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]


 In declaration Union_lem:
  added conversion finseq_appl[closed_interval[T](a, b)]
             
  to UnionPart(a, b, P1, P2), converting
     fs: finseq[closed_interval[T](a, b)]
  to [below[length(fs)] -> closed_interval[T](a, b)]

step_fun_scaf typechecked in 2.325s: 11 TCCs, 0 proved, 2 subsumed, 9 unproved; 2 conversions; 1 msg

 LET/WHERE variable N at line 44, col 24 is given type
  nat from its value expression.


 LET/WHERE variable xx at line 44, col 39 is given type
  [below[P`length] -> closed_interval[T](a, b)] from its value expression.


 LET/WHERE variable N1 at line 54, col 20 is given type
  nat from its value expression.


 LET/WHERE variable NUU at line 55, col 20 is given type
  int from its value expression.

step_fun_props typechecked in 7.611s: 27 TCCs, 0 proved, 8 subsumed, 19 unproved; 1 conversion; 4 msgs
Parsing concat_arrays
concat_arrays parsed in 0.00 seconds
concat_arrays is already parsed
Typechecking concat_arrays
concat_arrays typechecked in 0.04s: 6 TCCs, 0 proved, 0 subsumed, 6 unproved
Parsing sigma_below_sub
sigma_below_sub parsed in 0.00 seconds
sigma_below_sub is already parsed
Typechecking sigma_below_sub
sigma_below_sub typechecked in 0.10s: 16 TCCs, 0 proved, 0 subsumed, 16 unproved
integral_split typechecked in 11.39s: 17 TCCs, 0 proved, 9 subsumed, 8 unproved
Parsing continuous_functions_more
continuous_functions_more parsed in 0.00 seconds
continuous_functions_more is already parsed
Typechecking continuous_functions_more
continuous_functions_more typechecked in 0.06s: No TCCs generated

 LET/WHERE variable l at line 145, col 35 is given type
  {p: real | p <= a AND p <= b} from its value expression.


 LET/WHERE variable u at line 146, col 35 is given type
  {p: real | p >= a AND p >= b} from its value expression.

integral typechecked in 22.22s: 16 TCCs, 0 proved, 6 subsumed, 7 unproved, 3 trivial; 2 msgs
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/continuous_functions_props.bin in 0.14s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/derivatives_def.bin in 0.13s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/derivatives.bin in 0.13s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/derivatives_alt.bin in 0.13s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/derivative_props.bin in 0.15s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/fundamental_theorem.bin in 0.36s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/indefinite_integral.bin in 0.33s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/lim_of_composition.bin in 0.11s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/chain_rule.bin in 0.14s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/deriv_domain.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/deriv_domains.bin in 0.03s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/composition_continuous.bin in 0.13s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/inverse_continuous_functions.bin in 0.13s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/derivative_inverse.bin in 0.14s (load part took 0.00s)
ln_exp typechecked in 33.994s: 14 TCCs, 0 proved, 1 subsumed, 13 unproved
prelude_aux typechecked in 35.575s: 16 TCCs, 0 proved, 7 subsumed, 9 unproved
Parsing prelude_A4
prelude_A4 parsed in 0.01 seconds
prelude_A4 is already parsed
Typechecking prelude_A4
prelude_A4 typechecked in 1.054s: 100 TCCs, 0 proved, 58 subsumed, 42 unproved
Parsing appendix
appendix parsed in 0.00 seconds
appendix is already parsed
Typechecking appendix

 In declaration floor_log2:
  added conversion restrict[nat, posnat, nat]
             
  to (LAMBDA n: n), converting
     [nat -> nat]
  to [posnat -> nat]

appendix typechecked in 0.60s: 12 TCCs, 0 proved, 5 subsumed, 7 unproved; 1 conversion
Parsing prelude_sqrt
prelude_sqrt parsed in 0.00 seconds
prelude_sqrt is already parsed
Typechecking prelude_sqrt

 In declaration sqrt_set:
  added conversion restrict[real, nnreal, bool]
             
  to {y | y * y <= nnx}, converting
     [real -> bool]
  to [nnreal -> bool]


 In declaration sqrt_set_has_UB:
  added conversion extend[real, nnreal, bool, FALSE]
             
  to sqrt_set(nnx), converting
     [nnreal -> bool]
  to [real -> bool]


 In declaration sqrt_set_LUB:
  added conversion extend[real, nnreal, bool, FALSE]
             
  to sqrt_set(nnx), converting
     [nnreal -> bool]
  to [real -> bool]

prelude_sqrt typechecked in 0.43s: 2 TCCs, 0 proved, 1 subsumed, 1 unproved; 3 conversions
Parsing cauchy
cauchy parsed in 0.00 seconds
cauchy is already parsed
Typechecking cauchy
cauchy typechecked in 0.39s: 16 TCCs, 0 proved, 0 subsumed, 16 unproved
Parsing int
int parsed in 0.00 seconds
int is already parsed
Typechecking int
int typechecked in 0.21s: 2 TCCs, 0 proved, 0 subsumed, 2 unproved
Parsing add
add parsed in 0.00 seconds
add is already parsed
Typechecking add
add typechecked in 0.40s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing neg
neg parsed in 0.08 seconds
neg is already parsed
Typechecking neg
neg typechecked in 0.23s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing sub
sub parsed in 0.00 seconds
sub is already parsed
Typechecking sub
sub typechecked in 0.35s: No TCCs generated
Parsing mul
mul parsed in 0.01 seconds
mul is already parsed
Typechecking mul

 LET/WHERE variable s1 at line 88, col 21 is given type
  posint from its value expression.


 LET/WHERE variable s2 at line 89, col 21 is given type
  posint from its value expression.

mul typechecked in 1.046s: 3 TCCs, 0 proved, 1 subsumed, 2 unproved; 2 msgs
Parsing inv
inv parsed in 0.01 seconds
inv is already parsed
Typechecking inv
Parsing unique
unique parsed in 0.00 seconds
unique is already parsed
Typechecking unique
unique typechecked in 0.69s: No TCCs generated

 LET/WHERE variable s at line 98, col 21 is given type
  nat from its value expression.

inv typechecked in 2.056s: 17 TCCs, 0 proved, 1 subsumed, 16 unproved; 1 msg
Parsing div
div parsed in 0.00 seconds
div is already parsed
Typechecking div
div typechecked in 0.34s: No TCCs generated
Parsing rat
rat parsed in 0.00 seconds
rat is already parsed
Typechecking rat
rat typechecked in 0.56s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
Parsing shift
shift parsed in 0.00 seconds
shift is already parsed
Typechecking shift
shift typechecked in 0.52s: 3 TCCs, 0 proved, 0 subsumed, 3 unproved
Parsing min
min parsed in 0.00 seconds
min is already parsed
Typechecking min
min typechecked in 0.20s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing max
max parsed in 0.00 seconds
max is already parsed
Typechecking max
max typechecked in 0.19s: 1 TCC, 0 proved, 0 subsumed, 1 unproved
Parsing sqrtx
sqrtx parsed in 0.03 seconds
sqrtx is already parsed
Typechecking sqrtx
Parsing bisection_nat_sqrt
bisection_nat_sqrt parsed in 0.00 seconds
bisection_nat_sqrt is already parsed
Typechecking bisection_nat_sqrt

 LET/WHERE variable t at line 29, col 31 is given type
  {x1: {i | i <= (m + n) / 2 & (m + n) / 2 < 1 + i} | x1 >= 0} from its value expression.

bisection_nat_sqrt typechecked in 0.34s: 8 TCCs, 0 proved, 0 subsumed, 8 unproved; 1 msg
sqrtx typechecked in 1.225s: 7 TCCs, 0 proved, 1 subsumed, 6 unproved
Parsing power
power parsed in 0.01 seconds
power is already parsed
Typechecking power

 LET/WHERE variable p1 at line 125, col 10 is given type
  posint from its value expression.


 LET/WHERE variable p1 at line 129, col 22 is given type
  posint from its value expression.

power typechecked in 1.536s: 55 TCCs, 0 proved, 23 subsumed, 32 unproved; 2 msgs
Parsing sum
sum parsed in 0.00 seconds
sum is already parsed
Typechecking sum
sum typechecked in 1.191s: 20 TCCs, 0 proved, 8 subsumed, 12 unproved
Parsing series
series parsed in 0.00 seconds
series is already parsed
Typechecking series
series typechecked in 0.34s: 14 TCCs, 0 proved, 3 subsumed, 11 unproved
Parsing powerseries
powerseries parsed in 0.00 seconds
powerseries is already parsed
Typechecking powerseries
powerseries typechecked in 0.97s: 8 TCCs, 0 proved, 0 subsumed, 8 unproved
Parsing atanx
atanx parsed in 0.00 seconds
atanx is already parsed
Typechecking atanx
Parsing atan
atan parsed in 0.01 seconds
atan is already parsed
Typechecking atan
Parsing poly_rew
poly_rew parsed in 0.00 seconds
poly_rew is already parsed
Typechecking poly_rew
Parsing polynomials
polynomials parsed in 0.04 seconds
polynomials is already parsed
Typechecking polynomials
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/reals/pvsbin/sigma_nat.bin in 0.04s (load part took 0.00s)
Parsing factorial
factorial parsed in 0.00 seconds
factorial is already parsed
Typechecking factorial
Parsing factorial
factorial parsed in 0.00 seconds
factorial is already parsed
Typechecking factorial
factorial typechecked in 0.07s: 8 TCCs, 0 proved, 1 subsumed, 7 unproved
Parsing product
product parsed in 0.01 seconds
product is already parsed
Typechecking product
Parsing for_iterate
for_iterate parsed in 0.01 seconds
for_iterate is already parsed
Typechecking for_iterate
for_iterate typechecked in 0.53s: 74 TCCs, 0 proved, 14 subsumed, 60 unproved
product typechecked in 1.164s: 43 TCCs, 0 proved, 14 subsumed, 29 unproved; 4 warnings
factorial typechecked in 1.60s: 12 TCCs, 0 proved, 2 subsumed, 10 unproved
Parsing binomial
binomial parsed in 0.00 seconds
binomial is already parsed
Typechecking binomial
binomial typechecked in 0.27s: 23 TCCs, 0 proved, 2 subsumed, 21 unproved
Parsing sigma_swap
sigma_swap parsed in 0.00 seconds
sigma_swap is already parsed
Typechecking sigma_swap
sigma_swap typechecked in 0.03s: 1 TCC, 0 proved, 0 subsumed, 1 unproved

 LET/WHERE variable eventzero at line 173, col 8 is given type
  [sequence[real] -> boolean] from its value expression.


 LET/WHERE variable g at line 198, col 10 is given type
  sequence[real] from its value expression.


 LET/WHERE variable idf at line 228, col 31 is given type
  [real -> real] from its value expression.


 LET/WHERE variable fk at line 448, col 8 is given type
  [real -> real] from its value expression.


 LET/WHERE variable fn1 at line 449, col 5 is given type
  [real -> real] from its value expression.


 LET/WHERE variable fk at line 469, col 8 is given type
  [real -> real] from its value expression.


 LET/WHERE variable fn1 at line 470, col 5 is given type
  [real -> real] from its value expression.

polynomials typechecked in 3.68s: 111 TCCs, 0 proved, 44 subsumed, 67 unproved; 7 msgs
poly_rew typechecked in 3.871s: No TCCs generated
Parsing trig_types
trig_types parsed in 0.00 seconds
trig_types is already parsed
Typechecking trig_types
Parsing pi_def
pi_def parsed in 0.00 seconds
pi_def is already parsed
Typechecking pi_def
Parsing sincos_def
sincos_def parsed in 0.00 seconds
sincos_def is already parsed
Typechecking sincos_def
Parsing power_series_conv
power_series_conv parsed in 0.00 seconds
power_series_conv is already parsed
Typechecking power_series_conv
Parsing power_series
power_series parsed in 0.00 seconds
power_series is already parsed
Typechecking power_series
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/series/pvsbin/series.bin in 0.40s (load part took 0.00s)
Parsing exponent_props
exponent_props parsed in 0.00 seconds
exponent_props is already parsed
Typechecking exponent_props
exponent_props typechecked in 0.09s: 9 TCCs, 0 proved, 5 subsumed, 4 unproved
power_series typechecked in 0.95s: 3 TCCs, 0 proved, 1 subsumed, 2 unproved
power_series_conv typechecked in 1.088s: 5 TCCs, 0 proved, 0 subsumed, 5 unproved
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/nth_derivatives.bin in 0.13s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/taylors.bin in 0.29s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/series/pvsbin/power_series_derivseq.bin in 0.56s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/series/pvsbin/power_series_deriv_scaf.bin in 0.82s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/series/pvsbin/power_series_deriv.bin in 0.71s (load part took 0.00s)
sincos_def typechecked in 4.901s: 22 TCCs, 0 proved, 6 subsumed, 16 unproved
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/orders/pvsbin/relations_extra.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/orders/pvsbin/bounded_orders.bin in 0.04s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/orders/pvsbin/minmax_orders.bin in 0.05s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/orders/pvsbin/well_nat.bin in 0.05s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/series/pvsbin/series_aux.bin in 0.49s (load part took 0.00s)

 LET/WHERE variable S at line 26, col 45 is given type
  [nat -> real] from its value expression.

pi_def typechecked in 6.395s: 14 TCCs, 0 proved, 0 subsumed, 14 unproved; 1 msg
trig_types typechecked in 6.723s: 16 TCCs, 0 proved, 2 subsumed, 14 unproved
Parsing trig_basic
trig_basic parsed in 0.00 seconds
trig_basic is already parsed
Typechecking trig_basic
Parsing sincos
sincos parsed in 0.01 seconds
sincos is already parsed
Typechecking sincos
Parsing quadratic
quadratic parsed in 0.05 seconds
quadratic is already parsed
Typechecking quadratic
quadratic typechecked in 0.49s: 10 TCCs, 0 proved, 1 subsumed, 9 unproved
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/series/pvsbin/series_lems.bin in 0.46s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/series/pvsbin/absconv_series.bin in 0.50s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/trig/pvsbin/merten.bin in 0.55s (load part took 0.00s)
sincos typechecked in 4.057s: 18 TCCs, 0 proved, 2 subsumed, 14 unproved, 2 trivial
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/trig/pvsbin/infinite_limits.bin in 0.24s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/derivatives_subtype.bin in 0.15s (load part took 0.00s)
trig_basic typechecked in 5.25s: 18 TCCs, 0 proved, 4 subsumed, 14 unproved
Parsing trig_values
trig_values parsed in 0.00 seconds
trig_values is already parsed
Typechecking trig_values
Parsing trig_ineq
trig_ineq parsed in 0.00 seconds
trig_ineq is already parsed
Typechecking trig_ineq
trig_ineq typechecked in 0.33s: 8 TCCs, 0 proved, 2 subsumed, 6 unproved
trig_values typechecked in 0.69s: 4 TCCs, 0 proved, 0 subsumed, 4 unproved
Parsing harmonic_polynomials
harmonic_polynomials parsed in 0.02 seconds
harmonic_polynomials is already parsed
Typechecking harmonic_polynomials
harmonic_polynomials typechecked in 0.30s: 12 TCCs, 0 proved, 0 subsumed, 12 unproved
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/polynomial_deriv.bin in 0.70s (load part took 0.00s)
atan typechecked in 21.847s: 70 TCCs, 0 proved, 15 subsumed, 54 unproved, 1 trivial

 LET/WHERE variable t at line 106, col 10 is given type
  int from its value expression.


 LET/WHERE variable cxm1 at line 107, col 10 is given type
  cauchy_real from its value expression.


 LET/WHERE variable cxp1 at line 108, col 10 is given type
  cauchy_real from its value expression.


 LET/WHERE variable p2 at line 109, col 10 is given type
  cauchy_real from its value expression.


 LET/WHERE variable p4 at line 110, col 10 is given type
  cauchy_real from its value expression.

atanx typechecked in 28.307s: 25 TCCs, 0 proved, 1 subsumed, 24 unproved; 5 msgs
Parsing asinx
asinx parsed in 0.00 seconds
asinx is already parsed
Typechecking asinx
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/sqrt_derivative.bin in 0.27s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/analysis/pvsbin/restrict2_deriv.bin in 0.19s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/trig/pvsbin/asin.bin in 1.462s (load part took 0.00s)

 LET/WHERE variable t at line 32, col 10 is given type
  int from its value expression.


 LET/WHERE variable s at line 33, col 10 is given type
  cauchy_nnreal from its value expression.


 LET/WHERE variable p2 at line 34, col 10 is given type
  cauchy_real from its value expression.


 LET/WHERE variable a at line 36, col 18 is given type
  cauchy_real from its value expression.

asinx typechecked in 2.589s: 5 TCCs, 0 proved, 0 subsumed, 5 unproved; 4 msgs
Parsing acosx
acosx parsed in 0.00 seconds
acosx is already parsed
Typechecking acosx
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/trig/pvsbin/acos.bin in 1.474s (load part took 0.00s)
acosx typechecked in 2.00s: No TCCs generated
Parsing sincosx
sincosx parsed in 0.00 seconds
sincosx is already parsed
Typechecking sincosx
Parsing trig_approx
trig_approx parsed in 0.01 seconds
trig_approx is already parsed
Typechecking trig_approx
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/trig/pvsbin/exp_term.bin in 0.28s (load part took 0.00s)
Restored theory from /Users/mmoscato/nasa/pvslib/pvslib-gitlab-pvs-8.0-fixes/trig/pvsbin/atan2.bin in 1.501s (load part took 0.00s)
fatal error encountered in SBCL pid 46099 pthread 0x7ff85b106640:
SIGABRT received.

Welcome to LDB, a low-level debugger for the Lisp runtime environment.
ldb> 
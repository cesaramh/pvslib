(hp_def
 (dlvar_inj 0
  (dlvar_inj-1 nil 3899226353
   ("" (induct "v1")
    (("" (skeep)
      (("" (induct "v2") (("" (skeep) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   nil shostak))
 (dlvar_eq 0
  (dlvar_eq-1 nil 3903515235
   ("" (skeep) (("" (decompose-equality 1) nil nil)) nil) nil shostak))
 (mapexpr_inj_TCC1 0
  (mapexpr_inj_TCC1-1 nil 3786461579 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil))
   shostak
   (mapexpr_inj subtype "hp_def.i" "below[length[MapExpr](l)]")))
 (mapexpr_inj_TCC2 0
  (mapexpr_inj_TCC2-1 nil 3790609695 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil))
   shostak
   (mapexpr_inj subtype "hp_def.j" "below[length[MapExpr](l)]")))
 (mapexpr_inj_cons 0
  (mapexpr_inj_cons-1 nil 3790613034
   ("" (skeep)
    (("" (expand "mapexpr_inj")
      (("" (skeep :preds? t)
        (("" (inst -4 "i+1" "j+1")
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (mapexpr_inj_eq 0
  (mapexpr_inj_eq-1 nil 3786461627
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "mapexpr_inj")
          (("1" (skeep)
            (("1" (case "i < j")
              (("1" (inst -2 "i" "j")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)
               ("2" (inst -1 "j" "i")
                (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "mapexpr_inj")
          (("2" (skeep)
            (("2" (insteep -1) (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (mapexpr_inj_eq_index 0
  (mapexpr_inj_eq_index-1 nil 3903529769
   ("" (skeep)
    (("" (lemma "mapexpr_inj_eq")
      (("" (inst?)
        (("" (replaces -1)
          (("" (split)
            (("1" (flatten)
              (("1" (skeep)
                (("1" (insteep)
                  (("1" (assert)
                    (("1" (flatten)
                      (("1" (decompose-equality 1) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (flatten)
              (("2" (skeep)
                (("2" (insteep) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (null_MapExprInj 0
  (null_MapExprInj-1 nil 3790613251
   ("" (expand "mapexpr_inj") (("" (grind) nil nil)) nil)
   ((nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (dLVar type-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (mapexpr_inj const-decl "bool" hp_def nil))
   shostak
   (null_MapExprInj subtype "list_adt[[hp_def.dLVar, RealExpr]].null"
    "MapExprInj")))
 (cdr_is_MapExprInj 0
  (cdr_is_MapExprInj-1 nil 3782823687
   ("" (expand "mapexpr_inj")
    (("" (skeep*)
      (("" (typepred "l")
        (("" (expand "mapexpr_inj")
          (("" (inst -1 "i+1" "j+1")
            (("1" (assert)
              (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil))
              nil)
             ("2" (typepred "j")
              (("2" (expand "length" 1) (("2" (assert) nil nil)) nil))
              nil)
             ("3" (typepred "i")
              (("3" (expand "length" 1) (("3" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (TRUE const-decl "bool" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nth def-decl "T" list_props nil) (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (subrange type-eq-decl nil integers nil)
    (j skolem-const-decl "subrange(1 + i, length(cdr[MapExpr](l)) - 1)"
     hp_def nil)
    (i skolem-const-decl "below(length(cdr[MapExpr](l)))" hp_def nil)
    (below type-eq-decl nil naturalnumbers nil)
    (l skolem-const-decl "{l: MapExprInj | cons?(l)}" hp_def nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def nil))
   shostak
   (cdr_is_MapExprInj subtype "list_adt[MapExpr].cdr(hp_def.l)"
    "MapExprInj")))
 (sub_mapexpr_inj_is_mapexpr_inj 0
  (sub_mapexpr_inj_is_mapexpr_inj-1 nil 3796803795
   ("" (skeep :preds? t)
    (("" (expand "mapexpr_inj")
      (("" (skeep :preds? t)
        (("" (lemma "sublist_respects_order[MapExpr]")
          (("" (inst -1 "l2" "l1" "i" "j")
            (("" (skeep :preds? t)
              (("" (inst -9 "i2" "j2") (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sublist_respects_order formula-decl nil more_list_props
     structures)
    (sublist? def-decl "bool" more_list_props structures)
    (sublist_alt_def rec-application-judgement
     "{b: bool | b = EXISTS (l_: list[T] | suffix?(l_, l2)): prefix?(l1, l_)}"
     more_list_props structures))
   shostak))
 (in_map_cons 0
  (in_map_cons-1 nil 3798041729
   ("" (skeep :preds? t)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "in_map")
          (("1" (skolem -1 "i1")
            (("1" (skolem -4 "i2")
              (("1" (rewrite "mapexpr_inj_eq")
                (("1" (rewrite "mapexpr_inj_eq")
                  (("1" (case "i1 = 0")
                    (("1" (inst -6 "i1" "i2+1")
                      (("1" (expand "nth" -6 2)
                        (("1" (assert)
                          (("1" (decompose-equality) nil nil)) nil))
                        nil)
                       ("2" (expand "length" 1)
                        (("2" (assert) nil nil)) nil))
                      nil)
                     ("2" (hide (-3 -4))
                      (("2" (inst -3 "i1" "0")
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (expand "nth" 2 2)
                              (("2"
                                (lemma "dLVar_dlvar_extensionality")
                                (("2"
                                  (inst?)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (expand "in_map")
          (("2" (skeep :preds? t)
            (("2" (inst 2 "i_1+1")
              (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)
               ("2" (expand "length" 1) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (in_map_null_false 0
  (in_map_null_false-1 nil 3798036858 ("" (grind) nil nil) nil
   shostak))
 (not_in_map_null 0
  (not_in_map_null-1 nil 3798036642 ("" (grind) nil nil) nil shostak))
 (index_of_j 0
  (index_of_j-1 nil 3798040255
   ("" (skeep :preds? t)
    (("" (expand "singleton?")
      (("" (expand "in_map")
        (("" (skeep -2)
          (("" (inst 1 "i_1")
            (("1" (skeep :preds? t)
              (("1" (rewrite "mapexpr_inj_eq")
                (("1" (inst -3 "i_1" "y")
                  (("1" (assert)
                    (("1" (expand "index_of")
                      (("1" (flatten)
                        (("1" (lemma "dlvar_inj")
                          (("1" (inst?) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "index_of") (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton? const-decl "bool" sets nil)
    (dlvar_inj formula-decl nil hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mapexpr_inj_eq formula-decl nil hp_def nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (dLVar type-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (index_of const-decl "bool" hp_def nil)
    (me skolem-const-decl "MapExprInj" hp_def nil)
    (i skolem-const-decl "(in_map(me))" hp_def nil)
    (i_1 skolem-const-decl "below(length(me))" hp_def nil)
    (in_map const-decl "bool" hp_def nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   nil
   (index_of_j subtype "hp_def.index_of(hp_def.me, hp_def.i)"
    "(sets[naturalnumbers.below(list_props[MapExpr].length(hp_def.me))].singleton?)")))
 (expr_car_TCC1 0
  (expr_car_TCC1-1 nil 3798044273
   ("" (skeep)
    (("" (expand "in_map")
      (("" (inst 1 "0")
        (("1" (expand "nth") (("1" (propax) nil nil)) nil)
         ("2" (expand "length") (("2" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((in_map const-decl "bool" hp_def nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (< const-decl "bool" reals nil) (dLVar type-decl nil hp_def nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (list type-decl nil list_adt nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (mapexpr skolem-const-decl "MapExpr" hp_def nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (me skolem-const-decl "MapExprInj" hp_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   nil
   (expr_car subtype "hp_def.dlvar_index(hp_def.mapexpr`1)"
    "(hp_def.in_map(list_adt[MapExpr].cons(hp_def.mapexpr, hp_def.me)))")))
 (expr_car 0
  (expr_car-1 nil 3798046110
   ("" (skeep)
    (("" (expand "expr")
      ((""
        (case-replace
         "the(index_of(cons(mapexpr, me), dlvar_index(mapexpr`1))) = 0")
        (("1" (expand "nth") (("1" (propax) nil nil)) nil)
         ("2" (hide 2)
          (("2" (rewrite "mapexpr_inj_eq")
            (("2"
              (typepred
               "the(index_of(cons(mapexpr, me), dlvar_index(mapexpr`1)))")
              (("2"
                (name-replace "THE"
                 "the(index_of(cons(mapexpr, me), dlvar_index(mapexpr`1)))")
                (("2" (expand "index_of")
                  (("2" (inst -3 "0" "THE")
                    (("1" (assert)
                      (("1" (expand "nth" -3 1)
                        (("1" (lemma "dLVar_dlvar_extensionality")
                          (("1" (inst?) (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "length" 1) (("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (expr_not_car_TCC1 0
  (expr_not_car_TCC1-1 nil 3798037314
   ("" (skeep* :preds? t)
    (("" (expand "in_map")
      (("" (skeep :preds? t)
        (("" (inst 2 "i_1+1")
          (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)
           ("2" (expand "length" 1) (("2" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((in_map const-decl "bool" hp_def nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (mapexpr skolem-const-decl "MapExpr" hp_def nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (i_1 skolem-const-decl "below(length(me))" hp_def nil)
    (below type-eq-decl nil naturalnumbers nil)
    (me skolem-const-decl "MapExprInj" hp_def nil)
    (MapExprInj type-eq-decl nil hp_def nil)
    (mapexpr_inj const-decl "bool" hp_def nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (dLVar type-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (nth def-decl "T" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   nil
   (expr_not_car subtype "hp_def.i"
    "(hp_def.in_map(list_adt[MapExpr].cons(hp_def.mapexpr, hp_def.me)))")))
 (expr_not_car 0
  (expr_not_car-1 nil 3798037540
   ("" (skeep :preds? t)
    (("" (expand "expr")
      ((""
        (case-replace
         "the(index_of(cons(mapexpr, me), i)) = 1+the(index_of(me, i))")
        (("1" (expand "nth" 2 1) (("1" (assert) nil nil)) nil)
         ("2" (hide 3)
          (("2" (typepred "the(index_of(cons(mapexpr, me), i))")
            (("2" (typepred "the(index_of(me, i))")
              (("2" (expand "index_of" -2 1)
                (("2" (expand "index_of" -4 1)
                  (("2"
                    (case-replace
                     "the(index_of(cons(mapexpr, me), i)) = 0")
                    (("1" (expand "nth" -5) (("1" (propax) nil nil))
                      nil)
                     ("2" (expand "nth" -4)
                      (("2" (assert)
                        (("2"
                          (name-replace "THE1" "the(index_of(me, i))")
                          (("2"
                            (name-replace "THE2"
                             "the(index_of(cons(mapexpr, me), i))")
                            (("2" (rewrite "mapexpr_inj_eq" -5)
                              (("2"
                                (inst -5 "THE1" "THE2-1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (lemma
                                     "dLVar_dlvar_extensionality")
                                    (("1"
                                      (inst? -1)
                                      (("1"
                                        (inst? - :where -5)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (same_var_eq 0
  (same_var_eq-1 nil 3899400431
   ("" (grind)
    (("" (lemma "dLVar_dlvar_extensionality")
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   nil shostak))
 (distinct_var?_TCC1 0
  (distinct_var?_TCC1-1 nil 3907334172 ("" (subtype-tcc) nil nil) nil
   nil
   (distinct_var? subtype "hp_def.l"
    "(list_adt[hp_def.dLVar].cons?)")))
 (distinct_var?_TCC2 0
  (distinct_var?_TCC2-1 nil 3907334172 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil
   (distinct_var? termination
    "hp_def.distinct_var?(list_adt[hp_def.dLVar].cdr(hp_def.l))"
    "nil")))
 (distinct_var?_TCC3 0
  (distinct_var?_TCC3-1 nil 3907334172
   ("" (skeep)
    (("" (iff)
      (("" (split)
        (("1" (flatten)
          (("1" (split -1)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (typepred "v1(cdr[dLVar](l))(v)")
                (("2" (replaces -1)
                  (("2" (skeep :preds? t)
                    (("2" (case-replace "i=0")
                      (("1" (expand "nth") (("1" (propax) nil nil))
                        nil)
                       ("2" (inst -2 "i-1")
                        (("1" (expand "nth" -2)
                          (("1" (assert) nil nil)) nil)
                         ("2" (assert)
                          (("2" (expand "length" -1)
                            (("2" (lift-if) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split 2)
            (("1" (inst -2 "0")
              (("1" (expand "nth") (("1" (propax) nil nil)) nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (typepred "v1(cdr[dLVar](l))(v)")
              (("2" (replaces -1)
                (("2" (skeep :preds? t)
                  (("2" (inst -3 "i+1")
                    (("1" (expand "nth" 1) (("1" (propax) nil nil))
                      nil)
                     ("2" (expand "length" 1)
                      (("2" (lift-if)
                        (("2" (split 1)
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((i skolem-const-decl "below(length(cdr[dLVar](l)))" hp_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (TRUE const-decl "bool" booleans nil)
    (i skolem-const-decl "below(length(l))" hp_def nil)
    (l skolem-const-decl "list[dLVar]" hp_def nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil) (dLVar type-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (distinct_var? subtype
    "booleans.OR(list_adt[hp_def.dLVar].null?(hp_def.l), (booleans.AND((booleans.NOT)(hp_def.dlvar_index(list_adt[hp_def.dLVar].car(hp_def.l)) = hp_def.dlvar_index(hp_def.v)), hp_def.distinct_var?(list_adt[hp_def.dLVar].cdr(hp_def.l))(hp_def.v))))"
    "{b: booleans.bool | b = FORALL (i: naturalnumbers.below(list_props[hp_def.dLVar].length(hp_def.l))): (booleans.NOT)(hp_def.dlvar_index(list_props[hp_def.dLVar].nth(hp_def.l, i)) = hp_def.dlvar_index(hp_def.v))}")))
 (pairwise_distinct_vars?_TCC1 0
  (pairwise_distinct_vars?_TCC1-1 nil 3907334172
   ("" (skeep) (("" (hide -1) (("" (termination-tcc) nil nil)) nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)) nil
   (pairwise_distinct_vars? termination
    "hp_def.pairwise_distinct_vars?(list_adt[hp_def.dLVar].cdr(hp_def.l))"
    "nil")))
 (pairwise_distinct_vars?_TCC2 0
  (pairwise_distinct_vars?_TCC2-1 nil 3907335501
   ("" (skeep)
    (("" (iff)
      (("" (split)
        (("1" (flatten)
          (("1" (split -1)
            (("1" (grind) nil nil)
             ("2" (flatten)
              (("2" (skeep :preds? t)
                (("2"
                  (typepred
                   "distinct_var?(cdr[dLVar](l))(car[dLVar](l))")
                  (("2" (replaces -1)
                    (("2" (typepred "v(cdr[dLVar](l))")
                      (("2" (replaces -1)
                        (("2" (case-replace "i=0")
                          (("1" (expand "nth" -6)
                            (("1" (assert)
                              (("1"
                                (inst -4 "j-1")
                                (("1"
                                  (expand "same_var")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (case-replace "j=0")
                            (("1" (expand "nth" -6)
                              (("1"
                                (assert)
                                (("1" (inst -4 "i-1") nil nil))
                                nil))
                              nil)
                             ("2" (inst -4 "i-1" "j-1")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "nth" -4)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (assert)
                                (("2"
                                  (hide-all-but (-2 1))
                                  (("2"
                                    (expand "length" -1)
                                    (("2"
                                      (lift-if)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("3"
                                (assert)
                                (("3"
                                  (hide-all-but (-1 1))
                                  (("3"
                                    (expand "length" -1)
                                    (("3"
                                      (lift-if)
                                      (("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (split 2)
            (("1"
              (typepred "distinct_var?(cdr[dLVar](l))(car[dLVar](l))")
              (("1" (replaces -1)
                (("1" (skeep :preds? t)
                  (("1" (inst -3 "0" "i+1")
                    (("1" (assert)
                      (("1" (expand "nth" 1)
                        (("1" (expand "same_var")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (expand "length" 1)
                      (("2" (lift-if) (("2" (assert) nil nil)) nil))
                      nil)
                     ("3" (hide-all-but +) (("3" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "v(cdr[dLVar](l))")
              (("2" (replaces -1)
                (("2" (skeep :preds? t)
                  (("2" (inst -4 "i+1" "j+1")
                    (("1" (assert)
                      (("1" (expand "nth" 2) (("1" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (hide-all-but (-2 1 3))
                      (("2" (expand "length" 1) (("2" (grind) nil nil))
                        nil))
                      nil)
                     ("3" (hide-all-but (-1 1 3))
                      (("3" (expand "length" 1) (("3" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((j skolem-const-decl "below(length(cdr[dLVar](l)))" hp_def nil)
    (i skolem-const-decl "below(length(cdr[dLVar](l)))" hp_def nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "below(length(cdr[dLVar](l)))" hp_def nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (l skolem-const-decl "list[dLVar]" hp_def nil)
    (i skolem-const-decl "below(length(l))" hp_def nil)
    (j skolem-const-decl "below(length(l))" hp_def nil)
    (TRUE const-decl "bool" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (list type-decl nil list_adt nil) (dLVar type-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   nil
   (pairwise_distinct_vars? subtype
    "booleans.OR(list_adt[hp_def.dLVar].null?(hp_def.l), (booleans.AND(hp_def.distinct_var?(list_adt[hp_def.dLVar].cdr(hp_def.l))(list_adt[hp_def.dLVar].car(hp_def.l)), hp_def.pairwise_distinct_vars?(list_adt[hp_def.dLVar].cdr(hp_def.l)))))"
    "{b: booleans.bool | b = FORALL (i, j: naturalnumbers.below(list_props[hp_def.dLVar].length(hp_def.l))): booleans.IMPLIES(i /= j, (booleans.NOT)(hp_def.dlvar_index(list_props[hp_def.dLVar].nth(hp_def.l, i)) = hp_def.dlvar_index(list_props[hp_def.dLVar].nth(hp_def.l, j))))}")))
 (fresh_var 0
  (fresh_var-1 nil 3907428003
   (""
    (case "FORALL (l:list[dLVar]) : EXISTS (m:nat) : FORALL (i:below(length(l))): m > dlvar_index(nth(l,i))")
    (("1" (skeep)
      (("1" (insteep -1)
        (("1" (skeep)
          (("1" (inst 1 "dlvar(m)")
            (("1" (typepred "distinct_var?(l)(dlvar(m))")
              (("1" (replaces -1)
                (("1" (skeep)
                  (("1" (insteep) (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "l")
        (("1" (inst 1 "0") (("1" (grind) nil nil)) nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (inst 1 "max(m,dlvar_index(cons1_var)+1)")
              (("2" (skeep :preds? t)
                (("2" (expand "length" -1)
                  (("2" (expand "nth" 1)
                    (("2" (case-replace "i=0")
                      (("1" (hide-all-but 1) (("1" (grind) nil nil))
                        nil)
                       ("2" (assert)
                        (("2" (inst -2 "i-1") (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (mapexpr_inj_distinct_vars 0
  (mapexpr_inj_distinct_vars-1 nil 3907690803
   ("" (skeep)
    (("" (lemma "mapexpr_inj_eq_index")
      (("" (inst?)
        (("" (replaces -1)
          ((""
            (typepred
             "pairwise_distinct_vars?(map(LAMBDA (x: MapExpr): x`1)(l))")
            (("" (replaces -1)
              (("" (split)
                (("1" (flatten)
                  (("1" (skeep :preds? t)
                    (("1" (rewrite "map_length")
                      (("1" (insteep)
                        (("1" (rewrite "map_nth_rw")
                          (("1" (rewrite "map_nth_rw")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (skeep)
                    (("2" (insteep)
                      (("1" (assert)
                        (("1" (rewrite "map_nth_rw")
                          (("1" (rewrite "map_nth_rw") nil nil)) nil))
                        nil)
                       ("2" (rewrite "map_length")
                        (("2" (assert) nil nil)) nil)
                       ("3" (rewrite "map_length")
                        (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((mapexpr_inj_eq_index formula-decl nil hp_def nil)
    (TRUE const-decl "bool" booleans nil)
    (j skolem-const-decl "below(length(l))" hp_def nil)
    (i skolem-const-decl "below(length(l))" hp_def nil)
    (map_length formula-decl nil more_map_props nil)
    (map_nth_rw formula-decl nil more_map_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (l skolem-const-decl "list[MapExpr]" hp_def nil)
    (i skolem-const-decl
       "below(length(map(LAMBDA (x: MapExpr): x`1)(l)))" hp_def nil)
    (j skolem-const-decl
     "below(length(map(LAMBDA (x: MapExpr): x`1)(l)))" hp_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def nil)
    (map adt-def-decl "list[T1]" list_adt_map nil)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def nil)
    (RealExpr type-eq-decl nil hp_def nil)
    (Environment type-eq-decl nil hp_def nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def nil))
   shostak))
 (max_var_rec_TCC1 0
  (max_var_rec_TCC1-1 nil 3785145622 ("" (subtype-tcc) nil nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def nil)) nil
   (max_var_rec subtype "hp_def.ode" "(list_adt[MapExpr].cons?)")))
 (max_var_rec_TCC2 0
  (max_var_rec_TCC3-1 nil 3785145622 ("" (termination-tcc) nil nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (max_var_rec termination
    "hp_def.max_var_rec(list_adt[MapExpr].cdr(hp_def.ode), real_defs.max(hp_def.mx, hp_def.dlvar_index(list_adt[MapExpr].car(hp_def.ode)`1)))"
    "nil")))
 (max_var_rec_pull 0
  (max_var_rec_pull-1 nil 3798384892
   ("" (induct "ode")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "cons2_var=null")
          (("1" (hide -2) (("1" (grind) nil nil)) nil)
           ("2" (expand "max_var_rec" 2 1)
            (("2" (inst-cp -1 "max(0, dlvar_index(cons1_var`1))")
              (("2" (replace -2 2 rl)
                (("2" (hide -2)
                  (("2" (expand "max_var_rec" 2 2)
                    (("2" (inst -1 "max(mx, dlvar_index(cons1_var`1))")
                      (("2" (replace -1 2 rl)
                        (("2" (hide -1) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (max_var_max 0
  (max_var_max-1 nil 3798385144
   ("" (induct "ode")
    (("1" (skeep)
      (("1" (grind) (("1" (typepred "i") (("1" (grind) nil nil)) nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (case "cons2_var=null")
        (("1" (hide -2)
          (("1" (skeep)
            (("1" (typepred "i")
              (("1" (expand "length" -1)
                (("1" (expand "length" -1)
                  (("1" (assert) (("1" (grind) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (case "i=0")
            (("1" (expand "nth" 2 1)
              (("1" (assert)
                (("1" (expand "max_var" 2 1)
                  (("1" (expand "max_var_rec" 2 1)
                    (("1" (lemma "max_var_rec_pull")
                      (("1" (inst?)
                        (("1" (replace -1 2 rl)
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "nth" 3 1)
              (("2" (assert)
                (("2" (expand "max_var" 3 1)
                  (("2" (expand "max_var_rec" 3 1)
                    (("2" (lemma "max_var_rec_pull")
                      (("2" (inst?)
                        (("2" (replace -1 3 rl)
                          (("2" (inst -2 "i-1")
                            (("2" (expand "max_var" -2)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (max_var_exist 0
  (max_var_exist-1 nil 3798389200
   ("" (induct "ode")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (case "cons2_var=null")
        (("1" (hide -2)
          (("1" (inst 1 "0")
            (("1" (grind) nil nil)
             ("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (expand "max_var" 2 1)
            (("2" (expand "max_var_rec" 2 1)
              (("2" (lemma "max_var_rec_pull")
                (("2"
                  (inst -1 "cons2_var"
                   "max(0, dlvar_index(cons1_var`1))")
                  (("2" (replace -1 2 rl)
                    (("2" (hide -1)
                      (("2"
                        (case "dlvar_index(cons1_var`1) >= max_var_rec(cons2_var, 0)")
                        (("1" (inst 2 "0")
                          (("1" (expand "nth" 2)
                            (("1" (expand "max" 2)
                              (("1"
                                (lift-if 2)
                                (("1"
                                  (split 2)
                                  (("1"
                                    (flatten)
                                    (("1" (assert) nil nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "length" 1 1)
                            (("2" (assert) nil nil)) nil))
                          nil)
                         ("2" (skeep -1)
                          (("2" (expand "max_var" -1)
                            (("2" (inst 3 "i+1")
                              (("1"
                                (expand "nth" 3 1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (expand "length" 1 1)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (pigeon_map 0
  (pigeon_map-1 nil 3798388885
   ("" (induct "n")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (case "j=0")
        (("1" (hide -2)
          (("1" (skeep)
            (("1" (assert)
              (("1" (inst -3 "0") (("1" (assert) nil nil)) nil)) nil))
            nil))
          nil)
         ("2" (assert)
          (("2" (skeep)
            (("2" (case "NOT EXISTS(i:below(1+j)): f(i) = j-1")
              (("1" (inst -1 "f")
                (("1" (assert)
                  (("1" (split -1)
                    (("1" (skeep) (("1" (inst 3 "j1" "j2") nil nil))
                      nil)
                     ("2" (skeep)
                      (("2" (assert)
                        (("2" (inst 2 "i")
                          (("2" (inst -2 "i") (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep -1)
                (("2"
                  (inst -2
                   "LAMBDA(n:nat): IF n<i THEN f(n) ELSE f(n+1) ENDIF")
                  (("2" (assert)
                    (("2" (split -2)
                      (("1" (skeep)
                        (("1" (assert)
                          (("1" (lift-if -1)
                            (("1" (split -1)
                              (("1"
                                (flatten)
                                (("1"
                                  (lift-if -2)
                                  (("1"
                                    (split -2)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (inst 2 "j1" "j2")
                                          nil
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (assert)
                                      (("2"
                                        (flatten)
                                        (("2"
                                          (inst 3 "j1" "1+j2")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (lift-if -1)
                                  (("2"
                                    (split -1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst 3 "1+j1" "j2")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (inst 4 "j1+1" "j2+1")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (skeep)
                        (("2" (lift-if 1)
                          (("2" (split 1)
                            (("1" (flatten)
                              (("1"
                                (inst -4 "i_1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst 3 "i_1" "i")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (inst -3 "1+i_1")
                                  (("2"
                                    (inst 4 "1+i_1" "i")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (max_var_length 0
  (max_var_length-2 nil 3899309623
   ("" (skeep)
    (("" (case "null?(ode)")
      (("1" (grind) nil nil)
       ("2"
        (case "FORALL(i:below(length(ode))): dlvar_index(nth(ode,i)`1) < length(ode)-1")
        (("1" (lemma "pigeon_map")
          (("1"
            (inst -1
             "LAMBDA(i:nat): IF i<length(ode) THEN dlvar_index(nth(ode,i)`1) ELSE 0 ENDIF"
             "length(ode)")
            (("1" (assert)
              (("1" (split -1)
                (("1" (skeep)
                  (("1" (typepred "ode")
                    (("1" (rewrite "mapexpr_inj_eq")
                      (("1" (inst -1 "j1" "j2")
                        (("1" (assert)
                          (("1" (flatten)
                            (("1" (lemma "dLVar_dlvar_extensionality")
                              (("1"
                                (inst?)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil)
             ("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (lemma "max_var_exist")
            (("2" (inst?)
              (("1" (skeep)
                (("1" (lemma "max_var_max")
                  (("1" (inst -1 "ode" "i") (("1" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil)
  (max_var_length-1 nil 3798374085
   ("" (skeep)
    (("" (case "null?(ode)")
      (("1" (grind) nil nil)
       ("2"
        (case "FORALL(i:below(length(ode))): nth(ode,i)`1 < length(ode)-1")
        (("1" (lemma "pigeon_map")
          (("1"
            (inst -1
             "LAMBDA(i:nat): IF i<length(ode) THEN nth(ode,i)`1 ELSE 0 ENDIF"
             "length(ode)")
            (("1" (assert)
              (("1" (split -1)
                (("1" (skeep)
                  (("1" (typepred "ode")
                    (("1" (expand "mapexpr_inj")
                      (("1" (inst -1 "j1" "j2")
                        (("1" (assert) nil nil)
                         ("2" (typepred "ode")
                          (("2" (expand "mapexpr_inj")
                            (("2" (inst -1 "j2" "j1")
                              (("1" (assert) nil nil)
                               ("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (propax) nil nil))
                nil))
              nil)
             ("2" (expand "length" 1 1) (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (lemma "max_var_exist")
            (("2" (inst?)
              (("1" (skeep)
                (("1" (assert)
                  (("1" (flip-ineq 1)
                    (("1" (lemma "max_var_max")
                      (("1" (inst -1 "ode" "i")
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (nip_max_var 0
  (nip_max_var-1 nil 3798373840
   (""
    (case " FORALL(m:nat, ode: ODEs, i: above(max_var(ode))): length(ode)=m IMPLIES not_in_map(ode)(i)")
    (("1" (skeep) (("1" (inst -1 "length(ode)" "ode" "i") nil nil))
      nil)
     ("2" (hide 2)
      (("2" (skeep)
        (("2" (case "i=0")
          (("1" (expand "not_in_map" 1 1)
            (("1" (typepred "i")
              (("1" (skeep)
                (("1" (typepred "i_1") (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand "not_in_map" 2 1)
            (("2" (skeep)
              (("2" (typepred "i")
                (("2" (lemma "max_var_max")
                  (("2" (inst -1 "ode" "i_1") (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)))
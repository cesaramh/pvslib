(Glossary_Plaidypvs
 (dl_axiom_example 0
  (n "n" 3876421024 ("" (skeep) (("" (dl-axiom 3) nil nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (TRUE const-decl "bool" booleans nil)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_moveR formula-decl nil dynamic_logic dL))
   shostak)
  (dl_axiom_example-1 nil 3876420819
   ("" (dl-flatten) (("" (postpone) nil nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL) (list type-decl nil list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (dl_andL_example 0
  (dl_andL_example-1 nil 3876421306
   ("" (skeep) (("" (dl-andL) (("" (dl-axiom) nil nil)) nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (delta__47 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (gamma__46 skolem-const-decl "(cons?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (dl_andR_example 0
  (dl_andR_example-1 nil 3876422373
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-andR)
        (("1" (dl-axiom) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_andR formula-decl nil dynamic_logic dL)
    (gamma__50 skolem-const-decl "(cons?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (delta__51 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__49 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (gamma__48 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil))
   shostak))
 (dl_anyb_example 0
  (dl_anyb_example-1 nil 3873836410
   ("" (skeep)
    (("" (dl-anyb)
      (("" (dl-skolem "X")
        (("" (dl-subs)
          (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((delta__57 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (gamma__56 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (gamma__58 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__59 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_sub_implies formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (gamma__54 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (dl_anyb_with formula-decl nil dynamic_logic dL)
    (delta__55 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (dl_anyd_example 0
  (dl_anyd_example-1 nil 3873837253
   ("" (skeep)
    (("" (dl-anyd)
      (("" (dl-inst "1")
        (("" (dl-subs)
          (("" (dl-andR)
            (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((delta__65 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_existsR formula-decl nil dynamic_logic dL)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (gamma__64 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (delta__67 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (gamma__66 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_sub_and formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (DLAND const-decl "bool" bool_expr dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (DLEXISTS const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (gamma__62 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (dl_anyd_with formula-decl nil dynamic_logic dL)
    (delta__63 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (dl_assert_example 0
  (dl_assert_example-1 nil 3876423003
   ("" (skeep) (("" (beta) (("" (dl-assert) nil nil)) nil)) nil)
   ((delta__69 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (DLAND const-decl "bool" bool_expr dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_minus formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (SUB_Re const-decl "real" substitution dL)
    (dl_sub_gt formula-decl nil substitution dL)
    (dl_sub_or formula-decl nil substitution dL)
    (dl_subre_plus formula-decl nil substitution dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (UNION adt-constructor-decl "[[HP, HP] -> (union?)]" HP_adt dL)
    (union? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (boolean nonempty-type-decl nil booleans nil)
    (HP type-decl nil HP_adt dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (dl_assignb_example 0
  (dl_assignb_example-1 nil 3876423972
   ("" (skeep) (("" (dl-assignb) (("" (dl-assert) nil nil)) nil)) nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (gamma__70 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (= const-decl "BoolExpr" bool_expr dL)
    (Assigns type-eq-decl nil hp_def dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (delta__71 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (- const-decl "[T -> real]" real_fun_ops reals))
   shostak))
 (dl_assignd_example 0
  (dl_assignd_example-1 nil 3876424097
   ("" (skeep) (("" (dl-assignd) (("" (dl-assert) nil nil)) nil)) nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (gamma__72 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (= const-decl "BoolExpr" bool_expr dL)
    (Assigns type-eq-decl nil hp_def dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (delta__73 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL))
   shostak))
 (dl_boxd_example 0
  (dl_boxd_example-1 nil 3876424196
   ("" (skeep) (("" (dl-assert) nil nil)) nil)
   ((TRUE const-decl "bool" booleans nil)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (Assigns type-eq-decl nil hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_lt formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (delta__75 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_notR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (gamma__74 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures))
   shostak))
 (dl_choiceb_example 0
  (dl_choiceb_example-1 nil 3876424762
   ("" (skeep)
    (("" (dl-choiceb)
      (("" (dl-andR)
        (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((delta__79 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (gamma__78 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil) (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (gamma__76 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (HP type-decl nil HP_adt dL) (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (delta__77 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL))
   shostak))
 (dl_choiced_example 0
  (dl_choiced_example-1 nil 3876428543
   ("" (skeep)
    (("" (dl-choiced)
      (("" (dl-ground)
        (("" (dl-hide 2)
          (("" (dl-assignd) (("" (dl-assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((gamma__82 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (delta__83 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (delta__87 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (gamma__86 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (delta__85 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (gamma__84 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (gamma__80 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (HP type-decl nil HP_adt dL) (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (dl_choiced formula-decl nil dynamic_logic dL)
    (delta__81 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL))
   shostak))
 (dl_composeb_example 0
  (dl_composeb_example-1 nil 3876430667
   ("" (skeep)
    (("" (dl-composeb)
      (("" (dl-assignb)
        (("" (dl-testb)
          (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((delta__91 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (gamma__90 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_lt formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (gamma__94 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__95 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (gamma__92 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_testb formula-decl nil dynamic_logic dL)
    (delta__93 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (gamma__88 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (HP type-decl nil HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (delta__89 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil))
   shostak))
 (dl_composed_example 0
  (dl_composed_example-1 nil 3876430708
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-composed)
        (("" (rewrite "dl_testd")
          (("" (dl-assignd) (("" (dl-assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((dl_composed formula-decl nil dynamic_logic dL)
    (gamma__98 skolem-const-decl "(cons?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (delta__99 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (gamma__100 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__101 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (DLAND const-decl "bool" bool_expr dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (gamma__102 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__103 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_testd formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (delta__97 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (gamma__96 skolem-const-decl "(null?[BoolExpr])" Glossary_Plaidypvs
     nil))
   shostak))
 (dl_case_example 0
  (dl_case_example-1 nil 3876430559
   ("" (skeep)
    (("" (dl-case "cnst(c) >= cnst(0)")
      (("1" (dl-choiceb)
        (("1" (dl-andR)
          (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
        nil)
       ("2" (dl-assert) nil nil))
      nil))
    nil)
   ((dl_cut formula-decl nil dynamic_logic dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (union? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (UNION adt-constructor-decl "[[HP, HP] -> (union?)]" HP_adt dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (DLNOT const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (gamma__108 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__109 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (gamma__110 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__111 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (delta__113 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__112 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__115 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_notL formula-decl nil dynamic_logic dL)
    (gamma__114 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (DLAND const-decl "bool" bool_expr dL)
    (delta__107 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__106 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (delta__117 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (gamma__116 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (delta__119 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (gamma__118 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__122 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__123 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__120 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__121 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil))
   shostak))
 (dl_diffcase_example 0
  (dl_diffcase_example-1 nil 3877099018
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-diffcase "val(x) ^ 2 > cnst(5)")
        (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((gamma__124 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (DLBOOL const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__125 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (delta__127 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (gamma__126 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (delta__129 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__128 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_dC formula-decl nil dynamic_logic dL))
   shostak))
 (dl_diffghost_example 0
  (dl_diffghost_example-2 "" 3911913342
   ("" (skeep)
    (("" (beta)
      (("" (dl-flatten)
        ((""
          (dl-diffghost "cnst(-1/2)" "cnst(0)" "G"
           "val(x)*val(G)^2=cnst(1)")
          (("1" (dl-instf "div_safe_re(cnst(1),val(x)^^(1/2))")
            (("1" (dl-composeb)
              (("1" (dl-assignb)
                (("1" (dl-subf)
                  (("1" (dl-diffinv)
                    (("1" (grind :exclude "^^")
                      (("1" (grind) nil nil)
                       ("2" (lemma "sqrt_hathat")
                        (("2" (grind) nil nil)) nil))
                      nil)
                     ("2" (dl-assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (dl-assert) nil nil) ("3" (dl-assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((fresh_var formula-decl nil hp_def dL)
    (dl_differential_ghost formula-decl nil dynamic_logic dL)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ddl_dom? const-decl "bool" differentiation dL)
    (cont_re? const-decl "bool" continuity_re_def dL)
    (Assigns type-eq-decl nil hp_def dL)
    (fresh_li? inductive-decl "bool" hp_expr dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (fresh? const-decl "bool" hp_expr dL)
    (fresh? const-decl "bool" hp_expr dL)
    (fresh? def-decl "bool" bool_expr dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (dl_true_DDL formula-decl nil differentiation dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (delta__133 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__132 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (G skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (cont_re_cnst formula-decl nil continuity_re_props dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (fresh_be_gt formula-decl nil fresh_props dL)
    (fresh_be_DLTRUE formula-decl nil fresh_props dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (DLEXISTSRf const-decl "bool" bool_expr dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (gamma__136 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__137 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_subf formula-decl nil dynamic_logic dL)
    (gamma__140 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__141 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (div_safe const-decl "real" reals_safe_ops reals)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (nzreal_times_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (exp_0 formula-decl nil ln_exp lnexp)
    (expt const-decl "real" differentiation dL)
    (^^ const-decl "nnreal" expt lnexp)
    (ln const-decl "real" ln_exp lnexp)
    (Integral const-decl "real" integral_def analysis)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (posreal_times_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sqrt_hathat formula-decl nil differentiation dL)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (dl_dift_const formula-decl nil differentiation dL)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (dl_dift_pow formula-decl nil differentiation dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (length_singleton formula-decl nil more_list_props structures)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (max_var_max formula-decl nil hp_def dL)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (dl_dift_val formula-decl nil differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (gamma__147 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (delta__148 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (max_var const-decl "nat" hp_def dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (nnqb__142 skolem-const-decl "{nnqbe: NormNQBool |
   nqb_to_be(nnqbe) =
    nqb_to_be(NQB_rel(nqb_eq, val(x) * val(G) ^ 2, cnst(1)))}"
     Glossary_Plaidypvs nil)
    (delta__144 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__143 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (delta__139 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__138 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (fresh_re_exp formula-decl nil fresh_props dL)
    (fresh_re_div_safe formula-decl nil fresh_props dL)
    (delta__135 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__134 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (^^ const-decl "RealExpr" differentiation dL)
    (div_safe_re const-decl "real" hp_def dL)
    (dl_existsrRf formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (delta__131 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (gamma__130 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   shostak)
  (dl_diffghost_example-1 nil 3882037909
   ("" (skeep)
    (("" (beta)
      (("" (dl-flatten)
        ((""
          (dl-diffghost "cnst(-1/2)" "cnst(0)" "G"
           "val(x)*val(G)^2=cnst(1)")
          (("1" (dl-instf "div_safe_re(cnst(1),val(x)^^(1/2))")
            (("1" (dl-composeb)
              (("1" (dl-assignb)
                (("1" (dl-subf)
                  (("1" (relabel (:pairing |fn!:1157|) (1))
                    (("1"
                      (name-label*
                       ("nnqb__49"
                        (typechecked
                         "normalize(NQB_rel(nqb_eq, val(x) * val(G) ^ 2, cnst(1)))"
                         "{nnqbe: NormNQBool |
   nqb_to_be(nnqbe) =
    nqb_to_be(NQB_rel(nqb_eq,
                      *[Environment](val(x), ^[Environment](val(G), 2)),
                      cnst(1)))}"))
                       :hide? t :label (:pairing |nnqb_:1158|)
                       :tcc-label (:pairing nil) :tcc-step
                       (:pairing nil))
                      (("1"
                        (case-replace
                         "(val(x) * val(G) ^ 2 = cnst(1))=nqb_to_be(nnqb__49)")
                        (("1" (relabel (:pairing |castr!:1164|) (-1))
                          (("1" (relabel (:pairing |fn!:1165|) (1))
                            (("1"
                              (name-label*
                               ("gamma__50"
                                (! |fn!:1165| 1)
                                "delta__51"
                                (! |fn!:1165| 2 2))
                               :hide? t)
                              (("1"
                                (lemma "dl_dI_dlTRUE")
                                (("1"
                                  (relabel (:pairing |nfn!:1189|) (-1))
                                  (("1"
                                    (with-tccs
                                     (inst?
                                      |nfn!:1189|
                                      :where
                                      |fn!:1165|
                                      :polarity?
                                      t)
                                     :tcc-step
                                     (assert))
                                    (("1"
                                      (relabel
                                       (|fn!:1157|)
                                       |nfn!:1189|)
                                      (("1"
                                        (replaces
                                         |fn!:1165|
                                         :in
                                         |nfn!:1189|)
                                        (("1"
                                          (expand*
                                           ("gamma__50" "delta__51"))
                                          (("1"
                                            (replaces
                                             |castr!:1164|
                                             :dir
                                             rl)
                                            (("1"
                                              (expand*
                                               "nnqb__49"
                                               "normalize")
                                              (("1"
                                                (for@
                                                 nil
                                                 (expand
                                                  "normalize_rec"))
                                                (("1"
                                                  (split |nfn!:1189|)
                                                  (("1"
                                                    (postpone)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (relabel
                                                     (|fn!:1157|)
                                                     |nfn!:1189|)
                                                    (("2"
                                                      (postpone)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (relabel
                                                     (|fn!:1157|)
                                                     |nfn!:1189|)
                                                    (("3"
                                                      (postpone)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (postpone) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (postpone) nil nil) ("3" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_existsrRf formula-decl nil dynamic_logic dL)
    (^^ const-decl "RealExpr" differentiation dL)
    (fresh_re_div_safe formula-decl nil fresh_props dL)
    (fresh_re_exp formula-decl nil fresh_props dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_subf formula-decl nil dynamic_logic dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (div_safe const-decl "real" reals_safe_ops reals)
    (exp_0 formula-decl nil ln_exp lnexp)
    (expt const-decl "real" differentiation dL)
    (^^ const-decl "nnreal" expt lnexp)
    (ln const-decl "real" ln_exp lnexp)
    (Integral const-decl "real" integral_def analysis)
    (sqrt_hathat formula-decl nil differentiation dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (dl_dift_pow formula-decl nil differentiation dL)
    (dl_dift_val formula-decl nil differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (scal_function formula-decl nil real_fun_ops reals)
    (max_var const-decl "nat" hp_def dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (DLEXISTSRf const-decl "bool" bool_expr dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (fresh_be_DLTRUE formula-decl nil fresh_props dL)
    (fresh_be_gt formula-decl nil fresh_props dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (cont_re_cnst formula-decl nil continuity_re_props dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (Assigns type-eq-decl nil hp_def dL)
    (fresh_li? inductive-decl "bool" hp_expr dL)
    (fresh? def-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "BoolExpr" bool_expr dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (dl_differential_ghost formula-decl nil dynamic_logic dL))
   shostak))
 (dl_diffinit_example 0
  (dl_diffinit_example-1 nil 3877095523
   ("" (skeep) (("" (dl-diffinit) nil nil)) nil)
   ((null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (dl_dinit formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL) (ODEs type-eq-decl nil hp_def dL)
    (delta__150 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   shostak))
 (dl_diffinv_example 0
  (dl_diffinv_example-1 nil 3876429090
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-diffinv) (("" (dl-assert) nil nil)) nil)) nil))
    nil)
   ((NQBool type-decl nil NQBool_adt dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (NQB_REL type-decl nil hp_def dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (ddl_dom? const-decl "bool" differentiation dL)
    (gamma__154 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__155 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (nnqb__153 skolem-const-decl "{nnqbe: NormNQBool |
   nqb_to_be(nnqbe) =
    nqb_to_be(NQB_rel(nqb_eq, val(x) ^ 2 + val(y) ^ 2, cnst(1)))}"
     Glossary_Plaidypvs nil)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (max_var const-decl "nat" hp_def dL)
    (diff_re_sum formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (delta__157 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (gamma__156 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (dl_dift_plus formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_dift_pow formula-decl nil differentiation dL)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (dl_dift_val formula-decl nil differentiation dL)
    (y skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (<= const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_var_max formula-decl nil hp_def dL)
    (length_singleton formula-decl nil more_list_props structures)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (dl_dift_const formula-decl nil differentiation dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (val const-decl "real" hp_def dL)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (delta__152 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (gamma__151 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   shostak))
 (dl_falseL_example 0
  (dl_falseL_example-1 nil 3877095184
   ("" (skeep) (("" (dl-falseL) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_falseL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (gamma__158 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil))
   shostak))
 (dl_flatten_example 0
  (dl_flatten_example-1 nil 3873838249
   ("" (skeep) (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (delta__167 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (dl_orL formula-decl nil dynamic_logic dL)
    (gamma__166 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (gamma__164 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__165 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (gamma__162 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__163 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__161 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (DLOR const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (gamma__160 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   shostak))
 (dl_g_example 0
  (dl_g_example-2 nil 3911917946
   ("" (skeep) (("" (dl-Gb) (("" (dl-assert) nil nil)) nil)) nil)
   ((real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (HP type-decl nil HP_adt dL) (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (DLBOOL const-decl "bool" bool_expr dL)
    (TRUE const-decl "bool" booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (dl_const formula-decl nil dynamic_logic dL))
   nil)
  (dl_g_example-1 nil 3882037873
   ("" (dl-Gb) (("" (dl-assert) nil nil)) nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (HP type-decl nil HP_adt dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLBOOL const-decl "bool" bool_expr dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (dl_const formula-decl nil dynamic_logic dL))
   shostak))
 (dl_ghost_example 0
  (dl_ghost_example-2 nil 3911917965
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-ghost "val(x)*val(y)")
        (("" (dl-diffinv) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((dl_discrete_ghost formula-decl nil dynamic_logic dL)
    (gamma__170 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__171 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__173 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__172 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (y skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (delta__175 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__174 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (length_singleton formula-decl nil more_list_props structures)
    (max_var_max formula-decl nil hp_def dL)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (dl_dift_val formula-decl nil differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (gamma__179 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (delta__180 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_true_DDL formula-decl nil differentiation dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (max_var const-decl "nat" hp_def dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (nnqb__176 skolem-const-decl "{nnqbe: NormNQBool |
   nqb_to_be(nnqbe) = nqb_to_be(NQB_rel(nqb_ge, val(x) * val(y), cnst(2)))}"
     Glossary_Plaidypvs nil)
    (delta__178 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__177 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (ddl_dom? const-decl "bool" differentiation dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_ge adt-constructor-decl "(nqb_ge?)" hp_def dL)
    (nqb_ge? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (delta__169 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (gamma__168 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_ghost_example-1 nil 3882037814
   ("" (dl-flatten)
    (("" (dl-ghost "val(x)*val(y)")
      (("" (dl-diffinv)
        (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_discrete_ghost formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (dl_dift_val formula-decl nil differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (scal_function formula-decl nil real_fun_ops reals)
    (max_var const-decl "nat" hp_def dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_ge adt-constructor-decl "(nqb_ge?)" hp_def dL)
    (nqb_ge? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_grind_example 0
  (dl_grind_example-2 nil 3911917998
   ("" (skeep) (("" (dl-grind) nil nil)) nil)
   ((iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (sqrt_pos application-judgement "posreal" sqrt reals)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (gamma__185 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__186 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (gamma__183 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__184 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__182 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (nnreal type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (>= const-decl "BoolExpr" bool_expr dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (gamma__181 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__188 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (dl_orL formula-decl nil dynamic_logic dL)
    (gamma__187 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_grind_example-1 nil 3882037803 ("" (dl-grind) nil nil)
   ((iterate_left const-decl "T" for_iterate structures)
    (sqrt_pos application-judgement "posreal" sqrt reals)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (>= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL))
   shostak))
 (dl_ground_example 0
  (dl_ground_example-2 nil 3911918063
   ("" (skeep)
    (("" (dl-ground)
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (gamma__191 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__192 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__190 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (gamma__189 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__194 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_orL formula-decl nil dynamic_logic dL)
    (gamma__193 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__195 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__196 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_ground_example-1 nil 3882037789
   ("" (dl-ground)
    (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (dl_hide_example 0
  (dl_hide_example-2 nil 3911918089
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-hide -2)
        (("" (dl-hide + :but 3)
          (("" (dl-hide -2) (("" (dl-assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((length_singleton formula-decl nil more_list_props structures)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (gamma__207 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (delta__208 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (gamma__213 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__214 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (delta__212 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__211 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__210 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (gamma__209 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (gamma__205 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__206 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__203 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__204 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (gamma__201 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__202 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (gamma__199 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__200 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__198 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (DLOR const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (/= const-decl "BoolExpr" bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (gamma__197 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_hide_example-1 nil 3873839405
   ("" (dl-flatten)
    (("" (dl-hide -2)
      (("" (dl-hide + :but 3)
        (("" (dl-hide -2) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((length_singleton formula-decl nil more_list_props structures)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_hiderest_example 0
  (dl_hiderest_example-2 nil 3911918116
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-hiderest (-1 3)) (("" (dl-assert) nil nil)) nil)) nil))
    nil)
   ((dl_hide_restR formula-decl nil dynamic_logic dL)
    (gamma__225 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__227 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_hide_restL formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (gamma__223 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__224 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__221 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__222 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (gamma__219 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__220 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (gamma__217 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__218 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__216 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (DLOR const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (/= const-decl "BoolExpr" bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (gamma__215 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_hiderest_example-1 nil 3873839746
   ("" (dl-flatten)
    (("" (dl-hiderest (-1 3)) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_hide_restR formula-decl nil dynamic_logic dL)
    (dl_hide_restL formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_iff_example 0
  (dl_iff_example-2 nil 3911918166
   ("" (skeep)
    (("" (dl-iffR)
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
    nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (gamma__229 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_equivR formula-decl nil dynamic_logic dL)
    (delta__230 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (dl_iff_example-1 nil 3882037750
   ("" (dl-iffR) (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil))
    nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_equivR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil))
   shostak))
 (dl_inst_example 0
  (dl_inst_example-2 nil 3911918179
   ("" (skeep)
    (("" (dl-inst "-1")
      (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil))
    nil)
   ((gamma__233 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__234 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_testb formula-decl nil dynamic_logic dL)
    (gamma__235 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__236 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (gamma__231 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (>= const-decl "BoolExpr" bool_expr dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (dl_existsR formula-decl nil dynamic_logic dL)
    (delta__232 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (dl_inst_example-1 nil 3882037720
   ("" (dl-inst "-1")
    (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_impliesR formula-decl nil dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_existsR formula-decl nil dynamic_logic dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (dl_impliesL_example 0
  (dl_impliesL_example-2 nil 3911918198
   ("" (skeep) (("" (dl-impliesL) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (delta__238 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (gamma__237 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_impliesL_example-1 nil 3877103939
   ("" (flatten) (("" (dl-impliesL) nil nil)) nil)
   ((> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_impliesR_example 0
  (dl_impliesR_example-2 nil 3911918216
   ("" (skeep) (("" (dl-impliesR) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (< const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (dl_impliesR formula-decl nil dynamic_logic dL))
   nil)
  (dl_impliesR_example-1 nil 3877432643
   ("" (flatten) (("" (dl-impliesR) nil nil)) nil)
   ((dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_iterated_example 0
  (dl_iterated_example-2 nil 3911918234
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-iterated) (("" (dl-assert) nil nil)) nil)) nil))
    nil)
   ((dl_iterated formula-decl nil dynamic_logic dL)
    (gamma__243 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__244 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (DLOR const-decl "bool" bool_expr dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (delta__246 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__245 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (delta__242 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (gamma__241 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_iterated_example-1 nil 3882037631
   ("" (dl-flatten) (("" (dl-iterated) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_iterated formula-decl nil dynamic_logic dL)
    (DLOR const-decl "bool" bool_expr dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_K_example 0
  (dl_K_example-2 nil 3911918249
   ("" (skeep)
    (("" (dl-K)
      (("" (dl-assert-pairwise_distinct_vars?)
        (("" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_implies formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (delta__250 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (gamma__249 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (gamma__247 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (HP type-decl nil HP_adt dL) (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_distimpliesb formula-decl nil dynamic_logic dL)
    (delta__248 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL))
   nil)
  (dl_K_example-1 nil 3882037583
   ("" (dl-K) (("" (dl-assert) nil nil)) nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_sub_implies formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (dl_distimpliesb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL))
   shostak))
 (dl_loop_example 0
  (dl_loop_example-2 nil 3911918270
   ("" (skeep)
    (("" (dl-assert-pairwise_distinct_vars?)
      (("" (dl-flatten)
        (("" (dl-loop "val(x)>=cnst(1) and val(y) >=cnst(1)")
          (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)
           ("3" (dl-assignb) (("3" (dl-assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((gamma__251 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__252 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (delta__254 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (gamma__253 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (gamma__261 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__262 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_and formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (gamma__263 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__264 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (delta__266 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__265 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__260 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__259 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (delta__258 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__257 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (delta__256 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__255 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_loop formula-decl nil dynamic_logic dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL))
   nil)
  (dl_loop_example-1 nil 3882037490
   ("" (dl-flatten)
    (("" (dl-loop "val(x)>=cnst(1) and val(y) >=cnst(1)")
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)
       ("3" (dl-assignb) (("3" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_loop formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_and formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_Mb_example 0
  (dl_Mb_example-2 nil 3911918293
   ("" (skeep) (("" (dl-Mb) (("" (dl-assert) nil nil)) nil)) nil)
   ((iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (/= const-decl "boolean" notequal nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (gamma__269 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__270 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (cnst const-decl "real" hp_def dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (dl_impliesallrunsb formula-decl nil dynamic_logic dL)
    (delta__268 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL))
   nil)
  (dl_Mb_example-1 nil 3882037475
   ("" (dl-Mb) (("" (dl-assert) nil nil)) nil)
   ((iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (dl_impliesallrunsb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL))
   shostak))
 (dl_monob_example 0
  (dl_monob_example-1 nil 3882037373
   ("" (skeep)
    (("" (dl-assert-pairwise_distinct_vars?)
      (("" (dl-flatten)
        (("" (dl-monob "val(x) = cnst(0) AND val(y) = cnst(c)")
          (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((gamma__271 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__272 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (delta__274 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (gamma__273 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (delta__280 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__279 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (gamma__277 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__278 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_and formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (delta__276 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__275 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_MbR formula-decl nil dynamic_logic dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL))
   shostak))
 (dl_move_example 0
  (dl_move_example-2 nil 3911918322
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-move -2)
        (("" (dl-move 2) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (length def-decl "nat" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (append def-decl "list[T]" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (gamma__285 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__286 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (gamma__283 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__284 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__282 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (gamma__281 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_move_example-1 nil 3873840108
   ("" (dl-flatten)
    (("" (dl-move -2) (("" (dl-move 2) (("" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLOR const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_notL_example 0
  (dl_notL_example-2 nil 3911918337
   ("" (skeep) (("" (dl-notL) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_notL formula-decl nil dynamic_logic dL)
    (delta__288 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (gamma__287 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_notL_example-1 nil 3877105333
   ("" (flatten) (("" (dl-notL) nil nil)) nil)
   ((> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_notL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_notR_example 0
  (dl_notR_example-2 nil 3911918348
   ("" (skeep) (("" (dl-notR) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (< const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (dl_notR formula-decl nil dynamic_logic dL))
   nil)
  (dl_notR_example-1 nil 3877432902
   ("" (flatten) (("" (dl-notR) nil nil)) nil)
   ((dl_notR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_orL_example 0
  (dl_orL_example-2 nil 3911918362
   ("" (skeep) (("" (dl-orL) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_orL formula-decl nil dynamic_logic dL)
    (delta__292 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (gamma__291 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_orL_example-1 nil 3877433988
   ("" (flatten) (("" (dl-orL) nil nil)) nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (<= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_orR_example 0
  (dl_orR_example-2 nil 3911918374
   ("" (skeep) (("" (dl-orR) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (dl_orR formula-decl nil dynamic_logic dL))
   nil)
  (dl_orR_example-1 nil 3877433188
   ("" (flatten) (("" (dl-orR) nil nil)) nil)
   ((dl_orR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_pp_example 0
  (dl_pp_example-2 nil 3911918388
   ("" (skeep) (("" (dl-pp) (("" (dl-assert) nil nil)) nil)) nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil))
   nil)
  (dl_pp_example-1 nil 3873840274
   ("" (dl-pp) (("" (dl-assert) nil nil)) nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (dl_skolem_example 0
  (dl_skolem_example-2 nil 3911918401
   ("" (skeep) (("" (dl-skolem) (("" (dl-assert) nil nil)) nil)) nil)
   ((delta__298 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (gamma__297 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (gamma__295 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (delta__296 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (dl_skolem_example-1 nil 3877439517
   ("" (dl-skolem) (("" (dl-assert) nil nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil))
   shostak))
 (dl_solve_example1 0
  (dl_solve_example1-2 "" 3911710141
   ("" (skeep)
    (("" (dl-flatten) (("" (dl-solve) (("" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((solution_domain_ax_cnst_imp_zip formula-decl nil dl_solution dL)
    (y skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (env_nat_shift const-decl "real" dl_solution dL)
    (env_c const-decl "real" dl_solution dL)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (is_cnst? const-decl "bool" dl_solution dL)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (in_map const-decl "bool" hp_def dL)
    (/= const-decl "boolean" notequal nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def dL)
    (dlvar adt-constructor-decl "[nat -> (dlvar?)]" hp_def dL)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (delta__309 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__308 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (gamma__312 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__313 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__310 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__311 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_sub_bool_restricted formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_le formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (<= const-decl "bool" reals nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (for const-decl "T" for_iterate structures)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_singleton formula-decl nil more_list_props structures)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (gamma__316 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (delta__317 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (delta__300 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (gamma__299 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   shostak)
  (dl_solve_example1-1 nil 3882037333
   ("" (dl-flatten) (("" (dl-solve) (("" (dl-assert) nil nil)) nil))
    nil)
   ((solution_domain_ax_cnst_imp_zip formula-decl nil dl_solution dL)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (get_val_cnst_id_ex const-decl "{vc: [below(length(l)), real] |
   vc`1 /= i AND
    nth(l, i)`2 = cnst(vc`2) + val(nth(l, vc`1)`1) AND
     (FORALL (c: real, m: below(length(l))):
        nth(l, i)`2 = cnst(c) + val(nth(l, m)`1) IMPLIES
         (m = vc`1 AND vc`2 = c))}" dl_solution dL)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (is_cnst? const-decl "bool" dl_solution dL)
    (in_map_ex def-decl "bool" dl_solution dL)
    (env_c const-decl "real" dl_solution dL)
    (env_nat_shift const-decl "real" dl_solution dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_sub_bool_restricted formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_le formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length_singleton formula-decl nil more_list_props structures)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (val const-decl "real" hp_def dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_solve_example2 2
  (dl_solve_example2-4 "" 3911989205
   ("" (skeep)
    ((""
      (deftactic simplify_init_zip_sol (&optional (tac-fnum -1))
       (for@ nil
        (then (expand "init_zip_sol" tac-fnum)
         (for@ nil (expand "length" tac-fnum)))))
      ((""
        (deftactic expand_in_map_ex (&optional (tac-fnum -1))
         (for@ nil (expand "in_map_ex" tac-fnum)))
        (("" (deftactic lift_them_all nil (for@ nil (lift-if)))
          ((""
            (deftactic simplify_evaluable_ites nil
             (let ((allruns_assign_expr '"allruns_assign_expr_864")
                   (*allruns_assign_expr* '|allruns_assign_expr:18751|)
                   (solution_lemma '|solution_lemma:18750|)
                   (fnum 'nil)
                   (skolem-constant '"t")
                   (quiet? 't)
                   (dlseq
                    '(1 typechecked "(: :) |-
 (: ALLRUNS(DIFF((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :), val(z) = val(x)), val(z) = val(x)) :)"
                      "bool"))
                   (skolem-constant '"t")
                   (passed-checks '"t")
                   (turn-rw-msg-on? 'nil)
                   (lemma-to-use
                    '"solution_domain_ax_cnst_imp_zip_no_hyp")
                   (fnum '1)
                   (ite (extra-get-expr '(~ -1 "%{if_}"))))
               (when ite
                 (let ((guard (args1 ite)))
                   (then (eval-expr guard :quiet? t)
                    (replace -1 :hide? t))))))
            ((""
              (deftactic simplify_Y_sol_ex (&optional (tac-fnum -1))
               (then (expand "Y_sol_ex" tac-fnum 1)
                (expand "get_val_cnst_id_ex" tac-fnum)
                (expand "is_val_not_in_map?" tac-fnum)
                (expand "is_cnst?" tac-fnum)
                (expand_in_map_ex tac-fnum) (simplify_nth)
                (beta tac-fnum)
                (for@ nil
                 (rewrites "env_nat_shift_cnst" :fnums tac-fnum))
                (rewrites ("env_nat_shift_0_val" "env_c_val"
                           "env_nat_shift_1_val")
                          :fnums tac-fnum)
                (simplify_evaluable_ites)
                (let ((allruns_assign_expr '"allruns_assign_expr_864")
                      (*allruns_assign_expr*
                       '|allruns_assign_expr:18751|)
                      (solution_lemma '|solution_lemma:18750|)
                      (fnum 'nil)
                      (skolem-constant '"t")
                      (quiet? 't)
                      (dlseq
                       '(1 typechecked "(: :) |-
 (: ALLRUNS(DIFF((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :), val(z) = val(x)), val(z) = val(x)) :)"
                         "bool"))
                      (skolem-constant '"t")
                      (passed-checks '"t")
                      (turn-rw-msg-on? 'nil)
                      (lemma-to-use
                       '"solution_domain_ax_cnst_imp_zip_no_hyp")
                      (fnum '1)
                      (actual-fnum (lisp (extra-get-fnum tac-fnum))))
                  (match actual-fnum "get_index(%a{list})(%)" step
                         (then (eval-expr $aj :quiet? t)
                          (replace -1 :hide? t) (simplify_nth))))
                (beta tac-fnum)))
              (("" (lemma "solution_domain_ax_cnst_imp_zip_no_hyp")
                (("" (inst?)
                  (("1"
                    (with-labels (skoletin)
                     ((|solution_lemma:18750| Z_def nil)))
                    (("1" (beta |solution_lemma:18750|)
                      (("1" (split |solution_lemma:18750|)
                        (("1" (propax) nil nil)
                         ("2"
                          (hide-all-but
                           (|solution_lemma:18750| Z_def '-))
                          (("2" (expand "zs" Z_def)
                            (("2" (simplify_init_zip_sol Z_def)
                              (("2"
                                (for@ nil (simplify_nth))
                                (("2"
                                  (beta Z_def)
                                  (("2"
                                    (simplify_Y_sol_ex Z_def)
                                    (("2"
                                      (simplify_Y_sol_ex Z_def)
                                      (("2"
                                        (name
                                         "bla"
                                         "Y_sol_ex((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(2)")
                                        (("1"
                                          (label "bla-label" -1)
                                          (("1"
                                            (replace "bla-label" Z_def)
                                            (("1"
                                              (expand
                                               "Y_sol_ex"
                                               "bla-label")
                                              (("1"
                                                (name-label*
                                                 ("is_const?_951"
                                                  (typechecked
                                                   "is_cnst?((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(2)"
                                                   "bool"))
                                                 :hide?
                                                 t
                                                 :label
                                                 (:pairing
                                                  |is_const?:20260|)
                                                 :tcc-label
                                                 (:pairing
                                                  |is_const?-tccs:20261|)
                                                 :tcc-step
                                                 (:pairing
                                                  (extra-tcc-step)))
                                                (("1"
                                                  (reveal
                                                   |is_const?:20260|)
                                                  (("1"
                                                    (expand
                                                     "is_cnst?"
                                                     |is_const?:20260|)
                                                    (("1"
                                                      (simplify_nth)
                                                      (("1"
                                                        (beta
                                                         |is_const?:20260|)
                                                        (("1"
                                                          (for@
                                                           nil
                                                           (then
                                                            (match
                                                             -1
                                                             "(%op(%a,%b))(%c) = (%op(%a,%b))(%d)"
                                                             step
                                                             (expand
                                                              "%op"
                                                              -1))
                                                            (match
                                                             -1
                                                             "cnst(%%)(%%)"
                                                             step
                                                             (expand
                                                              "cnst"
                                                              -1))
                                                            (match
                                                             -1
                                                             "val(%%)(%%)"
                                                             step
                                                             (then
                                                              (expand
                                                               "val"
                                                               -1)
                                                              (expand
                                                               "env_nat_shift"
                                                               -1)))))
                                                          (("1"
                                                            (replace
                                                             |is_const?:20260|
                                                             "bla-label"
                                                             :hide?
                                                             t)
                                                            (("1"
                                                              (delete
                                                               (|is_const?-tccs:20261|))
                                                              (("1"
                                                                (touch
                                                                 (delabel
                                                                  (|is_const?-tccs:20261|
                                                                   |is_const?:20260|)))
                                                                (("1"
                                                                  (name-label*
                                                                   ("is_val_not_in_map?_953"
                                                                    (typechecked
                                                                     "is_val_not_in_map?((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(2)"
                                                                     "bool"))
                                                                   :hide?
                                                                   t
                                                                   :label
                                                                   (:pairing
                                                                    |is_val_not_in_map?:20288|)
                                                                   :tcc-label
                                                                   (:pairing
                                                                    |is_val_not_in_map?-tccs:20289|)
                                                                   :tcc-step
                                                                   (:pairing
                                                                    (extra-tcc-step)))
                                                                  (("1"
                                                                    (reveal
                                                                     |is_val_not_in_map?:20288|)
                                                                    (("1"
                                                                      (expand
                                                                       "is_val_not_in_map?"
                                                                       -1)
                                                                      (("1"
                                                                        (simplify_nth)
                                                                        (("1"
                                                                          (beta
                                                                           -1)
                                                                          (("1"
                                                                            (expand
                                                                             "in_map_ex"
                                                                             -1)
                                                                            (("1"
                                                                              (expand
                                                                               "in_map_ex"
                                                                               -1)
                                                                              (("1"
                                                                                (expand
                                                                                 "in_map_ex"
                                                                                 -1)
                                                                                (("1"
                                                                                  (expand
                                                                                   "in_map_ex"
                                                                                   -1)
                                                                                  (("1"
                                                                                    (expand
                                                                                     "+"
                                                                                     -1)
                                                                                    (("1"
                                                                                      (expand
                                                                                       "cnst"
                                                                                       -1)
                                                                                      (("1"
                                                                                        (expand
                                                                                         "val"
                                                                                         -1)
                                                                                        (("1"
                                                                                          (expand
                                                                                           "env_nat_shift"
                                                                                           -1)
                                                                                          (("1"
                                                                                            (expand
                                                                                             "env_c"
                                                                                             -1)
                                                                                            (("1"
                                                                                              (expand
                                                                                               "pairwise_distinct_vars?")
                                                                                              (("1"
                                                                                                (expand
                                                                                                 "distinct_var?")
                                                                                                (("1"
                                                                                                  (expand
                                                                                                   "distinct_var?")
                                                                                                  (("1"
                                                                                                    (expand
                                                                                                     "distinct_var?")
                                                                                                    (("1"
                                                                                                      (postpone)
                                                                                                      nil
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (postpone) nil nil)
                                         ("3" (postpone) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (dl_solve_example2-3 "" 3911971771
   ("" (skeep)
    ((""
      (deftactic simplify_init_zip_sol (&optional (tac-fnum -1))
       (for@ nil
        (then (expand "init_zip_sol" tac-fnum)
         (for@ nil (expand "length" tac-fnum)))))
      ((""
        (deftactic expand_in_map_ex (&optional (tac-fnum -1))
         (for@ nil (expand "in_map_ex" tac-fnum)))
        (("" (deftactic lift_them_all nil (for@ nil (lift-if)))
          ((""
            (deftactic simplify_evaluable_ites nil
             (let ((allruns_assign_expr '"allruns_assign_expr_864")
                   (*allruns_assign_expr* '|allruns_assign_expr:18751|)
                   (solution_lemma '|solution_lemma:18750|)
                   (fnum 'nil)
                   (skolem-constant '"t")
                   (quiet? 't)
                   (dlseq
                    '(1 typechecked "(: :) |-
 (: ALLRUNS(DIFF((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :), val(z) = val(x)), val(z) = val(x)) :)"
                      "bool"))
                   (skolem-constant '"t")
                   (passed-checks '"t")
                   (turn-rw-msg-on? 'nil)
                   (lemma-to-use
                    '"solution_domain_ax_cnst_imp_zip_no_hyp")
                   (fnum '1)
                   (ite (extra-get-expr '(~ -1 "%{if_}"))))
               (when ite
                 (let ((guard (args1 ite)))
                   (then (eval-expr guard :quiet? t)
                    (replace -1 :hide? t))))))
            ((""
              (deftactic simplify_Y_sol_ex (&optional (tac-fnum -1))
               (then (expand "Y_sol_ex" tac-fnum 1)
                (expand "get_val_cnst_id_ex" tac-fnum)
                (expand "is_val_not_in_map?" tac-fnum)
                (expand "is_cnst?" tac-fnum)
                (expand_in_map_ex tac-fnum) (simplify_nth)
                (beta tac-fnum)
                (for@ nil
                 (rewrites "env_nat_shift_cnst" :fnums tac-fnum))
                (rewrites ("env_nat_shift_0_val" "env_c_val"
                           "env_nat_shift_1_val")
                          :fnums tac-fnum)
                (simplify_evaluable_ites)
                (let ((allruns_assign_expr '"allruns_assign_expr_864")
                      (*allruns_assign_expr*
                       '|allruns_assign_expr:18751|)
                      (solution_lemma '|solution_lemma:18750|)
                      (fnum 'nil)
                      (skolem-constant '"t")
                      (quiet? 't)
                      (dlseq
                       '(1 typechecked "(: :) |-
 (: ALLRUNS(DIFF((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :), val(z) = val(x)), val(z) = val(x)) :)"
                         "bool"))
                      (skolem-constant '"t")
                      (passed-checks '"t")
                      (turn-rw-msg-on? 'nil)
                      (lemma-to-use
                       '"solution_domain_ax_cnst_imp_zip_no_hyp")
                      (fnum '1)
                      (actual-fnum (lisp (extra-get-fnum tac-fnum))))
                  (match actual-fnum "get_index(%a{list})(%)" step
                         (then (eval-expr $aj :quiet? t)
                          (replace -1 :hide? t) (simplify_nth))))
                (beta tac-fnum)))
              (("" (lemma "solution_domain_ax_cnst_imp_zip_no_hyp")
                (("" (inst?)
                  (("1"
                    (with-labels (skoletin)
                     ((|solution_lemma:18750| Z_def nil)))
                    (("1" (beta |solution_lemma:18750|)
                      (("1" (split |solution_lemma:18750|)
                        (("1" (propax) nil nil)
                         ("2"
                          (hide-all-but
                           (|solution_lemma:18750| Z_def '-))
                          (("2" (expand "zs" Z_def)
                            (("2" (simplify_init_zip_sol Z_def)
                              (("2"
                                (for@ nil (simplify_nth))
                                (("2"
                                  (simplify_Y_sol_ex Z_def)
                                  (("2"
                                    (with-tccs
                                     (name
                                      "bla"
                                      "Y_sol_ex((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(1)"))
                                    (("2"
                                      (label "bla-label" -1)
                                      (("2"
                                        (replace "bla-label" Z_def)
                                        (("2"
                                          (expand
                                           "Y_sol_ex"
                                           "bla-label")
                                          (("2"
                                            (with-tccs
                                             (name
                                              "bli"
                                              "is_cnst?((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(1)"))
                                            (("2"
                                              (replace -1 "bla-label")
                                              (("2"
                                                (label "bli-label" -1)
                                                (("2"
                                                  (dl-calculate-is_cnst?
                                                   "bli-label")
                                                  (("2"
                                                    (replace
                                                     "bli-label"
                                                     "bla-label"
                                                     :hide?
                                                     t)
                                                    (("2"
                                                      (with-tccs
                                                       (name
                                                        "blo"
                                                        "is_val_not_in_map?((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(1)"))
                                                      (("2"
                                                        (replace -1 -2)
                                                        (("2"
                                                          (label
                                                           "blo-label"
                                                           -1)
                                                          (("2"
                                                            (dl-calculate-is_val_not_in_map?
                                                             "blo-label")
                                                            (("2"
                                                              (replace
                                                               "blo-label"
                                                               "bla-label"
                                                               :hide?
                                                               t)
                                                              (("2"
                                                                (with-tccs
                                                                 (name
                                                                  "ble"
                                                                  "get_val_cnst_id_ex((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(1)"))
                                                                (("2"
                                                                  (replace
                                                                   -1
                                                                   -2)
                                                                  (("2"
                                                                    (label
                                                                     "ble-label"
                                                                     -1)
                                                                    (("2"
                                                                      (dl-calculate-get_val_cnst_id_ex
                                                                       "ble-label")
                                                                      (("2"
                                                                        (replace
                                                                         "ble-label"
                                                                         :dir
                                                                         rl
                                                                         :hide?
                                                                         t)
                                                                        (("2"
                                                                          (beta
                                                                           "bla-label")
                                                                          (("2"
                                                                            (simplify_nth)
                                                                            (("2"
                                                                              (use
                                                                               "env_c_val")
                                                                              (("2"
                                                                                (replace
                                                                                 -1
                                                                                 "bla-label"
                                                                                 :hide?
                                                                                 t)
                                                                                (("2"
                                                                                  (replace
                                                                                   "bla-label"
                                                                                   :dir
                                                                                   rl
                                                                                   :hide?
                                                                                   t)
                                                                                  (("2"
                                                                                    (beta
                                                                                     Z_def)
                                                                                    (("2"
                                                                                      (postpone)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (dl_solve_example2-2 nil 3911710502
   ("" (skeep)
    (("" (dl-solve)
      (("" (dl-inst "t")
        (("" (dl-flatten)
          (("" (dl-ground) (("" (dl-assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (gamma__338 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_forallL formula-decl nil dynamic_logic dL)
    (delta__339 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (gamma__342 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__343 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (gamma__340 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (delta__341 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (PRED type-eq-decl nil defined_types nil)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (gamma__332 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__333 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__335 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (gamma__334 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__331 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (gamma__330 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (dlvar adt-constructor-decl "[nat -> (dlvar?)]" hp_def dL)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (/= const-decl "boolean" notequal nil)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (is_cnst? const-decl "bool" dl_solution dL)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (env_c const-decl "real" dl_solution dL)
    (env_nat_shift const-decl "real" dl_solution dL)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (in_map_ex def-decl "bool" dl_solution dL)
    (get_val_cnst_id_ex const-decl "{vc: [below(length(l)), real] |
   vc`1 /= i AND
    nth(l, i)`2 = cnst(vc`2) + val(nth(l, vc`1)`1) AND
     (FORALL (c: real, m: below(length(l))):
        nth(l, i)`2 = cnst(c) + val(nth(l, m)`1) IMPLIES
         (m = vc`1 AND vc`2 = c))}" dl_solution dL)
    (env_c_val formula-decl nil dl_solution dL)
    (ode_326 skolem-const-decl
     "(cons?[[dLVar, [Environment -> real]]])" Glossary_Plaidypvs nil)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (div_safe_re const-decl "real" hp_def dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (ODEs type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (Assigns type-eq-decl nil hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (quad_cnst? const-decl "bool" dl_solution dL)
    (get_index def-decl
     "{n: below(length(l)) | dlvar_index(nth(l, n)`1) = j}" dl_solution
     dL)
    (cnst_val_0 formula-decl nil dl_solution dL)
    (cnst_val_com formula-decl nil dl_solution dL)
    (in_map const-decl "bool" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (q skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (z skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (val const-decl "real" hp_def dL)
    (y skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (cnst const-decl "real" hp_def dL)
    (x skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (dLVar type-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (solution_domain_ax_cnst_imp_zip_no_hyp formula-decl nil
     dl_solution dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (dl_solve_example2-1 nil 3882037272
   ("" (dl-solve)
    (("" (dl-inst "t")
      (("" (dl-flatten)
        (("" (dl-ground) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((dl_forallL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (env_c_val formula-decl nil dl_solution dL)
    (env_nat_shift const-decl "real" dl_solution dL)
    (env_c const-decl "real" dl_solution dL)
    (in_map_ex def-decl "bool" dl_solution dL)
    (is_cnst? const-decl "bool" dl_solution dL)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (get_val_cnst_id_ex const-decl "{vc: [below(length(l)), real] |
   vc`1 /= i AND
    nth(l, i)`2 = cnst(vc`2) + val(nth(l, vc`1)`1) AND
     (FORALL (c: real, m: below(length(l))):
        nth(l, i)`2 = cnst(c) + val(nth(l, m)`1) IMPLIES
         (m = vc`1 AND vc`2 = c))}" dl_solution dL)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (HP type-decl nil HP_adt dL)
    (cnst_val_com formula-decl nil dl_solution dL)
    (get_index def-decl
     "{n: below(length(l)) | dlvar_index(nth(l, n)`1) = j}" dl_solution
     dL)
    (in_map const-decl "bool" hp_def dL)
    (quad_cnst? const-decl "bool" dl_solution dL)
    (cnst_val_0 formula-decl nil dl_solution dL)
    (bijective? const-decl "bool" functions nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (solution_domain_ax_cnst_imp_zip_no_hyp formula-decl nil
     dl_solution dL))
   shostak))
 (dl_subs_example 0
  (dl_subs_example-2 nil 3911918573
   ("" (skeep)
    (("" (dl-assert-pairwise_distinct_vars?)
      (("" (dl-flatten) (("" (dl-subs) (("" (dl-assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((gamma__344 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__345 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (for const-decl "T" for_iterate structures)
    (nth def-decl "T" list_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_exp formula-decl nil substitution dL)
    (dl_subre_plus formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL))
   nil)
  (dl_subs_example-1 nil 3873840950
   ("" (dl-flatten) (("" (dl-subs) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_subre_val formula-decl nil substitution dL)
    (dl_subre_exp formula-decl nil substitution dL)
    (dl_subre_plus formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (^ const-decl "[T -> real]" real_fun_ops reals))
   shostak))
 (dl_testb_example 0
  (dl_testb_example-2 nil 3911918600
   ("" (skeep)
    (("" (dl-flatten) (("" (dl-testb) (("" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((append def-decl "list[T]" list_props nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length def-decl "nat" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (gamma__350 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_testb formula-decl nil dynamic_logic dL)
    (delta__351 skolem-const-decl "(cons?)" Glossary_Plaidypvs nil)
    (gamma__352 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (delta__353 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (gamma__348 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__349 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__347 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (gamma__346 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_testb_example-1 nil 3877436527
   ("" (dl-flatten) (("" (dl-testb) (("" (dl-assert) nil nil)) nil))
    nil)
   ((move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_testd_example 0
  (dl_testd_example-2 nil 3911918621
   ("" (skeep) (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (dl_testd formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__355 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLAND const-decl "bool" bool_expr dL)
    (gamma__354 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_testd_example-1 nil 3877437670
   ("" (dl-flatten) (("" (dl-testd) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (dl_testd formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLAND const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_trueR_example 0
  (dl_trueR_example-2 nil 3911918646
   ("" (skeep) (("" (dl-trueR) nil nil)) nil)
   ((number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (<= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_trueR formula-decl nil dynamic_logic dL))
   nil)
  (dl_trueR_example-1 nil 3877101367 ("" (then (dl-trueR)) nil nil)
   ((Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_trueR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_Vb_example 0
  (dl_Vb_example-2 nil 3911918657
   ("" (skeep)
    (("" (dl-assert-pairwise_distinct_vars?)
      (("" (dl-flatten) (("" (dl-Vb) (("" (dl-assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((gamma__358 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (delta__359 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dLVar type-decl nil hp_def dL)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (bv_me def-decl "list[nat]" bound_variables_def dL)
    (length_singleton formula-decl nil more_list_props structures)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (fresh? const-decl "bool" hp_expr dL)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (i skolem-const-decl
       "below(length(BV(DIFF((: (y, val(y) * val(z)) :), DLBOOL(TRUE)))))"
       Glossary_Plaidypvs nil)
    (z skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (y skolem-const-decl "dLVar" Glossary_Plaidypvs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (fresh_re_val formula-decl nil fresh_props dL)
    (/= const-decl "boolean" notequal nil)
    (fresh_re_pow formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (listn_0 name-judgement "listn(0)" vector_arithmetic mv_analysis)
    (fresh_be_eq formula-decl nil fresh_props dL)
    (length def-decl "nat" list_props nil)
    (BV def-decl "list[nat]" bound_variables_def dL)
    (delta__361 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (gamma__360 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_V formula-decl nil dynamic_logic dL)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL))
   nil)
  (dl_Vb_example-1 nil 3882037166
   ("" (dl-flatten) (("" (dl-Vb) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_V formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (BV def-decl "list[nat]" bound_variables_def dL)
    (fresh_be_eq formula-decl nil fresh_props dL)
    (fresh_re_pow formula-decl nil fresh_props dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_weak_example 0
  (dl_weak_example-2 nil 3911918686
   ("" (skeep)
    (("" (dl-flatten)
      (("" (dl-weak "val(y)=cnst(25)")
        (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_weakR formula-decl nil dynamic_logic dL)
    (gamma__367 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (delta__368 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (nth def-decl "T" list_props nil)
    (for const-decl "T" for_iterate structures)
    (length def-decl "nat" list_props nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (gamma__365 skolem-const-decl "(cons?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (delta__366 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (TRUE const-decl "bool" booleans nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (bijective? const-decl "bool" functions nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (delta__364 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (+ const-decl "[T -> real]" real_fun_ops reals)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (- const-decl "[T -> real]" real_fun_ops reals)
    (* const-decl "[T -> real]" real_fun_ops reals)
    (gamma__363 skolem-const-decl "(null?[BoolExpr])"
     Glossary_Plaidypvs nil))
   nil)
  (dl_weak_example-1 nil 3882037184
   ("" (dl-flatten)
    (("" (dl-weak "val(y)=cnst(25)")
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
    nil)
   ((dl_weakR formula-decl nil dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak)))


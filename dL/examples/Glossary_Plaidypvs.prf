(Glossary_Plaidypvs
 (dl_axiom_example 0
  (n "n" 3876421024 ("" (then (skeep) (dl-axiom 3)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_moveR formula-decl nil dynamic_logic dL))
   shostak)
  (dl_axiom_example-1 nil 3876420819
   ("" (dl-flatten) (("" (postpone) nil nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL) (list type-decl nil list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (dl_andL_example 0
  (dl_andL_example-1 nil 3876421306
   ("" (then (skeep) (dl-andL) (dl-axiom)) nil)
   ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_axiom formula-decl nil dynamic_logic dL))
   shostak))
 (dl_andR_example 0
  (dl_andR_example-1 nil 3876422373
   (""
    (then (skeep) (dl-flatten)
     (spread (dl-andR) ((dl-axiom) (dl-assert))))
    nil)
   ((cnst const-decl "real" hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_anyb_example 0
  (dl_anyb_example-1 nil 3873836410
   (""
    (then (skeep) (dl-anyb) (dl-skolem "X") (dl-subs) (dl-flatten)
     (dl-assert))
    nil)
   ((bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_anyb_with formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_implies formula-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_forallR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_anyd_example 0
  (dl_anyd_example-1 nil 3873837253
   (""
    (then (skeep) (dl-anyd) (dl-inst "1") (dl-subs)
     (spread (dl-andR) ((dl-assert) (dl-assert))))
    nil)
   ((bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_anyd_with formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLEXISTS const-decl "bool" bool_expr dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (DLAND const-decl "bool" bool_expr dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_and formula-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_andR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_existsR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_assert_example 0
  (dl_assert_example-1 nil 3876423003
   ("" (then (skeep) (beta) (dl-assert)) nil)
   ((SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (HP type-decl nil HP_adt dL)
    (union? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (UNION adt-constructor-decl "[[HP, HP] -> (union?)]" HP_adt dL)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (DLOR const-decl "bool" bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (dl_subre_plus formula-decl nil substitution dL)
    (dl_sub_or formula-decl nil substitution dL)
    (dl_sub_gt formula-decl nil substitution dL)
    (SUB_Re const-decl "real" substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_minus formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_andR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (DLAND const-decl "bool" bool_expr dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for const-decl "T" for_iterate structures))
   shostak))
 (dl_assignb_example 0
  (dl_assignb_example-1 nil 3876423972
   ("" (then (skeep) (dl-assignb) (dl-assert)) nil)
   ((val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (Assigns type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL))
   shostak))
 (dl_assignd_example 0
  (dl_assignd_example-1 nil 3876424097
   ("" (then (skeep) (dl-assignd) (dl-assert)) nil)
   ((val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (Assigns type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL))
   shostak))
 (dl_boxd_example 0
  (dl_boxd_example-1 nil 3876424196 ("" (then (skeep) (dl-assert)) nil)
   ((iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_notR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_lt formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (Assigns type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_assignd formula-decl nil dynamic_logic dL))
   shostak))
 (dl_choiceb_example 0
  (dl_choiceb_example-1 nil 3876424762
   (""
    (then (skeep) (dl-choiceb)
     (spread (dl-andR) ((dl-assert) (dl-assert))))
    nil)
   ((cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (DLAND const-decl "bool" bool_expr dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_andR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_choiced_example 0
  (dl_choiced_example-1 nil 3876428543
   (""
    (then (skeep) (dl-choiced) (dl-ground) (dl-hide 2) (dl-assignd)
     (dl-assert))
    nil)
   ((cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_choiced formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (DLOR const-decl "bool" bool_expr dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_composeb_example 0
  (dl_composeb_example-1 nil 3876430667
   (""
    (then (skeep) (dl-composeb) (dl-assignb) (dl-testb) (dl-flatten)
     (dl-assert))
    nil)
   ((cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (val const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_lt formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL))
   shostak))
 (dl_composed_example 0
  (dl_composed_example-1 nil 3876430708
   (""
    (then (skeep) (dl-flatten) (dl-composed) (rewrite "dl_testd")
     (dl-assignd) (dl-assert))
    nil)
   ((ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (dl_testd formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (DLAND const-decl "bool" bool_expr dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (dl_composed formula-decl nil dynamic_logic dL))
   shostak))
 (dl_case_example 0
  (dl_case_example-1 nil 3876430559
   (""
    (then (skeep)
     (spread (dl-case "cnst(c) >= cnst(0)")
      ((then (dl-choiceb) (spread (dl-andR) ((dl-assert) (dl-assert))))
       (dl-assert))))
    nil)
   ((dl_cut formula-decl nil dynamic_logic dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (union? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (UNION adt-constructor-decl "[[HP, HP] -> (union?)]" HP_adt dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (DLNOT const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_notL formula-decl nil dynamic_logic dL)
    (DLAND const-decl "bool" bool_expr dL)
    (dl_choiceb formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL))
   shostak))
 (dl_diffcase_example 0
  (dl_diffcase_example-1 nil 3877099018
   (""
    (then (skeep) (dl-flatten)
     (spread (dl-diffcase "val(x) ^ 2 > cnst(5)")
      ((dl-assert) (dl-assert))))
    nil)
   ((DLBOOL const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_dC formula-decl nil dynamic_logic dL))
   shostak))
 (dl_diffghost_example 0
  (dl_diffghost_example-2 "" 3911913342
   (""
    (then (skeep) (beta) (dl-flatten)
     (spread
      (dl-diffghost "cnst(-1/2)" "cnst(0)" "G"
       "val(x)*val(G)^2=cnst(1)")
      ((then (dl-instf "div_safe_re(cnst(1),val(x)^^(1/2))")
        (dl-composeb) (dl-assignb) (dl-subf)
        (spread (dl-diffinv)
         ((spread (grind :exclude "^^")
           ((grind) (then (lemma "sqrt_hathat") (grind))))
          (dl-assert))))
       (dl-assert) (dl-assert))))
    nil)
   ((fresh_var formula-decl nil hp_def dL)
    (dl_differential_ghost formula-decl nil dynamic_logic dL)
    (Assigns type-eq-decl nil hp_def dL)
    (fresh_li? inductive-decl "bool" hp_expr dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (fresh? def-decl "bool" bool_expr dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (cont_re_cnst formula-decl nil continuity_re_props dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (fresh_be_gt formula-decl nil fresh_props dL)
    (fresh_be_DLTRUE formula-decl nil fresh_props dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (DLEXISTSRf const-decl "bool" bool_expr dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (dl_subf formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (div_safe const-decl "real" reals_safe_ops reals)
    (exp_0 formula-decl nil ln_exp lnexp)
    (expt const-decl "real" differentiation dL)
    (^^ const-decl "nnreal" expt lnexp)
    (ln const-decl "real" ln_exp lnexp)
    (Integral const-decl "real" integral_def analysis)
    (sqrt_hathat formula-decl nil differentiation dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (dl_dift_pow formula-decl nil differentiation dL)
    (length_singleton formula-decl nil more_list_props structures)
    (max_var_max formula-decl nil hp_def dL)
    (dl_dift_val formula-decl nil differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (max_var const-decl "nat" hp_def dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (fresh_re_exp formula-decl nil fresh_props dL)
    (fresh_re_div_safe formula-decl nil fresh_props dL)
    (^^ const-decl "RealExpr" differentiation dL)
    (div_safe_re const-decl "real" hp_def dL)
    (dl_existsrRf formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL))
   shostak)
  (dl_diffghost_example-1 nil 3882037909
   ("" (skeep)
    (("" (beta)
      (("" (dl-flatten)
        ((""
          (dl-diffghost "cnst(-1/2)" "cnst(0)" "G"
           "val(x)*val(G)^2=cnst(1)")
          (("1" (dl-instf "div_safe_re(cnst(1),val(x)^^(1/2))")
            (("1" (dl-composeb)
              (("1" (dl-assignb)
                (("1" (dl-subf)
                  (("1" (relabel (:pairing |fn!:1157|) (1))
                    (("1"
                      (name-label*
                       ("nnqb__49"
                        (typechecked
                         "normalize(NQB_rel(nqb_eq, val(x) * val(G) ^ 2, cnst(1)))"
                         "{nnqbe: NormNQBool |
   nqb_to_be(nnqbe) =
    nqb_to_be(NQB_rel(nqb_eq,
                      *[Environment](val(x), ^[Environment](val(G), 2)),
                      cnst(1)))}"))
                       :hide? t :label (:pairing |nnqb_:1158|)
                       :tcc-label (:pairing nil) :tcc-step
                       (:pairing nil))
                      (("1"
                        (case-replace
                         "(val(x) * val(G) ^ 2 = cnst(1))=nqb_to_be(nnqb__49)")
                        (("1" (relabel (:pairing |castr!:1164|) (-1))
                          (("1" (relabel (:pairing |fn!:1165|) (1))
                            (("1"
                              (name-label*
                               ("gamma__50"
                                (! |fn!:1165| 1)
                                "delta__51"
                                (! |fn!:1165| 2 2))
                               :hide? t)
                              (("1"
                                (lemma "dl_dI_dlTRUE")
                                (("1"
                                  (relabel (:pairing |nfn!:1189|) (-1))
                                  (("1"
                                    (with-tccs
                                     (inst?
                                      |nfn!:1189|
                                      :where
                                      |fn!:1165|
                                      :polarity?
                                      t)
                                     :tcc-step
                                     (assert))
                                    (("1"
                                      (relabel
                                       (|fn!:1157|)
                                       |nfn!:1189|)
                                      (("1"
                                        (replaces
                                         |fn!:1165|
                                         :in
                                         |nfn!:1189|)
                                        (("1"
                                          (expand*
                                           ("gamma__50" "delta__51"))
                                          (("1"
                                            (replaces
                                             |castr!:1164|
                                             :dir
                                             rl)
                                            (("1"
                                              (expand*
                                               "nnqb__49"
                                               "normalize")
                                              (("1"
                                                (for@
                                                 nil
                                                 (expand
                                                  "normalize_rec"))
                                                (("1"
                                                  (split |nfn!:1189|)
                                                  (("1"
                                                    (postpone)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (relabel
                                                     (|fn!:1157|)
                                                     |nfn!:1189|)
                                                    (("2"
                                                      (postpone)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (relabel
                                                     (|fn!:1157|)
                                                     |nfn!:1189|)
                                                    (("3"
                                                      (postpone)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (postpone) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (postpone) nil nil) ("3" (postpone) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_existsrRf formula-decl nil dynamic_logic dL)
    (^^ const-decl "RealExpr" differentiation dL)
    (fresh_re_div_safe formula-decl nil fresh_props dL)
    (fresh_re_exp formula-decl nil fresh_props dL)
    (dl_composeb formula-decl nil dynamic_logic dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_subf formula-decl nil dynamic_logic dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (div_safe const-decl "real" reals_safe_ops reals)
    (exp_0 formula-decl nil ln_exp lnexp)
    (expt const-decl "real" differentiation dL)
    (^^ const-decl "nnreal" expt lnexp)
    (ln const-decl "real" ln_exp lnexp)
    (Integral const-decl "real" integral_def analysis)
    (sqrt_hathat formula-decl nil differentiation dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (dl_dift_pow formula-decl nil differentiation dL)
    (dl_dift_val formula-decl nil differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (scal_function formula-decl nil real_fun_ops reals)
    (max_var const-decl "nat" hp_def dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (DLEXISTSRf const-decl "bool" bool_expr dL)
    (seq? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SEQ adt-constructor-decl "[[HP, HP] -> (seq?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (fresh_be_DLTRUE formula-decl nil fresh_props dL)
    (fresh_be_gt formula-decl nil fresh_props dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (cont_re_cnst formula-decl nil continuity_re_props dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (Assigns type-eq-decl nil hp_def dL)
    (fresh_li? inductive-decl "bool" hp_expr dL)
    (fresh? def-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "BoolExpr" bool_expr dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (dl_differential_ghost formula-decl nil dynamic_logic dL))
   shostak))
 (dl_diffinit_example 0
  (dl_diffinit_example-1 nil 3877095523
   ("" (then (skeep) (dl-diffinit)) nil)
   ((ODEs type-eq-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_dinit formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (dl_diffinv_example 0
  (dl_diffinv_example-1 nil 3876429090
   ("" (then (skeep) (dl-flatten) (dl-diffinv) (dl-assert)) nil)
   ((DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (length_singleton formula-decl nil more_list_props structures)
    (max_var_max formula-decl nil hp_def dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (dl_dift_val formula-decl nil differentiation dL)
    (dl_dift_pow formula-decl nil differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (derivable_up? const-decl "bool" differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_pow formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_plus formula-decl nil differentiation dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (diff_re_pow formula-decl nil diff_re_props dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_sum formula-decl nil diff_re_props dL)
    (max_var const-decl "nat" hp_def dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_eq adt-constructor-decl "(nqb_eq?)" hp_def dL)
    (nqb_eq? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL))
   shostak))
 (dl_falseL_example 0
  (dl_falseL_example-1 nil 3877095184
   ("" (then (skeep) (dl-falseL)) nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (dl_falseL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_flatten_example 0
  (dl_flatten_example-1 nil 3873838249
   ("" (then (skeep) (dl-flatten) (dl-assert)) nil)
   ((^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures))
   shostak))
 (dl_g_example 0
  (dl_g_example-2 nil 3911917946
   ("" (then (skeep) (dl-Gb) (dl-assert)) nil)
   ((dl_const formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL))
   nil)
  (dl_g_example-1 nil 3882037873
   ("" (dl-Gb) (("" (dl-assert) nil nil)) nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (HP type-decl nil HP_adt dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLBOOL const-decl "bool" bool_expr dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (dl_const formula-decl nil dynamic_logic dL))
   shostak))
 (dl_ghost_example 0
  (dl_ghost_example-2 nil 3911917965
   (""
    (then (skeep) (dl-flatten) (dl-ghost "val(x)*val(y)") (dl-diffinv)
     (dl-assert))
    nil)
   ((DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (NQBool type-decl nil NQBool_adt dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (NQB_REL type-decl nil hp_def dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_ge? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (nqb_ge adt-constructor-decl "(nqb_ge?)" hp_def dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (max_var const-decl "nat" hp_def dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_dift_val formula-decl nil differentiation dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (max_var_max formula-decl nil hp_def dL)
    (length_singleton formula-decl nil more_list_props structures)
    (dl_dift_const formula-decl nil differentiation dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (dl_discrete_ghost formula-decl nil dynamic_logic dL))
   nil)
  (dl_ghost_example-1 nil 3882037814
   ("" (dl-flatten)
    (("" (dl-ghost "val(x)*val(y)")
      (("" (dl-diffinv)
        (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_discrete_ghost formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_trueL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (diff_re_cnst formula-decl nil diff_re_props dL)
    (diff_re_prod formula-decl nil diff_re_props dL)
    (diff_re? const-decl "bool" chain_rule_re dL)
    (diff_re_val formula-decl nil diff_re_props dL)
    (derivable_M_nqbool? inductive-decl "bool" chain_rule_re dL)
    (dl_dift_const formula-decl nil differentiation dL)
    (dl_dift_val formula-decl nil differentiation dL)
    (ddl_dom_upto? const-decl "bool" differentiation dL)
    (dl_derivable_up_val formula-decl nil differentiation dL)
    (dl_true_DDL formula-decl nil differentiation dL)
    (ddt def-decl "RealExpr" differentiation dL)
    (dl_dift_mult formula-decl nil differentiation dL)
    (const_fun const-decl "[T -> real]" real_fun_ops reals)
    (scal_function formula-decl nil real_fun_ops reals)
    (max_var const-decl "nat" hp_def dL)
    (DIFT def-decl "BoolExpr" differentiation dL)
    (SUB_DIFT const-decl "BoolExpr" differentiation dL)
    (normalize_rec def-decl "{nnqbe: NormNQBool |
   FORALL (env: Environment):
     nqb_to_be(nnqbe)(env) = (pos IFF nqb_to_be(nqbe)(env))}" bool_expr
     dL)
    (dl_dI_dlTRUE formula-decl nil dynamic_logic dL)
    (nqb_rel const-decl "BoolExpr" bool_expr dL)
    (nqb_ge adt-constructor-decl "(nqb_ge?)" hp_def dL)
    (nqb_ge? adt-recognizer-decl "[NQB_REL -> boolean]" hp_def dL)
    (NQB_rel adt-constructor-decl
     "[[NQB_REL, RealExpr, RealExpr] -> (nqb_rel?)]" NQBool_adt dL)
    (nqb_rel? adt-recognizer-decl "[NQBool -> boolean]" NQBool_adt dL)
    (NQB_REL type-decl nil hp_def dL)
    (normalize const-decl
     "{nnqbe: NormNQBool | nqb_to_be(nnqbe) = nqb_to_be(nqbe)}"
     bool_expr dL)
    (nqb_to_be def-decl "BoolExpr" bool_expr dL)
    (NormNQBool type-eq-decl nil bool_expr dL)
    (nqb_normal? inductive-decl "bool" bool_expr dL)
    (NQBool type-decl nil NQBool_adt dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_grind_example 0
  (dl_grind_example-2 nil 3911917998 ("" (then (skeep) (dl-grind)) nil)
   ((dl_orL formula-decl nil dynamic_logic dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (>= const-decl "BoolExpr" bool_expr dL)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLOR const-decl "bool" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (sqrt_pos application-judgement "posreal" sqrt reals)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures))
   nil)
  (dl_grind_example-1 nil 3882037803 ("" (dl-grind) nil nil)
   ((iterate_left const-decl "T" for_iterate structures)
    (sqrt_pos application-judgement "posreal" sqrt reals)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (sqrt const-decl "{nnz: nnreal | nnz * nnz = nnx}" sqrt reals)
    (>= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL))
   shostak))
 (dl_ground_example 0
  (dl_ground_example-2 nil 3911918063
   ("" (then (skeep) (spread (dl-ground) ((dl-assert) (dl-assert))))
    nil)
   ((dl_andL formula-decl nil dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLOR const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL))
   nil)
  (dl_ground_example-1 nil 3882037789
   ("" (dl-ground)
    (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLOR const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (dl_hide_example 0
  (dl_hide_example-2 nil 3911918089
   (""
    (then (skeep) (dl-flatten) (dl-hide -2) (dl-hide + :but 3)
     (dl-hide -2) (dl-assert))
    nil)
   ((= const-decl "BoolExpr" bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (length_singleton formula-decl nil more_list_props structures))
   nil)
  (dl_hide_example-1 nil 3873839405
   ("" (dl-flatten)
    (("" (dl-hide -2)
      (("" (dl-hide + :but 3)
        (("" (dl-hide -2) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((length_singleton formula-decl nil more_list_props structures)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_hideR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_hiderest_example 0
  (dl_hiderest_example-2 nil 3911918116
   ("" (then (skeep) (dl-flatten) (dl-hiderest (-1 3)) (dl-assert))
    nil)
   ((= const-decl "BoolExpr" bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_hide_restL formula-decl nil dynamic_logic dL)
    (dl_hide_restR formula-decl nil dynamic_logic dL))
   nil)
  (dl_hiderest_example-1 nil 3873839746
   ("" (dl-flatten)
    (("" (dl-hiderest (-1 3)) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_hide_restR formula-decl nil dynamic_logic dL)
    (dl_hide_restL formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLOR const-decl "bool" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_iff_example 0
  (dl_iff_example-2 nil 3911918166
   ("" (then (skeep) (spread (dl-iffR) ((dl-assert) (dl-assert)))) nil)
   ((bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_equivR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL))
   nil)
  (dl_iff_example-1 nil 3882037750
   ("" (dl-iffR) (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil))
    nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_equivR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil))
   shostak))
 (dl_inst_example 0
  (dl_inst_example-2 nil 3911918179
   ("" (then (skeep) (dl-inst "-1") (dl-flatten) (dl-assert)) nil)
   ((bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_existsR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL))
   nil)
  (dl_inst_example-1 nil 3882037720
   ("" (dl-inst "-1")
    (("" (dl-flatten) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_impliesR formula-decl nil dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_existsR formula-decl nil dynamic_logic dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   shostak))
 (dl_impliesL_example 0
  (dl_impliesL_example-2 nil 3911918198
   ("" (then (skeep) (dl-impliesL)) nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   nil)
  (dl_impliesL_example-1 nil 3877103939
   ("" (flatten) (("" (dl-impliesL) nil nil)) nil)
   ((> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_impliesR_example 0
  (dl_impliesR_example-2 nil 3911918216
   ("" (then (skeep) (dl-impliesR)) nil)
   ((dl_impliesR formula-decl nil dynamic_logic dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   nil)
  (dl_impliesR_example-1 nil 3877432643
   ("" (flatten) (("" (dl-impliesR) nil nil)) nil)
   ((dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_iterated_example 0
  (dl_iterated_example-2 nil 3911918234
   ("" (then (skeep) (dl-flatten) (dl-iterated) (dl-assert)) nil)
   ((ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (DLOR const-decl "bool" bool_expr dL)
    (dl_iterated formula-decl nil dynamic_logic dL))
   nil)
  (dl_iterated_example-1 nil 3882037631
   ("" (dl-flatten) (("" (dl-iterated) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_iterated formula-decl nil dynamic_logic dL)
    (DLOR const-decl "bool" bool_expr dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_orR formula-decl nil dynamic_logic dL)
    (dl_assignd formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_K_example 0
  (dl_K_example-2 nil 3911918249
   (""
    (then (skeep) (dl-K) (dl-assert-pairwise_distinct_vars?)
     (dl-assert))
    nil)
   ((cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_distimpliesb formula-decl nil dynamic_logic dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_implies formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL))
   nil)
  (dl_K_example-1 nil 3882037583
   ("" (dl-K) (("" (dl-assert) nil nil)) nil)
   ((null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_sub_implies formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL) (HP type-decl nil HP_adt dL)
    (dl_distimpliesb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL))
   shostak))
 (dl_loop_example 0
  (dl_loop_example-2 nil 3911918270
   (""
    (then (skeep) (dl-assert-pairwise_distinct_vars?) (dl-flatten)
     (spread (dl-loop "val(x)>=cnst(1) and val(y) >=cnst(1)")
      ((dl-assert) (dl-assert) (then (dl-assignb) (dl-assert)))))
    nil)
   ((pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_loop formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_and formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL))
   nil)
  (dl_loop_example-1 nil 3882037490
   ("" (dl-flatten)
    (("" (dl-loop "val(x)>=cnst(1) and val(y) >=cnst(1)")
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)
       ("3" (dl-assignb) (("3" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_loop formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_sub_and formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_ge formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (STAR adt-constructor-decl "[HP -> (star?)]" HP_adt dL)
    (star? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_Mb_example 0
  (dl_Mb_example-2 nil 3911918293
   ("" (then (skeep) (dl-Mb) (dl-assert)) nil)
   ((val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesallrunsb formula-decl nil dynamic_logic dL)
    (HP type-decl nil HP_adt dL) (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures))
   nil)
  (dl_Mb_example-1 nil 3882037475
   ("" (dl-Mb) (("" (dl-assert) nil nil)) nil)
   ((iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (/= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (dl_impliesallrunsb formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (val const-decl "real" hp_def dL))
   shostak))
 (dl_monob_example 0
  (dl_monob_example-1 nil 3882037373
   (""
    (then (skeep) (dl-assert-pairwise_distinct_vars?) (dl-flatten)
     (spread (dl-monob "val(x) = cnst(0) AND val(y) = cnst(c)")
      ((dl-assert) (dl-assert))))
    nil)
   ((pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_MbR formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_and formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_andL formula-decl nil dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (Assigns type-eq-decl nil hp_def dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (^ const-decl "[T -> real]" real_fun_ops reals))
   shostak))
 (dl_move_example 0
  (dl_move_example-2 nil 3911918322
   ("" (then (skeep) (dl-flatten) (dl-move -2) (dl-move 2) (dl-assert))
    nil)
   ((DLOR const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL))
   nil)
  (dl_move_example-1 nil 3873840108
   ("" (dl-flatten)
    (("" (dl-move -2) (("" (dl-move 2) (("" (dl-assert) nil nil)) nil))
      nil))
    nil)
   ((dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (dl_moveR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_orR formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLOR const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_notL_example 0
  (dl_notL_example-2 nil 3911918337 ("" (then (skeep) (dl-notL)) nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (dl_notL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   nil)
  (dl_notL_example-1 nil 3877105333
   ("" (flatten) (("" (dl-notL) nil nil)) nil)
   ((> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_notL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_notR_example 0
  (dl_notR_example-2 nil 3911918348 ("" (then (skeep) (dl-notR)) nil)
   ((dl_notR formula-decl nil dynamic_logic dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   nil)
  (dl_notR_example-1 nil 3877432902
   ("" (flatten) (("" (dl-notR) nil nil)) nil)
   ((dl_notR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_orL_example 0
  (dl_orL_example-2 nil 3911918362 ("" (then (skeep) (dl-orL)) nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (<= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   nil)
  (dl_orL_example-1 nil 3877433988
   ("" (flatten) (("" (dl-orL) nil nil)) nil)
   ((Formulas type-eq-decl nil bool_expr dL)
    (dl_orL formula-decl nil dynamic_logic dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (<= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_orR_example 0
  (dl_orR_example-2 nil 3911918374 ("" (then (skeep) (dl-orR)) nil)
   ((dl_orR formula-decl nil dynamic_logic dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   nil)
  (dl_orR_example-1 nil 3877433188
   ("" (flatten) (("" (dl-orR) nil nil)) nil)
   ((dl_orR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (< const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   shostak))
 (dl_pp_example 0
  (dl_pp_example-2 nil 3911918388
   ("" (then (skeep) (dl-pp) (dl-assert)) nil)
   ((Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL))
   nil)
  (dl_pp_example-1 nil 3873840274
   ("" (dl-pp) (("" (dl-assert) nil nil)) nil)
   ((\|- const-decl "bool" dynamic_logic dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil))
   shostak))
 (dl_skolem_example 0
  (dl_skolem_example-2 nil 3911918401
   ("" (then (skeep) (dl-skolem) (dl-assert)) nil)
   ((bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (dLVar type-decl nil hp_def dL) (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL))
   nil)
  (dl_skolem_example-1 nil 3877439517
   ("" (dl-skolem) (("" (dl-assert) nil nil)) nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil))
   shostak))
 (dl_solve_example1 0
  (dl_solve_example1-2 "" 3911710141
   ("" (then (skeep) (dl-flatten) (dl-solve) (dl-assert)) nil)
   ((DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (val const-decl "real" hp_def dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (length_singleton formula-decl nil more_list_props structures)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_le formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_sub_bool_restricted formula-decl nil substitution dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (env_nat_shift const-decl "real" dl_solution dL)
    (env_c const-decl "real" dl_solution dL)
    (is_cnst? const-decl "bool" dl_solution dL)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (in_map const-decl "bool" hp_def dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def dL)
    (dlvar adt-constructor-decl "[nat -> (dlvar?)]" hp_def dL)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (Assigns type-eq-decl nil hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (solution_domain_ax_cnst_imp_zip formula-decl nil dl_solution dL))
   shostak)
  (dl_solve_example1-1 nil 3882037333
   ("" (dl-flatten) (("" (dl-solve) (("" (dl-assert) nil nil)) nil))
    nil)
   ((solution_domain_ax_cnst_imp_zip formula-decl nil dl_solution dL)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (\|- const-decl "bool" dynamic_logic dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (get_val_cnst_id_ex const-decl "{vc: [below(length(l)), real] |
   vc`1 /= i AND
    nth(l, i)`2 = cnst(vc`2) + val(nth(l, vc`1)`1) AND
     (FORALL (c: real, m: below(length(l))):
        nth(l, i)`2 = cnst(c) + val(nth(l, m)`1) IMPLIES
         (m = vc`1 AND vc`2 = c))}" dl_solution dL)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (is_cnst? const-decl "bool" dl_solution dL)
    (in_map_ex def-decl "bool" dl_solution dL)
    (env_c const-decl "real" dl_solution dL)
    (env_nat_shift const-decl "real" dl_solution dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_sub_bool_restricted formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_le formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (length_singleton formula-decl nil more_list_props structures)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_hideL formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (val const-decl "real" hp_def dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_solve_example2 2
  (dl_solve_example2-4 "" 3911989205
   ("" (skeep)
    ((""
      (deftactic simplify_init_zip_sol (&optional (tac-fnum -1))
       (for@ nil
        (then (expand "init_zip_sol" tac-fnum)
         (for@ nil (expand "length" tac-fnum)))))
      ((""
        (deftactic expand_in_map_ex (&optional (tac-fnum -1))
         (for@ nil (expand "in_map_ex" tac-fnum)))
        (("" (deftactic lift_them_all nil (for@ nil (lift-if)))
          ((""
            (deftactic simplify_evaluable_ites nil
             (let ((allruns_assign_expr '"allruns_assign_expr_864")
                   (*allruns_assign_expr* '|allruns_assign_expr:18751|)
                   (solution_lemma '|solution_lemma:18750|)
                   (fnum 'nil)
                   (skolem-constant '"t")
                   (quiet? 't)
                   (dlseq
                    '(1 typechecked "(: :) |-
 (: ALLRUNS(DIFF((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :), val(z) = val(x)), val(z) = val(x)) :)"
                      "bool"))
                   (skolem-constant '"t")
                   (passed-checks '"t")
                   (turn-rw-msg-on? 'nil)
                   (lemma-to-use
                    '"solution_domain_ax_cnst_imp_zip_no_hyp")
                   (fnum '1)
                   (ite (extra-get-expr '(~ -1 "%{if_}"))))
               (when ite
                 (let ((guard (args1 ite)))
                   (then (eval-expr guard :quiet? t)
                    (replace -1 :hide? t))))))
            ((""
              (deftactic simplify_Y_sol_ex (&optional (tac-fnum -1))
               (then (expand "Y_sol_ex" tac-fnum 1)
                (expand "get_val_cnst_id_ex" tac-fnum)
                (expand "is_val_not_in_map?" tac-fnum)
                (expand "is_cnst?" tac-fnum)
                (expand_in_map_ex tac-fnum) (simplify_nth)
                (beta tac-fnum)
                (for@ nil
                 (rewrites "env_nat_shift_cnst" :fnums tac-fnum))
                (rewrites ("env_nat_shift_0_val" "env_c_val"
                           "env_nat_shift_1_val")
                          :fnums tac-fnum)
                (simplify_evaluable_ites)
                (let ((allruns_assign_expr '"allruns_assign_expr_864")
                      (*allruns_assign_expr*
                       '|allruns_assign_expr:18751|)
                      (solution_lemma '|solution_lemma:18750|)
                      (fnum 'nil)
                      (skolem-constant '"t")
                      (quiet? 't)
                      (dlseq
                       '(1 typechecked "(: :) |-
 (: ALLRUNS(DIFF((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :), val(z) = val(x)), val(z) = val(x)) :)"
                         "bool"))
                      (skolem-constant '"t")
                      (passed-checks '"t")
                      (turn-rw-msg-on? 'nil)
                      (lemma-to-use
                       '"solution_domain_ax_cnst_imp_zip_no_hyp")
                      (fnum '1)
                      (actual-fnum (lisp (extra-get-fnum tac-fnum))))
                  (match actual-fnum "get_index(%a{list})(%)" step
                         (then (eval-expr $aj :quiet? t)
                          (replace -1 :hide? t) (simplify_nth))))
                (beta tac-fnum)))
              (("" (lemma "solution_domain_ax_cnst_imp_zip_no_hyp")
                (("" (inst?)
                  (("1"
                    (with-labels (skoletin)
                     ((|solution_lemma:18750| Z_def nil)))
                    (("1" (beta |solution_lemma:18750|)
                      (("1" (split |solution_lemma:18750|)
                        (("1" (propax) nil nil)
                         ("2"
                          (hide-all-but
                           (|solution_lemma:18750| Z_def '-))
                          (("2" (expand "zs" Z_def)
                            (("2" (simplify_init_zip_sol Z_def)
                              (("2"
                                (for@ nil (simplify_nth))
                                (("2"
                                  (beta Z_def)
                                  (("2"
                                    (simplify_Y_sol_ex Z_def)
                                    (("2"
                                      (simplify_Y_sol_ex Z_def)
                                      (("2"
                                        (name
                                         "bla"
                                         "Y_sol_ex((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(2)")
                                        (("1"
                                          (label "bla-label" -1)
                                          (("1"
                                            (replace "bla-label" Z_def)
                                            (("1"
                                              (expand
                                               "Y_sol_ex"
                                               "bla-label")
                                              (("1"
                                                (name-label*
                                                 ("is_const?_951"
                                                  (typechecked
                                                   "is_cnst?((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(2)"
                                                   "bool"))
                                                 :hide?
                                                 t
                                                 :label
                                                 (:pairing
                                                  |is_const?:20260|)
                                                 :tcc-label
                                                 (:pairing
                                                  |is_const?-tccs:20261|)
                                                 :tcc-step
                                                 (:pairing
                                                  (extra-tcc-step)))
                                                (("1"
                                                  (reveal
                                                   |is_const?:20260|)
                                                  (("1"
                                                    (expand
                                                     "is_cnst?"
                                                     |is_const?:20260|)
                                                    (("1"
                                                      (simplify_nth)
                                                      (("1"
                                                        (beta
                                                         |is_const?:20260|)
                                                        (("1"
                                                          (for@
                                                           nil
                                                           (then
                                                            (match
                                                             -1
                                                             "(%op(%a,%b))(%c) = (%op(%a,%b))(%d)"
                                                             step
                                                             (expand
                                                              "%op"
                                                              -1))
                                                            (match
                                                             -1
                                                             "cnst(%%)(%%)"
                                                             step
                                                             (expand
                                                              "cnst"
                                                              -1))
                                                            (match
                                                             -1
                                                             "val(%%)(%%)"
                                                             step
                                                             (then
                                                              (expand
                                                               "val"
                                                               -1)
                                                              (expand
                                                               "env_nat_shift"
                                                               -1)))))
                                                          (("1"
                                                            (replace
                                                             |is_const?:20260|
                                                             "bla-label"
                                                             :hide?
                                                             t)
                                                            (("1"
                                                              (delete
                                                               (|is_const?-tccs:20261|))
                                                              (("1"
                                                                (touch
                                                                 (delabel
                                                                  (|is_const?-tccs:20261|
                                                                   |is_const?:20260|)))
                                                                (("1"
                                                                  (name-label*
                                                                   ("is_val_not_in_map?_953"
                                                                    (typechecked
                                                                     "is_val_not_in_map?((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(2)"
                                                                     "bool"))
                                                                   :hide?
                                                                   t
                                                                   :label
                                                                   (:pairing
                                                                    |is_val_not_in_map?:20288|)
                                                                   :tcc-label
                                                                   (:pairing
                                                                    |is_val_not_in_map?-tccs:20289|)
                                                                   :tcc-step
                                                                   (:pairing
                                                                    (extra-tcc-step)))
                                                                  (("1"
                                                                    (reveal
                                                                     |is_val_not_in_map?:20288|)
                                                                    (("1"
                                                                      (expand
                                                                       "is_val_not_in_map?"
                                                                       -1)
                                                                      (("1"
                                                                        (simplify_nth)
                                                                        (("1"
                                                                          (beta
                                                                           -1)
                                                                          (("1"
                                                                            (expand
                                                                             "in_map_ex"
                                                                             -1)
                                                                            (("1"
                                                                              (expand
                                                                               "in_map_ex"
                                                                               -1)
                                                                              (("1"
                                                                                (expand
                                                                                 "in_map_ex"
                                                                                 -1)
                                                                                (("1"
                                                                                  (expand
                                                                                   "in_map_ex"
                                                                                   -1)
                                                                                  (("1"
                                                                                    (expand
                                                                                     "+"
                                                                                     -1)
                                                                                    (("1"
                                                                                      (expand
                                                                                       "cnst"
                                                                                       -1)
                                                                                      (("1"
                                                                                        (expand
                                                                                         "val"
                                                                                         -1)
                                                                                        (("1"
                                                                                          (expand
                                                                                           "env_nat_shift"
                                                                                           -1)
                                                                                          (("1"
                                                                                            (expand
                                                                                             "env_c"
                                                                                             -1)
                                                                                            (("1"
                                                                                              (expand
                                                                                               "pairwise_distinct_vars?")
                                                                                              (("1"
                                                                                                (expand
                                                                                                 "distinct_var?")
                                                                                                (("1"
                                                                                                  (expand
                                                                                                   "distinct_var?")
                                                                                                  (("1"
                                                                                                    (expand
                                                                                                     "distinct_var?")
                                                                                                    (("1"
                                                                                                      (postpone)
                                                                                                      nil
                                                                                                      nil))
                                                                                                    nil))
                                                                                                  nil))
                                                                                                nil))
                                                                                              nil))
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2" (postpone) nil nil)
                                         ("3" (postpone) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (dl_solve_example2-3 "" 3911971771
   ("" (skeep)
    ((""
      (deftactic simplify_init_zip_sol (&optional (tac-fnum -1))
       (for@ nil
        (then (expand "init_zip_sol" tac-fnum)
         (for@ nil (expand "length" tac-fnum)))))
      ((""
        (deftactic expand_in_map_ex (&optional (tac-fnum -1))
         (for@ nil (expand "in_map_ex" tac-fnum)))
        (("" (deftactic lift_them_all nil (for@ nil (lift-if)))
          ((""
            (deftactic simplify_evaluable_ites nil
             (let ((allruns_assign_expr '"allruns_assign_expr_864")
                   (*allruns_assign_expr* '|allruns_assign_expr:18751|)
                   (solution_lemma '|solution_lemma:18750|)
                   (fnum 'nil)
                   (skolem-constant '"t")
                   (quiet? 't)
                   (dlseq
                    '(1 typechecked "(: :) |-
 (: ALLRUNS(DIFF((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :), val(z) = val(x)), val(z) = val(x)) :)"
                      "bool"))
                   (skolem-constant '"t")
                   (passed-checks '"t")
                   (turn-rw-msg-on? 'nil)
                   (lemma-to-use
                    '"solution_domain_ax_cnst_imp_zip_no_hyp")
                   (fnum '1)
                   (ite (extra-get-expr '(~ -1 "%{if_}"))))
               (when ite
                 (let ((guard (args1 ite)))
                   (then (eval-expr guard :quiet? t)
                    (replace -1 :hide? t))))))
            ((""
              (deftactic simplify_Y_sol_ex (&optional (tac-fnum -1))
               (then (expand "Y_sol_ex" tac-fnum 1)
                (expand "get_val_cnst_id_ex" tac-fnum)
                (expand "is_val_not_in_map?" tac-fnum)
                (expand "is_cnst?" tac-fnum)
                (expand_in_map_ex tac-fnum) (simplify_nth)
                (beta tac-fnum)
                (for@ nil
                 (rewrites "env_nat_shift_cnst" :fnums tac-fnum))
                (rewrites ("env_nat_shift_0_val" "env_c_val"
                           "env_nat_shift_1_val")
                          :fnums tac-fnum)
                (simplify_evaluable_ites)
                (let ((allruns_assign_expr '"allruns_assign_expr_864")
                      (*allruns_assign_expr*
                       '|allruns_assign_expr:18751|)
                      (solution_lemma '|solution_lemma:18750|)
                      (fnum 'nil)
                      (skolem-constant '"t")
                      (quiet? 't)
                      (dlseq
                       '(1 typechecked "(: :) |-
 (: ALLRUNS(DIFF((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :), val(z) = val(x)), val(z) = val(x)) :)"
                         "bool"))
                      (skolem-constant '"t")
                      (passed-checks '"t")
                      (turn-rw-msg-on? 'nil)
                      (lemma-to-use
                       '"solution_domain_ax_cnst_imp_zip_no_hyp")
                      (fnum '1)
                      (actual-fnum (lisp (extra-get-fnum tac-fnum))))
                  (match actual-fnum "get_index(%a{list})(%)" step
                         (then (eval-expr $aj :quiet? t)
                          (replace -1 :hide? t) (simplify_nth))))
                (beta tac-fnum)))
              (("" (lemma "solution_domain_ax_cnst_imp_zip_no_hyp")
                (("" (inst?)
                  (("1"
                    (with-labels (skoletin)
                     ((|solution_lemma:18750| Z_def nil)))
                    (("1" (beta |solution_lemma:18750|)
                      (("1" (split |solution_lemma:18750|)
                        (("1" (propax) nil nil)
                         ("2"
                          (hide-all-but
                           (|solution_lemma:18750| Z_def '-))
                          (("2" (expand "zs" Z_def)
                            (("2" (simplify_init_zip_sol Z_def)
                              (("2"
                                (for@ nil (simplify_nth))
                                (("2"
                                  (simplify_Y_sol_ex Z_def)
                                  (("2"
                                    (with-tccs
                                     (name
                                      "bla"
                                      "Y_sol_ex((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(1)"))
                                    (("2"
                                      (label "bla-label" -1)
                                      (("2"
                                        (replace "bla-label" Z_def)
                                        (("2"
                                          (expand
                                           "Y_sol_ex"
                                           "bla-label")
                                          (("2"
                                            (with-tccs
                                             (name
                                              "bli"
                                              "is_cnst?((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(1)"))
                                            (("2"
                                              (replace -1 "bla-label")
                                              (("2"
                                                (label "bli-label" -1)
                                                (("2"
                                                  (dl-calculate-is_cnst?
                                                   "bli-label")
                                                  (("2"
                                                    (replace
                                                     "bli-label"
                                                     "bla-label"
                                                     :hide?
                                                     t)
                                                    (("2"
                                                      (with-tccs
                                                       (name
                                                        "blo"
                                                        "is_val_not_in_map?((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(1)"))
                                                      (("2"
                                                        (replace -1 -2)
                                                        (("2"
                                                          (label
                                                           "blo-label"
                                                           -1)
                                                          (("2"
                                                            (dl-calculate-is_val_not_in_map?
                                                             "blo-label")
                                                            (("2"
                                                              (replace
                                                               "blo-label"
                                                               "bla-label"
                                                               :hide?
                                                               t)
                                                              (("2"
                                                                (with-tccs
                                                                 (name
                                                                  "ble"
                                                                  "get_val_cnst_id_ex((: (x, cnst(3)), (y, val(x)), (z, val(q) + cnst(5)) :))(1)"))
                                                                (("2"
                                                                  (replace
                                                                   -1
                                                                   -2)
                                                                  (("2"
                                                                    (label
                                                                     "ble-label"
                                                                     -1)
                                                                    (("2"
                                                                      (dl-calculate-get_val_cnst_id_ex
                                                                       "ble-label")
                                                                      (("2"
                                                                        (replace
                                                                         "ble-label"
                                                                         :dir
                                                                         rl
                                                                         :hide?
                                                                         t)
                                                                        (("2"
                                                                          (beta
                                                                           "bla-label")
                                                                          (("2"
                                                                            (simplify_nth)
                                                                            (("2"
                                                                              (use
                                                                               "env_c_val")
                                                                              (("2"
                                                                                (replace
                                                                                 -1
                                                                                 "bla-label"
                                                                                 :hide?
                                                                                 t)
                                                                                (("2"
                                                                                  (replace
                                                                                   "bla-label"
                                                                                   :dir
                                                                                   rl
                                                                                   :hide?
                                                                                   t)
                                                                                  (("2"
                                                                                    (beta
                                                                                     Z_def)
                                                                                    (("2"
                                                                                      (postpone)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (dl_solve_example2-2 nil 3911710502
   (""
    (then (skeep) (dl-solve) (dl-inst "t") (dl-flatten) (dl-ground)
     (dl-assert))
    nil)
   ((solution_domain_ax_cnst_imp_zip_no_hyp formula-decl nil
     dl_solution dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (MapExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (in_map const-decl "bool" hp_def dL)
    (cnst_val_com formula-decl nil dl_solution dL)
    (cnst_val_0 formula-decl nil dl_solution dL)
    (get_index def-decl
     "{n: below(length(l)) | dlvar_index(nth(l, n)`1) = j}" dl_solution
     dL)
    (quad_cnst? const-decl "bool" dl_solution dL)
    (bijective? const-decl "bool" functions nil)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (HP type-decl nil HP_adt dL) (ODEs type-eq-decl nil hp_def dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (dlvar adt-constructor-decl "[nat -> (dlvar?)]" hp_def dL)
    (dlvar? adt-recognizer-decl "[dLVar -> boolean]" hp_def dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (is_cnst? const-decl "bool" dl_solution dL)
    (env_c const-decl "real" dl_solution dL)
    (env_nat_shift const-decl "real" dl_solution dL)
    (in_map_ex def-decl "bool" dl_solution dL)
    (get_val_cnst_id_ex const-decl "{vc: [below(length(l)), real] |
   vc`1 /= i AND
    nth(l, i)`2 = cnst(vc`2) + val(nth(l, vc`1)`1) AND
     (FORALL (c: real, m: below(length(l))):
        nth(l, i)`2 = cnst(c) + val(nth(l, m)`1) IMPLIES
         (m = vc`1 AND vc`2 = c))}" dl_solution dL)
    (env_c_val formula-decl nil dl_solution dL)
    (div_safe_re const-decl "real" hp_def dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (dl_forallL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL))
   nil)
  (dl_solve_example2-1 nil 3882037272
   ("" (dl-solve)
    (("" (dl-inst "t")
      (("" (dl-flatten)
        (("" (dl-ground) (("" (dl-assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((dl_forallL formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_andR formula-decl nil dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (dl_assignb_restricted formula-decl nil dynamic_logic dL)
    (dl_assignb formula-decl nil dynamic_logic dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (dl_andL formula-decl nil dynamic_logic dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_forallR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (DLAND const-decl "bool" bool_expr dL)
    (>= const-decl "BoolExpr" bool_expr dL)
    (env_c_val formula-decl nil dl_solution dL)
    (env_nat_shift const-decl "real" dl_solution dL)
    (env_c const-decl "real" dl_solution dL)
    (in_map_ex def-decl "bool" dl_solution dL)
    (is_cnst? const-decl "bool" dl_solution dL)
    (is_val_not_in_map? const-decl "bool" dl_solution dL)
    (get_val_cnst_id_ex const-decl "{vc: [below(length(l)), real] |
   vc`1 /= i AND
    nth(l, i)`2 = cnst(vc`2) + val(nth(l, vc`1)`1) AND
     (FORALL (c: real, m: below(length(l))):
        nth(l, i)`2 = cnst(c) + val(nth(l, m)`1) IMPLIES
         (m = vc`1 AND vc`2 = c))}" dl_solution dL)
    (init_zip_sol def-decl "{a: MapExprInj |
   length(a) = length(ode) AND
    FORALL (i: below(length(a))): nth(a, i) = (nth(ode, i)`1, y(i)(t))}"
     dl_solution dL)
    (Y_sol_ex const-decl "[Environment -> real]" dl_solution dL)
    (zs const-decl "MapExprInj" dl_solution dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ASSIGN adt-constructor-decl "[Assigns -> (assign?)]" HP_adt dL)
    (Assigns type-eq-decl nil hp_def dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (UPTO const-decl "BoolExpr" bool_expr dL)
    (QHP type-eq-decl nil bool_expr dL)
    (DLFORALL const-decl "bool" bool_expr dL)
    (QBoolExpr type-eq-decl nil hp_def dL)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (assign? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (HP type-decl nil HP_adt dL)
    (cnst_val_com formula-decl nil dl_solution dL)
    (get_index def-decl
     "{n: below(length(l)) | dlvar_index(nth(l, n)`1) = j}" dl_solution
     dL)
    (in_map const-decl "bool" hp_def dL)
    (quad_cnst? const-decl "bool" dl_solution dL)
    (cnst_val_0 formula-decl nil dl_solution dL)
    (bijective? const-decl "bool" functions nil)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cnst_lins? const-decl "bool" dl_solution dL)
    (MapExprInj type-eq-decl nil hp_def dL)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (solution_domain_ax_cnst_imp_zip_no_hyp formula-decl nil
     dl_solution dL))
   shostak))
 (dl_subs_example 0
  (dl_subs_example-2 nil 3911918573
   (""
    (then (skeep) (dl-assert-pairwise_distinct_vars?) (dl-flatten)
     (dl-subs) (dl-assert))
    nil)
   ((pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_subre_plus formula-decl nil substitution dL)
    (dl_subre_exp formula-decl nil substitution dL)
    (dl_subre_val formula-decl nil substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (SUB const-decl "bool" substitution dL)
    (Substitution type-eq-decl nil substitution dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   nil)
  (dl_subs_example-1 nil 3873840950
   ("" (dl-flatten) (("" (dl-subs) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_subre_val formula-decl nil substitution dL)
    (dl_subre_exp formula-decl nil substitution dL)
    (dl_subre_plus formula-decl nil substitution dL)
    (dl_subre_const formula-decl nil substitution dL)
    (dl_sub_eq formula-decl nil substitution dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (SUB_MapVar def-decl
     "{re: RealExpr | FORALL (env: Environment): re(env) = SUB_Re(l)(val(v))(env)}"
     substitution dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Substitution type-eq-decl nil substitution dL)
    (SUB const-decl "bool" substitution dL)
    (^ const-decl "[T -> real]" real_fun_ops reals))
   shostak))
 (dl_testb_example 0
  (dl_testb_example-2 nil 3911918600
   ("" (then (skeep) (dl-flatten) (dl-testb) (dl-assert)) nil)
   ((DLIMPLIES const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head_rec def-decl "Formulas" dynamic_logic dL))
   nil)
  (dl_testb_example-1 nil 3877436527
   ("" (dl-flatten) (("" (dl-testb) (("" (dl-assert) nil nil)) nil))
    nil)
   ((move_to_head_rec def-decl "Formulas" dynamic_logic dL)
    (is_dlfnum const-decl "bool" dynamic_logic dL)
    (move_to_head const-decl "Formulas" dynamic_logic dL)
    (dl_moveL formula-decl nil dynamic_logic dL)
    (dl_testb formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL)
    (dl_impliesL formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLIMPLIES const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_testd_example 0
  (dl_testd_example-2 nil 3911918621
   ("" (then (skeep) (dl-flatten) (dl-assert)) nil)
   ((DLAND const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_testd formula-decl nil dynamic_logic dL)
    (dl_axiom formula-decl nil dynamic_logic dL))
   nil)
  (dl_testd_example-1 nil 3877437670
   ("" (dl-flatten) (("" (dl-testd) (("" (dl-assert) nil nil)) nil))
    nil)
   ((dl_axiom formula-decl nil dynamic_logic dL)
    (dl_testd formula-decl nil dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (DLAND const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (> const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (TEST adt-constructor-decl "[BoolExpr -> (test?)]" HP_adt dL)
    (test? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (SOMERUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_trueR_example 0
  (dl_trueR_example-2 nil 3911918646 ("" (then (skeep) (dl-trueR)) nil)
   ((dl_trueR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (bijective? const-decl "bool" functions nil)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL))
   nil)
  (dl_trueR_example-1 nil 3877101367 ("" (then (dl-trueR)) nil nil)
   ((Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (RealExpr type-eq-decl nil hp_def dL)
    (> const-decl "BoolExpr" bool_expr dL)
    (val const-decl "real" hp_def dL)
    (cnst const-decl "real" hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (Formulas type-eq-decl nil bool_expr dL)
    (<= const-decl "BoolExpr" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (dl_trueR formula-decl nil dynamic_logic dL))
   shostak))
 (dl_Vb_example 0
  (dl_Vb_example-2 nil 3911918657
   (""
    (then (skeep) (dl-assert-pairwise_distinct_vars?) (dl-flatten)
     (dl-Vb) (dl-assert))
    nil)
   ((pairwise_distinct_vars? def-decl "{b: bool |
   b =
    FORALL (i, j: below(length(l))):
      i /= j IMPLIES NOT dlvar_index(nth(l, i)) = dlvar_index(nth(l, j))}"
     hp_def dL)
    (distinct_var? def-decl "{b: bool |
   b =
    FORALL (i: below(length(l))):
      NOT dlvar_index(nth(l, i)) = dlvar_index(v)}" hp_def dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (dl_V formula-decl nil dynamic_logic dL)
    (BV def-decl "list[nat]" bound_variables_def dL)
    (fresh_be_eq formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (fresh_re_pow formula-decl nil fresh_props dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (dlvar_index adt-accessor-decl "[dLVar -> nat]" hp_def dL)
    (length_singleton formula-decl nil more_list_props structures)
    (bv_me def-decl "list[nat]" bound_variables_def dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dLVar type-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (cnst const-decl "real" hp_def dL) (HP type-decl nil HP_adt dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (ODEs type-eq-decl nil hp_def dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (DLBOOL const-decl "bool" bool_expr dL)
    (^ const-decl "[T -> real]" real_fun_ops reals))
   nil)
  (dl_Vb_example-1 nil 3882037166
   ("" (dl-flatten) (("" (dl-Vb) (("" (dl-assert) nil nil)) nil)) nil)
   ((dl_V formula-decl nil dynamic_logic dL)
    (null_MapExprInj name-judgement "MapExprInj" hp_def dL)
    (BV def-decl "list[nat]" bound_variables_def dL)
    (fresh_be_eq formula-decl nil fresh_props dL)
    (fresh_re_pow formula-decl nil fresh_props dL)
    (fresh_re_val formula-decl nil fresh_props dL)
    (fresh_re_cnst formula-decl nil fresh_props dL)
    (iterate_left const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (for const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (val const-decl "real" hp_def dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (mapexpr_inj const-decl "bool" hp_def dL)
    (list type-decl nil list_adt nil)
    (MapExpr type-eq-decl nil hp_def dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (bijective? const-decl "bool" functions nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (^ const-decl "[T -> real]" real_fun_ops reals)
    (DLBOOL const-decl "bool" bool_expr dL)
    (DIFF adt-constructor-decl "[[ODEs, BoolExpr] -> (diff?)]" HP_adt
     dL)
    (diff? adt-recognizer-decl "[HP -> boolean]" HP_adt dL)
    (ODEs type-eq-decl nil hp_def dL)
    (ALLRUNS const-decl "bool" bool_expr dL)
    (HP type-decl nil HP_adt dL) (cnst const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak))
 (dl_weak_example 0
  (dl_weak_example-2 nil 3911918686
   (""
    (then (skeep) (dl-flatten)
     (spread (dl-weak "val(y)=cnst(25)") ((dl-assert) (dl-assert))))
    nil)
   ((cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL) (dLVar type-decl nil hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (Environment type-eq-decl nil hp_def dL)
    (BoolExpr type-eq-decl nil hp_def dL)
    (list type-decl nil list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (bijective? const-decl "bool" functions nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (\|- const-decl "bool" dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (dl_weakR formula-decl nil dynamic_logic dL))
   nil)
  (dl_weak_example-1 nil 3882037184
   ("" (dl-flatten)
    (("" (dl-weak "val(y)=cnst(25)")
      (("1" (dl-assert) nil nil) ("2" (dl-assert) nil nil)) nil))
    nil)
   ((dl_weakR formula-decl nil dynamic_logic dL)
    (for const-decl "T" for_iterate structures)
    (for_it def-decl
     "{t: T | t = for_def(i, upto, a, ext2int(upfrom, upto, f))}"
     for_iterate structures)
    (iterate_left const-decl "T" for_iterate structures)
    (\|- const-decl "bool" dynamic_logic dL)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (dl_andL formula-decl nil dynamic_logic dL)
    (bijective? const-decl "bool" functions nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (list type-decl nil list_adt nil)
    (BoolExpr type-eq-decl nil hp_def dL)
    (Environment type-eq-decl nil hp_def dL)
    (dl_impliesR formula-decl nil dynamic_logic dL)
    (cnst const-decl "real" hp_def dL)
    (val const-decl "real" hp_def dL)
    (= const-decl "BoolExpr" bool_expr dL)
    (RealExpr type-eq-decl nil hp_def dL)
    (DLAND const-decl "bool" bool_expr dL)
    (Formulas type-eq-decl nil bool_expr dL))
   shostak)))
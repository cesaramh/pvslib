(norms_equiv
 (equiv?_TCC1 0
  (equiv?_TCC1-1 nil 3740224822 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/"))
   nil (equiv? subtype "norms_equiv.x" "(list_adt[real].cons?)")))
 (equiv_m?_TCC1 0
  (equiv_m?_TCC1-1 nil 3740409829
   ("" (skeep) (("" (typepred "x") (("" (assert) nil nil)) nil)) nil)
   ((VectorN type-eq-decl nil matrices "matrices/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   nil (equiv_m? subtype "norms_equiv.x" "(list_adt[real].cons?)")))
 (equiv_trans 0
  (equiv_trans-1 nil 3740224903
   ("" (skeep)
    (("" (typepred "n1")
      (("" (typepred "n2")
        (("" (split)
          (("1" (flatten)
            (("1" (expand "equiv?")
              (("1" (skeep)
                (("1" (inst 1 "1/c2" "1/c1")
                  (("1" (skeep)
                    (("1" (inst -1 "x")
                      (("1" (flatten)
                        (("1" (split)
                          (("1" (mult-by -2 "1/c2")
                            (("1" (assert) nil nil)) nil)
                           ("2" (mult-by -1 "1/c1")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "equiv?")
              (("2" (skeep)
                (("2" (inst 1 "1/c2" "1/c1")
                  (("2" (skeep)
                    (("2" (inst -1 "x")
                      (("2" (flatten)
                        (("2" (split)
                          (("1" (mult-by -2 "1/c2")
                            (("1" (assert) nil nil)) nil)
                           ("2" (mult-by -1 "1/c1")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((n formal-const-decl "posnat" norms_equiv nil)
    (norm? const-decl "bool" norms nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (equiv? const-decl "bool" norms_equiv nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   shostak))
 (equiv_1norm_imp_equiv 0
  (equiv_1norm_imp_equiv-1 nil 3740225375
   ("" (flatten)
    (("" (skeep)
      (("" (inst-cp -1 "n1")
        (("" (inst -1 "n2")
          (("" (expand "equiv?")
            (("" (skeep)
              (("" (skeep)
                (("" (inst 1 "c1!1/c2" "c2!1/c1")
                  (("" (skeep)
                    (("" (inst?)
                      (("" (inst?)
                        (("" (flatten)
                          (("" (split)
                            (("1" (assert)
                              (("1"
                                (mult-by -2 "1/c2")
                                (("1"
                                  (assert)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (mult-by -3 "1/c2")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (mult-by -1 "1/c1")
                              (("2"
                                (assert)
                                (("2"
                                  (mult-by -4 "1/c1")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (equiv? const-decl "bool" norms_equiv nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (norm? const-decl "bool" norms nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (norm1_div_TCC1 0
  (norm1_div_TCC1-1 nil 3740227451 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (VectorN type-eq-decl nil matrices "matrices/"))
   nil (norm1_div subtype "norms_equiv.xx" "(list_adt[real].cons?)")))
 (norm1_div_TCC2 0
  (norm1_div_TCC2-1 nil 3740227451 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (/= const-decl "boolean" notequal nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil))
   nil (norm1_div subtype "norms_equiv.x" "(list_adt[real].cons?)")))
 (norm1_div_TCC3 0
  (norm1_div_TCC3-1 nil 3740228177 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (/= const-decl "boolean" notequal nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil))
   nil
   (norm1_div subtype "norms.norm_1(norms_equiv.n)(norms_equiv.x)"
    "nznum")))
 (norm1_div_TCC4 0
  (norm1_div_TCC4-1 nil 3740228177 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (/= const-decl "boolean" notequal nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil)
    (* const-decl "VectorN(length(v2))" matrices "matrices/"))
   nil
   (norm1_div subtype
    "matrices.*((number_fields./(1, norms.norm_1(norms_equiv.n)(norms_equiv.x))), norms_equiv.x)"
    "(list_adt[real].cons?)")))
 (norm1_div 0
  (norm1_div-1 nil 3740227520
   ("" (skeep)
    (("" (typepred "norm_1(n)")
      (("" (expand "norm?")
        (("" (flatten)
          (("" (assert)
            (("" (inst -2 "x" "(1 / norm_1(n)(x))")
              (("" (assert)
                (("" (hide -1 -3 -4)
                  (("" (replace -1 1)
                    (("" (typepred "norm_1(n)")
                      (("" (expand "norm?")
                        (("" (flatten)
                          (("" (hide -2 -3 -4)
                            (("" (inst -1 "x")
                              ((""
                                (case "(1 / norm_1(n)(x))<0")
                                (("1"
                                  (mult-by -1 "norm_1(n)(x)")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (expand "abs" 2 1)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((norm_1 const-decl "(norm?(m))" norms nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (norm? const-decl "bool" norms nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (/= const-decl "boolean" notequal nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (div_cancel2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (< const-decl "bool" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nonzero_abs_is_pos application-judgement "{y: posreal | y >= x}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   shostak))
 (equiv_unit_imp_equiv_TCC1 0
  (equiv_unit_imp_equiv_TCC1-1 nil 3740225869
   ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (norm_1 const-decl "(norm?(m))" norms nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil)
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/"))
   nil
   (equiv_unit_imp_equiv subtype "norms_equiv.x"
    "(list_adt[real].cons?)")))
 (equiv_unit_imp_equiv 0
  (equiv_unit_imp_equiv-1 nil 3740225870
   ("" (skeep)
    (("" (skeep)
      (("" (expand "equiv?")
        (("" (inst 1 "c1" "c2")
          (("" (skeep)
            (("" (case "norm_1(n)(x)=0")
              (("1" (typepred "norm_1(n)")
                (("1" (expand "norm?" -1)
                  (("1" (flatten)
                    (("1" (hide -1 -2 -4)
                      (("1" (inst -1 "x")
                        (("1" (assert)
                          (("1" (typepred "norm")
                            (("1" (expand "norm?")
                              (("1"
                                (flatten)
                                (("1"
                                  (inst -3 "x")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case "1/ norm_1(n)(x)<0")
                (("1" (typepred "norm_1(n)")
                  (("1" (expand "norm?")
                    (("1" (flatten)
                      (("1" (hide -2 -3 -4)
                        (("1" (inst -1 "x")
                          (("1" (mult-by -2 "norm_1(n)(x)")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (split)
                    (("1" (div-by 1 "norm_1(n)(x)")
                      (("1" (assert)
                        (("1" (typepred "norm")
                          (("1" (expand "norm?")
                            (("1" (flatten)
                              (("1"
                                (hide -1 -3 -4)
                                (("1"
                                  (inst -1 "x" "1 / norm_1(n)(x)")
                                  (("1"
                                    (expand "abs" -1)
                                    (("1"
                                      (replace -1 1 rl)
                                      (("1"
                                        (inst
                                         -2
                                         "1 / norm_1(n)(x) * x")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (typepred
                                                 "norm_1(n)(1 / norm_1(n)(x) * x)")
                                                (("1"
                                                  (typepred
                                                   "1 / norm_1(n)(x) * x")
                                                  (("1"
                                                    (hide -1)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (lemma
                                                         "norm1_div")
                                                        (("1"
                                                          (inst -1 "x")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (lemma "norm1_div")
                                            (("2"
                                              (inst -1 "x")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (div-by 1 "norm_1(n)(x)")
                      (("2" (assert)
                        (("2" (typepred "norm")
                          (("2" (expand "norm?")
                            (("2" (flatten)
                              (("2"
                                (hide -3 -4)
                                (("2"
                                  (inst -2 "x" " 1 / norm_1(n)(x)")
                                  (("2"
                                    (expand "abs" -2)
                                    (("2"
                                      (replace -2 1 rl)
                                      (("2"
                                        (inst
                                         -3
                                         "1 / norm_1(n)(x) * x")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (lemma "norm1_div")
                                              (("1"
                                                (inst -1 "x")
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (split)
                                          (("1"
                                            (typepred
                                             "1 / norm_1(n)(x) * x")
                                            (("1"
                                              (typepred "x")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (lemma "norm1_div")
                                            (("2"
                                              (inst -1 "x")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (assert) nil nil))
                nil)
               ("3" (assert) (("3" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (> const-decl "bool" reals nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (norm? const-decl "bool" norms nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (both_sides_div_pos_le1 formula-decl nil real_props nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (times_div_cancel2 formula-decl nil extra_real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (norm1_div formula-decl nil norms_equiv nil)
    (* const-decl "VectorN(length(v2))" matrices "matrices/")
    (Vector type-eq-decl nil matrices "matrices/")
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (real_div_nzreal_is_real application-judgement "real" reals nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (div_cancel2 formula-decl nil real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x skolem-const-decl "VectorN(n)" norms_equiv nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (equiv? const-decl "bool" norms_equiv nil))
   shostak))
 (standard_norm_TCC1 0
  (standard_norm_TCC1-1 nil 3742074613 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/"))
   nil
   (standard_norm subtype "norms_equiv.v" "(list_adt[real].cons?)")))
 (standard_norm_TCC2 0
  (standard_norm_TCC2-1 nil 3742074613 ("" (subtype-tcc) nil nil) nil
   nil
   (standard_norm subtype "norms_equiv.i"
    "naturalnumbers.below(list_props[real].length(norms_equiv.v))")))
 (standard_norm_TCC3 0
  (standard_norm_TCC3-1 nil 3742074613 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (standard_norm subtype
    "sum_vecs[norms_equiv.n].Standard_sum(norms_equiv.v, norms_equiv.i)"
    "(list_adt[real].cons?)")))
 (standard_norm_TCC4 0
  (standard_norm_TCC4-1 nil 3742074613 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil))
   nil
   (standard_norm subtype "norms_equiv.j" "below[length[real](v)]")))
 (standard_norm_TCC5 0
  (standard_norm_TCC5-1 nil 3742074613
   ("" (skeep)
    (("" (typepred "v") (("" (assert) (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (VectorN type-eq-decl nil matrices "matrices/"))
   nil
   (standard_norm subtype
    "vector_arithmetic.e(list_props[real].length(norms_equiv.v), norms_equiv.j)"
    "(list_adt[real].cons?)")))
 (standard_norm 0
  (standard_norm-1 nil 3742074774
   ("" (skeep)
    (("" (induct "i")
      (("1" (assert)
        (("1" (assert)
          (("1" (expand "Standard_sum" 1 1)
            (("1" (expand "sigma" 1)
              (("1" (expand "sigma" 1)
                (("1" (typepred "nn")
                  (("1" (expand "norm?" -1)
                    (("1" (flatten)
                      (("1" (inst -2 "e(length(v), 0)" "nth(v,0)")
                        (("1" (assert) nil nil) ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skeep)
        (("2" (expand "sigma" 1)
          (("2" (assert)
            (("2" (expand "Standard_sum" 1 1)
              (("2" (typepred "nn" 1)
                (("2" (expand "norm?" -1)
                  (("2" (flatten)
                    (("2"
                      (inst -4 "nth(v, 1 + jb) * e(length(v), 1 + jb)"
                       "Standard_sum(v, jb)")
                      (("1" (assert)
                        (("1"
                          (inst -2 "e(length(v), 1 + jb)"
                           "nth(v, 1 + jb)")
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (hide 2)
                        (("2"
                          (typepred
                           "nth[real](v, 1 + jb) * e(length[real](v), 1 + jb)"
                           "e(length[real](v), 1 + jb)")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (hide 2)
        (("3" (skeep)
          (("3" (assert)
            (("3" (typepred "m")
              (("3" (typepred "e(length[real](v), j)" "v")
                (("3" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil)
       ("5" (hide 2)
        (("5" (skeep)
          (("5" (assert)
            (("5" (typepred "Standard_sum[n](v, i)")
              (("5" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (v skolem-const-decl "VectorN(m)" norms_equiv nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (Standard_sum def-decl "{vv: list |
   (length(vv) = length(v) AND FORALL (j: upto(i)): nth(v, j) = nth(vv, j))
    AND FORALL (j: subrange(i + 1, length(v) - 1)): 0 = nth(vv, j)}"
     sum_vecs nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (subrange type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (m skolem-const-decl "posnat" norms_equiv nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (e def-decl "VectorN(m)" vector_arithmetic nil)
    (pred type-eq-decl nil defined_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T_low type-eq-decl nil sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (sigma def-decl "real" sigma "reals/")
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (Vector type-eq-decl nil matrices "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/")
    (jb skolem-const-decl "below(m)" norms_equiv nil)
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (odd? const-decl "bool" integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   shostak))
 (max_e_exists_TCC1 0
  (max_e_exists_TCC1-1 nil 3742205255 ("" (subtype-tcc) nil nil) nil
   nil
   (max_e_exists subtype "norms_equiv.k"
    "{ii: naturalnumbers.nat | reals.<(ii, norms_equiv.m)}")))
 (max_e_exists_TCC2 0
  (max_e_exists_TCC2-1 nil 3742205255 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (zero_vec def-decl "VectorN(m)" vector_arithmetic nil)
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   nil
   (max_e_exists subtype
    "vector_arithmetic.e(norms_equiv.m, norms_equiv.k)"
    "(list_adt[real].cons?)")))
 (max_e_exists 0
  (max_e_exists-1 nil 3742205256
   ("" (skeep)
    (("" (induct "i")
      (("1" (assert) nil nil)
       ("2" (skeep)
        (("2" (assert)
          (("2" (skeep)
            (("2" (case "nn(e(m,1+jb)) <= nn(e(m, j))")
              (("1" (inst 1 "j")
                (("1" (skeep)
                  (("1" (inst -3 "k") (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (inst 2 "1+jb")
                (("2" (assert)
                  (("2" (skeep)
                    (("2" (inst -2 "k")
                      (("1" (assert) nil nil) ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (typepred "e(m, j)") (("3" (assert) nil nil)) nil)
               ("4" (assert)
                (("4" (typepred "e(m, 1 + jb)")
                  (("4" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skeep)
        (("3" (typepred "e(m, k)") (("3" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((e def-decl "VectorN(m)" vector_arithmetic nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (m skolem-const-decl "posnat" norms_equiv nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (k skolem-const-decl "upto(1 + jb)" norms_equiv nil)
    (jb skolem-const-decl "below(m)" norms_equiv nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (k skolem-const-decl "upto(1 + jb)" norms_equiv nil)
    (NOT const-decl "[bool -> bool]" booleans nil))
   shostak))
 (max_e_TCC1 0
  (max_e_TCC1-1 nil 3742205594 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   nil
   (max_e subtype "vector_arithmetic.e(norms_equiv.m, norms_equiv.i)"
    "(list_adt[real].cons?)")))
 (max_e_TCC2 0
  (max_e_TCC2-1 nil 3742205594 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (* const-decl "VectorN(length(v2))" matrices "matrices/")
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (e def-decl "VectorN(m)" vector_arithmetic nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil
   (max_e subtype "vector_arithmetic.e(norms_equiv.m, norms_equiv.i)"
    "(list_adt[real].cons?)")))
 (max_e_TCC3 0
  (max_e_TCC3-1 nil 3742205594
   ("" (skeep)
    (("" (expand "nonempty?" 1)
      (("" (expand "empty?" -1)
        (("" (lemma "max_e_exists")
          (("" (inst -1 "m" "nn" "m-1")
            (("" (skeep)
              (("" (inst -2 "nn(e(m, j))")
                (("1" (expand "member" 1)
                  (("1" (skeep)
                    (("1" (inst -1 "i")
                      (("1" (assert) (("1" (inst 1 "j") nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "nn")
                  (("2" (expand "norm?" -1)
                    (("2" (flatten)
                      (("2" (inst -3 "e(m,j)")
                        (("2" (assert)
                          (("2" (inst -1 "e(m, j)")
                            (("2" (hide -2 -4 -5)
                              (("2"
                                (lemma "e_not_zero")
                                (("2"
                                  (inst -1 "m" "j")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (assert)
                  (("3" (typepred "e(m, j)") (("3" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty? const-decl "bool" sets nil)
    (max_e_exists formula-decl nil norms_equiv nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (e_not_zero formula-decl nil vector_arithmetic nil)
    (member const-decl "bool" sets nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nn skolem-const-decl "(norm?(m))" norms_equiv nil)
    (j skolem-const-decl "upto(m - 1)" norms_equiv nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (m skolem-const-decl "posnat" norms_equiv nil)
    (e def-decl "VectorN(m)" vector_arithmetic nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (norm? const-decl "bool" norms nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (empty? const-decl "bool" sets nil))
   nil
   (max_e subtype
    "{c: real_types.posreal | FORALL (i: naturalnumbers.below(norms_equiv.m)): booleans.AND(reals.<=(norms_equiv.nn(vector_arithmetic.e(norms_equiv.m, i)), c), EXISTS (i: naturalnumbers.below(norms_equiv.m)): c = norms_equiv.nn(vector_arithmetic.e(norms_equiv.m, i)))}"
    "(sets[posreal].nonempty?)")))
 (standard_norm_ineq 0
  (standard_norm_ineq-1 nil 3742206581
   ("" (skeep)
    (("" (skeep)
      (("" (lemma "standard_norm")
        (("" (inst -1 "m" "v" "nn" "i")
          (("" (lemma "sigma_le[nat]")
            ((""
              (inst -1 "LAMBDA (j: nat):
               IF j < m THEN abs(nth(v, j)) * nn(e(length(v), j))
               ELSE 0
               ENDIF" "LAMBDA (j: nat):
               IF j < m THEN abs(nth(v, j)) * max_e(m, nn)
               ELSE 0
               ENDIF" "i" "0")
              (("1" (split)
                (("1" (lemma "sigma_scal[nat]")
                  (("1"
                    (inst -1
                     "LAMBDA (j: nat): IF j < m THEN abs(nth(v, j)) ELSE 0 ENDIF"
                     "max_e(m, nn)" "i" "0")
                    (("1" (assert)
                      (("1"
                        (case "(LAMBDA (i_1: nat):
              max_e(m, nn) * IF i_1 < m THEN abs(nth(v, i_1)) ELSE 0 ENDIF) = (LAMBDA (j: nat):
               IF j < m THEN abs(nth(v, j)) * max_e(m, nn) ELSE 0 ENDIF)")
                        (("1" (assert) nil nil)
                         ("2" (hide-all-but 1)
                          (("2" (decompose-equality 1)
                            (("1" (lift-if)
                              (("1"
                                (split)
                                (("1" (assert) nil nil)
                                 ("2" (assert) nil nil))
                                nil))
                              nil)
                             ("2" (skeep) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil)
                         ("3" (hide -)
                          (("3" (skeep) (("3" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep) (("2" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (skeep)
                  (("2" (hide-all-but 1)
                    (("2" (lift-if)
                      (("2" (split)
                        (("1" (assert)
                          (("1" (assert)
                            (("1" (typepred "max_e(m, nn)")
                              (("1"
                                (inst -3 "n!1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (typepred "length(v)")
                                        (("1"
                                          (typepred "m")
                                          (("1"
                                            (case "NOT length(v) = m")
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (replace -1 1)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (mult-by
                                                   -6
                                                   "abs(nth(v, n!1))")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert)
                (("2" (skeep)
                  (("2" (assert)
                    (("2" (typepred "e(length[real](v), j)")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (skeep) (("3" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil) (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (m skolem-const-decl "posnat" norms_equiv nil)
    (v skolem-const-decl "VectorN(m)" norms_equiv nil)
    (e def-decl "VectorN(m)" vector_arithmetic nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (<= const-decl "bool" reals nil)
    (max_e const-decl "{c: posreal |
   FORALL (i: below(m)):
     nn(e(m, i)) <= c AND EXISTS (i: below(m)): c = nn(e(m, i))}"
     norms_equiv nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (T_high type-eq-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (both_sides_times_pos_le1_imp formula-decl nil extra_real_props
     nil)
    (subrange type-eq-decl nil integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma_scal formula-decl nil sigma "reals/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (sigma_le formula-decl nil sigma "reals/")
    (standard_norm formula-decl nil norms_equiv nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   shostak))
 (one_norm_sum 0
  (one_norm_sum-3 nil 3742208701
   ("" (induct "ll")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep)
      (("3" (case "cons2_var=null")
        (("1" (replace -1 1) (("1" (grind) nil nil)) nil)
         ("2" (assert)
          (("2" (lemma "sigma_first")
            (("2"
              (inst -1 "LAMBDA (j: nat):
               IF j < length(cons(cons1_var, cons2_var))
                 THEN abs(nth(cons(cons1_var, cons2_var), j))
               ELSE 0
               ENDIF" "length(cons(cons1_var, cons2_var)) - 1" "0")
              (("2" (assert)
                (("2" (expand "length" -1 4)
                  (("2" (expand "length" -1 1)
                    (("2" (assert)
                      (("2" (replace -1 2)
                        (("2" (lemma "norm_one_recurse")
                          (("2"
                            (inst -1 "length(cons2_var)+1"
                             "cons(cons1_var, cons2_var)")
                            (("1" (assert)
                              (("1"
                                (expand "length" -1 1)
                                (("1"
                                  (assert)
                                  (("1"
                                    (split)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (expand "norm_1" -2 1)
                                          (("1"
                                            (replace -2 2)
                                            (("1"
                                              (expand "norm_1" 2 1)
                                              (("1"
                                                (expand "nth" 2 1)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (lemma
                                                     "sigma_shift_T")
                                                    (("1"
                                                      (expand
                                                       "length"
                                                       2
                                                       1)
                                                      (("1"
                                                        (expand
                                                         "length"
                                                         -4
                                                         3)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (inst
                                                             -1
                                                             "(LAMBDA (j: nat):
               IF j=0 THEN 0
               ELSIF (j/=0 AND j-1 < length(cons2_var)) THEN abs(nth(cons2_var, j-1))
               ELSE 0
               ENDIF)"
                                                             "length(cons2_var) - 1"
                                                             "0"
                                                             "1")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (case
                                                                 "NOT (LAMBDA (j: nat):
               IF j < length(cons2_var) THEN abs(nth(cons2_var, j))
               ELSE 0
               ENDIF) = (LAMBDA (i: nat):
               IF i < length(cons2_var) THEN abs(nth(cons2_var, i))
               ELSE 0 ENDIF)")
                                                                (("1"
                                                                  (propax)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (replace
                                                                   -1
                                                                   -6)
                                                                  (("2"
                                                                    (case
                                                                     "NOT sigma(1, length(cons2_var),
            (LAMBDA (j: nat):
               IF j = 0 THEN 0
               ELSIF j - 1 < length(cons2_var)
                 THEN abs(nth(cons2_var, j - 1))
               ELSE 0
               ENDIF)) = norm_1(cons2_var)")
                                                                    (("1"
                                                                      (assert)
                                                                      nil
                                                                      nil)
                                                                     ("2"
                                                                      (hide
                                                                       -7)
                                                                      (("2"
                                                                        (hide
                                                                         -2)
                                                                        (("2"
                                                                          (lemma
                                                                           "sigma_eq[nat]")
                                                                          (("2"
                                                                            (inst
                                                                             -1
                                                                             "(LAMBDA (j: nat):
               IF j = 0 THEN 0
               ELSIF j - 1 < length(cons2_var)
                 THEN abs(nth(cons2_var, j - 1))
               ELSE 0
               ENDIF)"
                                                                             "(LAMBDA (j: nat):
              IF j < length(cons(cons1_var, cons2_var))
                THEN abs(nth(cons(cons1_var, cons2_var), j))
              ELSE 0
              ENDIF)"
                                                                             "length[real](cons2_var)"
                                                                             "1")
                                                                            (("1"
                                                                              (assert)
                                                                              (("1"
                                                                                (skeep)
                                                                                (("1"
                                                                                  (hide
                                                                                   -)
                                                                                  (("1"
                                                                                    (typepred
                                                                                     "n!1")
                                                                                    (("1"
                                                                                      (assert)
                                                                                      (("1"
                                                                                        (expand
                                                                                         "length"
                                                                                         1
                                                                                         1)
                                                                                        (("1"
                                                                                          (expand
                                                                                           "nth"
                                                                                           1
                                                                                           2)
                                                                                          (("1"
                                                                                            (propax)
                                                                                            nil
                                                                                            nil))
                                                                                          nil))
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil)
                                                                             ("2"
                                                                              (skeep)
                                                                              (("2"
                                                                                (assert)
                                                                                nil
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("3"
                                                                      (skeep)
                                                                      (("3"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (skeep)
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2"
                                (expand "length" 1 1)
                                (("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (assert) nil nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (norm_one_recurse formula-decl nil norms nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (sigma_eq formula-decl nil sigma "reals/")
    (subrange type-eq-decl nil integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (sigma_shift_T formula-decl nil sigma "reals/")
    (nnreal_plus_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons2_var skolem-const-decl "list[real]" norms_equiv nil)
    (cons1_var skolem-const-decl "real" norms_equiv nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (sigma_first formula-decl nil sigma "reals/")
    (abs def-decl "{l: list | length(l) = length(ll)}" norms nil)
    (entry_sum def-decl "real" norms nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (< const-decl "bool" reals nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (length def-decl "nat" list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (sigma def-decl "real" sigma "reals/")
    (T_high type-eq-decl nil sigma "reals/")
    (T_low type-eq-decl nil sigma "reals/")
    (<= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil)
  (one_norm_sum-2 nil 3742208655
   ("" (induct "ll")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (assert)
      (("3" (skeep)
        (("3" (assert)
          (("3" (case "cons2_var=null")
            (("1" (hide -2)
              (("1" (replace -1 1)
                (("1" (expand "length" 1)
                  (("1" (expand "length" 1)
                    (("1" (expand "norm_1" 1)
                      (("1" (expand "entry_sum" 1)
                        (("1" (expand "length" 1)
                          (("1" (assert)
                            (("1" (lift-if)
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (expand "length" 2 1)
                (("2" (lemma "sigma_last")
                  (("2"
                    (inst -1 "(LAMBDA (j: nat):
                     IF j < length(cons(cons1_var, cons2_var))-1
                       THEN abs(nth(cons(cons1_var, cons2_var), j))
                     ELSE 0
                     ENDIF)" "length[real](cons2_var)" "0")
                    (("1" (assert)
                      (("1" (assert)
                        (("1" (expand "length" -1 6)
                          (("1" (postpone) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (postpone) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (postpone) nil nil))
    nil)
   nil nil)
  (one_norm_sum-1 nil 3742208137
   ("" (induct "ll")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (assert)
      (("3" (skeep)
        (("3" (assert)
          (("3" (case "cons2_var=null")
            (("1" (hide -2)
              (("1" (replace -1 1)
                (("1" (expand "length" 1)
                  (("1" (expand "length" 1)
                    (("1" (expand "norm_1" 1)
                      (("1" (expand "entry_sum" 1)
                        (("1" (expand "length" 1)
                          (("1" (assert)
                            (("1" (lift-if)
                              (("1"
                                (assert)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (expand "length" 2 1)
                (("2" (lemma "sigma_last")
                  (("2"
                    (inst -1 "(LAMBDA (j: nat):
               IF j < length(cons(cons1_var, cons2_var))
                 THEN abs(nth(cons(cons1_var, cons2_var), j))
               ELSE 0
               ENDIF)" "1 + length[real](cons2_var)" "0")
                    (("1" (assert)
                      (("1" (assert)
                        (("1" (expand "length" -1 6)
                          (("1" (assert) (("1" (postpone) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (postpone) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (postpone) nil nil))
    nil)
   nil shostak))
 (standard_max_e_one_norm_TCC1 0
  (standard_max_e_one_norm_TCC1-1 nil 3742209197
   ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/"))
   nil
   (standard_max_e_one_norm subtype "norms_equiv.v"
    "(list_adt[real].cons?)")))
 (standard_max_e_one_norm_TCC2 0
  (standard_max_e_one_norm_TCC2-1 nil 3742209197
   ("" (subtype-tcc) nil nil) nil nil
   (standard_max_e_one_norm subtype
    "(number_fields.-)(norms_equiv.m, 1)"
    "naturalnumbers.below(list_props[real].length(norms_equiv.v))")))
 (standard_max_e_one_norm_TCC3 0
  (standard_max_e_one_norm_TCC3-1 nil 3742209197
   ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/")
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (standard_max_e_one_norm subtype
    "sum_vecs[norms_equiv.n].Standard_sum(norms_equiv.v, (number_fields.-)(norms_equiv.m, 1))"
    "(list_adt[real].cons?)")))
 (standard_max_e_one_norm 0
  (standard_max_e_one_norm-1 nil 3742209138
   ("" (skeep)
    (("" (lemma "standard_norm_ineq")
      (("" (inst -1 "m" "v" "nn" "_")
        (("" (lemma "one_norm_sum")
          (("" (inst -2 "m-1")
            (("" (inst -1 "v")
              (("" (typepred "v")
                (("" (replace -2 -3)
                  (("" (assert)
                    (("" (case "NOT norm_1(v) = norm_1(m)(v)")
                      (("1" (expand "norm_1" 1 2)
                        (("1" (propax) nil nil)) nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((standard_norm_ineq formula-decl nil norms_equiv nil)
    (one_norm_sum formula-decl nil norms_equiv nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (norm? const-decl "bool" norms nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   shostak))
 (norm_to_max_e_one_norm 0
  (norm_to_max_e_one_norm-2 nil 3742217594
   ("" (skeep)
    (("" (lemma "standard_max_e_one_norm")
      (("" (inst -1 "m" "v" "nn")
        (("" (lemma "Standard_id")
          (("" (inst -1 "m" "v") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((standard_max_e_one_norm formula-decl nil norms_equiv nil)
    (Standard_id formula-decl nil sum_vecs nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (norm? const-decl "bool" norms nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   nil)
  (norm_to_max_e_one_norm-1 nil 3742217574 ("" (postpone) nil nil) nil
   shostak))
 (unit_sphere_norm_1_closed_bounded 0
  (unit_sphere_norm_1_closed_bounded-1 nil 3742290695
   ("" (split)
    (("1" (expand "norm_1_closed?")
      (("1" (skeep)
        (("1" (expand "unit_sphere_norm_1")
          (("1" (expand "norm_1_convergence?")
            (("1" (lemma "reverse_triag")
              (("1" (inst -2 "abs(norm_1(n)(L)-1)/2")
                (("1" (skeep)
                  (("1" (inst -2 "N+1")
                    (("1" (inst -1 "n" "V(N+1)" "L" "norm_1(n)")
                      (("1" (assert)
                        (("1" (typepred "V(1+N)")
                          (("1" (typepred "V")
                            (("1" (hide -2 -3)
                              (("1"
                                (inst -1 "1+N")
                                (("1"
                                  (expand "unit_sphere_norm_1")
                                  (("1"
                                    (replace -1 -2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (case
                                         "NOT abs(1 - norm_1(n)(L)) < abs(norm_1(n)(L) - 1) / 2")
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (assert)
                                          (("2"
                                            (hide -2 -3 -4)
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (expand "norm_1_bounded?")
      (("2" (inst 1 "2")
        (("2" (skeep)
          (("2" (typepred "v")
            (("2" (expand "unit_sphere_norm_1")
              (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((norm_1_bounded? const-decl "bool" norm_1_defs nil)
    (norm_1_closed? const-decl "bool" norm_1_defs nil)
    (unit_sphere_norm_1 const-decl "domain" norms_equiv nil)
    (reverse_triag formula-decl nil norms nil)
    (domain type-eq-decl nil domain_vec2real_def nil)
    (vec_seq type-eq-decl nil domain_vec2real_def nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil)
    (< const-decl "bool" reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (above nonempty-type-eq-decl nil integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (norm? const-decl "bool" norms nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (L skolem-const-decl "VectorN(n)" norms_equiv nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (nnreal_div_posreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (norm_1_convergence? const-decl "bool" norm_1_defs nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil))
   shostak))
 (norm_achieve_max_usn1_TCC1 0
  (norm_achieve_max_usn1_TCC1-1 nil 3742291375
   ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (domain type-eq-decl nil domain_vec2real_def nil)
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/")
    (n formal-const-decl "posnat" norms_equiv nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_glob_maximizer? const-decl "bool" unconstrained_global_extrema
     nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil)
    (unit_sphere_norm_1 const-decl "domain" norms_equiv nil)
    (is_glob_max? const-decl "bool" unconstrained_global_extrema nil))
   nil
   (norm_achieve_max_usn1 subtype "norms_equiv.p"
    "(list_adt[real].cons?)")))
 (norm_achieve_max_usn1 0
  (norm_achieve_max_usn1-2 nil 3742291817
   ("" (skeep)
    (("" (lemma "max_on_closed_bounded")
      ((""
        (inst -1 " unit_sphere_norm_1" "LAMBDA (v: VectorN(n)): nn(v)")
        (("1" (assert)
          (("1" (split)
            (("1" (propax) nil nil)
             ("2" (hide 2)
              (("2" (expand "norm_1_contD?")
                (("2" (skeep)
                  (("2" (expand "norm_1_contp?")
                    (("2" (skeep)
                      (("2" (inst 1 "eps/max_e(n,nn)")
                        (("2" (lemma "reverse_triag")
                          (("2" (lemma "norm_to_max_e_one_norm")
                            (("2" (skeep)
                              (("2"
                                (inst -2 "n" "x" "p" "nn")
                                (("2"
                                  (inst -1 "n" "x-p" "nn")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (mult-by -3 "max_e(n, nn)")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred "x-p" "x" "p")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "max" -)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (skeep)
            (("2" (typepred "v") (("2" (assert) nil nil)) nil)) nil))
          nil)
         ("3" (hide 2)
          (("3" (lemma "unit_sphere_norm_1_closed_bounded")
            (("3" (flatten)
              (("3" (assert)
                (("3" (expand "nonempty?")
                  (("3" (expand "empty?" -3)
                    (("3" (inst -3 "e(n,0)")
                      (("1" (expand "member" 1)
                        (("1" (expand "unit_sphere_norm_1")
                          (("1" (expand "e" 1)
                            (("1" (assert)
                              (("1"
                                (lift-if)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "norm_1" 1)
                                    (("1"
                                      (lemma "norm_one_recurse")
                                      (("1"
                                        (inst
                                         -1
                                         "n"
                                         "cons(1, zero_vec(n - 1))")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand "norm_1" -2 1)
                                                (("1"
                                                  (replace -2 1)
                                                  (("1"
                                                    (typepred
                                                     "norm_1(n-1)")
                                                    (("1"
                                                      (expand
                                                       "norm?"
                                                       -1)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (inst
                                                           -3
                                                           "zero_vec(n - 1)")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand "length" 1)
                                          (("2"
                                            (typepred
                                             "length(zero_vec(n - 1))")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((n formal-const-decl "posnat" norms_equiv nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (max_on_closed_bounded formula-decl nil
     norm_1_extreme_value_theorem nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (norm_one_recurse formula-decl nil norms nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs_nat formula-decl nil abs_lems "reals/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (zero_vec def-decl "VectorN(m)" vector_arithmetic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (unit_sphere_norm_1_closed_bounded formula-decl nil norms_equiv
     nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (reverse_triag formula-decl nil norms nil)
    (Vector type-eq-decl nil matrices "matrices/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (- const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (x skolem-const-decl "(unit_sphere_norm_1)" norms_equiv nil)
    (p skolem-const-decl "(unit_sphere_norm_1)" norms_equiv nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (div_cancel2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (norm_to_max_e_one_norm formula-decl nil norms_equiv nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (e def-decl "VectorN(m)" vector_arithmetic nil)
    (max_e const-decl "{c: posreal |
   FORALL (i: below(m)):
     nn(e(m, i)) <= c AND EXISTS (i: below(m)): c = nn(e(m, i))}"
     norms_equiv nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (norm_1_contp? const-decl "bool" norm_1_defs nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (norm_1_contD? const-decl "bool" norm_1_defs nil)
    (norm? const-decl "bool" norms nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (vec2real_f type-eq-decl nil domain_vec2real_def nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (domain type-eq-decl nil domain_vec2real_def nil)
    (norm_1_closed? const-decl "bool" norm_1_defs nil)
    (unit_sphere_norm_1 const-decl "domain" norms_equiv nil)
    (norm_1_bounded? const-decl "bool" norm_1_defs nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil)
  (norm_achieve_max_usn1-1 nil 3742291376
   ("" (lemma "max_on_closed_bounded")
    (("" (skeep)
      (("" (inst -1 "unit_sphere_norm_1(n)" "nn")
        (("1" (split)
          (("1" (propax) nil nil)
           ("2" (hide 2)
            (("2" (expand "norm_1_contD?" 1)
              (("2" (skeep)
                (("2" (expand "norm_1_contp?")
                  (("2" (skeep)
                    (("2" (lemma "norm_to_max_e_one_norm")
                      (("2" (inst 1 "eps/max_e(n,nn)")
                        (("2" (skeep)
                          (("2" (lemma "reverse_triag")
                            (("2" (inst -1 "n" "x" "p" "nn")
                              (("2"
                                (inst -2 "n" "x - p" "nn")
                                (("1"
                                  (mult-by -3 "max_e(n, nn)")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (typepred "x-p" "x" "p")
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "max" -)
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (postpone) nil nil) ("3" (postpone) nil nil))
        nil))
      nil))
    nil)
   nil shostak))
 (norm_achieve_min_usn1_TCC1 0
  (norm_achieve_min_usn1_TCC1-1 nil 3742294705
   ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (norm? const-decl "bool" norms nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (domain type-eq-decl nil domain_vec2real_def nil)
    (+ const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (* const-decl "VectorN(length(v2))" matrices "matrices/")
    (n formal-const-decl "posnat" norms_equiv nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (is_glob_minimizer? const-decl "bool" unconstrained_global_extrema
     nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (norm_1 const-decl "[(cons?) -> nonneg_real]" norms nil)
    (unit_sphere_norm_1 const-decl "domain" norms_equiv nil)
    (is_glob_min? const-decl "bool" unconstrained_global_extrema nil))
   nil
   (norm_achieve_min_usn1 subtype "norms_equiv.p"
    "(list_adt[real].cons?)")))
 (norm_achieve_min_usn1 0
  (norm_achieve_min_usn1-2 nil 3742293320
   ("" (skeep)
    (("" (lemma "min_on_closed_bounded")
      ((""
        (inst -1 " unit_sphere_norm_1" "LAMBDA (v: VectorN(n)): nn(v)")
        (("1" (assert)
          (("1" (split)
            (("1" (propax) nil nil)
             ("2" (hide 2)
              (("2" (expand "norm_1_contD?")
                (("2" (skeep)
                  (("2" (expand "norm_1_contp?")
                    (("2" (skeep)
                      (("2" (inst 1 "eps/max_e(n,nn)")
                        (("2" (lemma "reverse_triag")
                          (("2" (lemma "norm_to_max_e_one_norm")
                            (("2" (skeep)
                              (("2"
                                (inst -2 "n" "x" "p" "nn")
                                (("2"
                                  (inst -1 "n" "x-p" "nn")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (mult-by -3 "max_e(n, nn)")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred "x-p" "x" "p")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "max" -)
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (hide 2)
          (("2" (skeep)
            (("2" (typepred "v") (("2" (assert) nil nil)) nil)) nil))
          nil)
         ("3" (hide 2)
          (("3" (lemma "unit_sphere_norm_1_closed_bounded")
            (("3" (flatten)
              (("3" (assert)
                (("3" (expand "nonempty?")
                  (("3" (expand "empty?" -3)
                    (("3" (inst -3 "e(n,0)")
                      (("1" (expand "member" 1)
                        (("1" (expand "unit_sphere_norm_1")
                          (("1" (expand "e" 1)
                            (("1" (assert)
                              (("1"
                                (lift-if)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "norm_1" 1)
                                    (("1"
                                      (lemma "norm_one_recurse")
                                      (("1"
                                        (inst
                                         -1
                                         "n"
                                         "cons(1, zero_vec(n - 1))")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (split)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand "norm_1" -2 1)
                                                (("1"
                                                  (replace -2 1)
                                                  (("1"
                                                    (typepred
                                                     "norm_1(n-1)")
                                                    (("1"
                                                      (expand
                                                       "norm?"
                                                       -1)
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (inst
                                                           -3
                                                           "zero_vec(n - 1)")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (propax) nil nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (expand "length" 1)
                                          (("2"
                                            (typepred
                                             "length(zero_vec(n - 1))")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((n formal-const-decl "posnat" norms_equiv nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (min_on_closed_bounded formula-decl nil
     norm_1_extreme_value_theorem nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (norm_one_recurse formula-decl nil norms nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs_nat formula-decl nil abs_lems "reals/")
    (posreal_plus_nnreal_is_posreal application-judgement "posreal"
     real_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (zero_vec def-decl "VectorN(m)" vector_arithmetic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (unit_sphere_norm_1_closed_bounded formula-decl nil norms_equiv
     nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (reverse_triag formula-decl nil norms nil)
    (Vector type-eq-decl nil matrices "matrices/")
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (- const-decl "VectorN(max(length(v1), length(v2)))" matrices
       "matrices/")
    (x skolem-const-decl "(unit_sphere_norm_1)" norms_equiv nil)
    (p skolem-const-decl "(unit_sphere_norm_1)" norms_equiv nil)
    (both_sides_times_pos_lt1 formula-decl nil real_props nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (div_cancel2 formula-decl nil real_props nil)
    (nonzero_real nonempty-type-eq-decl nil reals nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnreal_times_nnreal_is_nnreal application-judgement "nnreal"
     real_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (norm_to_max_e_one_norm formula-decl nil norms_equiv nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (e def-decl "VectorN(m)" vector_arithmetic nil)
    (max_e const-decl "{c: posreal |
   FORALL (i: below(m)):
     nn(e(m, i)) <= c AND EXISTS (i: below(m)): c = nn(e(m, i))}"
     norms_equiv nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (norm_1_contp? const-decl "bool" norm_1_defs nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (norm_1_contD? const-decl "bool" norm_1_defs nil)
    (norm? const-decl "bool" norms nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (vec2real_f type-eq-decl nil domain_vec2real_def nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (domain type-eq-decl nil domain_vec2real_def nil)
    (norm_1_closed? const-decl "bool" norm_1_defs nil)
    (unit_sphere_norm_1 const-decl "domain" norms_equiv nil)
    (norm_1_bounded? const-decl "bool" norm_1_defs nil)
    (set type-eq-decl nil sets nil)
    (nonempty? const-decl "bool" sets nil))
   nil)
  (norm_achieve_min_usn1-1 nil 3742293203 ("" (postpone) nil nil) nil
   shostak))
 (equiv_norm 0
  (equiv_norm-1 nil 3742294060
   ("" (skeep)
    (("" (lemma "equiv_unit_imp_equiv")
      (("" (lemma "equiv_1norm_imp_equiv")
        (("" (split)
          (("1" (inst -1 "n1" "n2") nil nil)
           ("2" (skeep)
            (("2" (hide 2)
              (("2" (inst -1 "norm")
                (("2" (lemma "norm_achieve_max_usn1")
                  (("2" (lemma "norm_achieve_min_usn1")
                    (("2" (inst -1 "norm")
                      (("2" (inst -2 "norm")
                        (("2" (skeep)
                          (("2" (skeep)
                            (("2" (split)
                              (("1"
                                (assert)
                                (("1"
                                  (lemma "equiv_trans")
                                  (("1"
                                    (inst -1 "norm" "norm_1(n)")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (inst 1 "c" "c!1")
                                (("1"
                                  (skeep)
                                  (("1"
                                    (typepred "x")
                                    (("1"
                                      (replace -3 1)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (split)
                                          (("1"
                                            (hide -4 -6 -7)
                                            (("1"
                                              (expand
                                               "is_glob_min?"
                                               -4)
                                              (("1"
                                                (skeep)
                                                (("1"
                                                  (inst -6 "x")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       "unit_sphere_norm_1")
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "is_glob_max?" -8)
                                            (("2"
                                              (skeep)
                                              (("2"
                                                (inst -9 "x")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (expand
                                                     "unit_sphere_norm_1")
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (hide -1 -2 -3 -4 -5)
                                    (("2"
                                      (case "NOT norm(p!1) = 0")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (assert)
                                        (("2"
                                          (typepred "norm")
                                          (("2"
                                            (expand "norm?" -1)
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (inst -3 "p!1")
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (typepred "p!1")
                                                    (("2"
                                                      (expand
                                                       "unit_sphere_norm_1")
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (typepred
                                                           "norm_1(n)")
                                                          (("2"
                                                            (expand
                                                             "norm?"
                                                             -1)
                                                            (("2"
                                                              (flatten)
                                                              (("2"
                                                                (inst
                                                                 -3
                                                                 "p!1")
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (assert)
                                  (("3"
                                    (typepred "norm" "p")
                                    (("3"
                                      (expand "unit_sphere_norm_1")
                                      (("3"
                                        (typepred "norm_1(n)")
                                        (("3"
                                          (expand "norm?" -2)
                                          (("3"
                                            (expand "norm?" -1)
                                            (("3"
                                              (flatten)
                                              (("3"
                                                (inst -3 "p")
                                                (("3"
                                                  (inst -7 "p")
                                                  (("3"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((equiv_unit_imp_equiv formula-decl nil norms_equiv nil)
    (n formal-const-decl "posnat" norms_equiv nil)
    (norm? const-decl "bool" norms nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (norm_achieve_max_usn1 formula-decl nil norms_equiv nil)
    (listn_0 name-judgement "listn[real](0)" vector_arithmetic nil)
    (equiv_trans formula-decl nil norms_equiv nil)
    (norm_1 const-decl "(norm?(m))" norms nil)
    (is_glob_min? const-decl "bool" unconstrained_global_extrema nil)
    (unit_sphere_norm_1 const-decl "domain" norms_equiv nil)
    (domain type-eq-decl nil domain_vec2real_def nil)
    (is_glob_max? const-decl "bool" unconstrained_global_extrema nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (VectorN type-eq-decl nil matrices "matrices/")
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (c!1 skolem-const-decl "real" norms_equiv nil)
    (c skolem-const-decl "real" norms_equiv nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (norm_achieve_min_usn1 formula-decl nil norms_equiv nil)
    (equiv_1norm_imp_equiv formula-decl nil norms_equiv nil))
   shostak)))
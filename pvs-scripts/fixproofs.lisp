(defun symbol-or-number (s)
  (or (symbolp s) (numberp s)))

(defun fixproof-equal (s1 s2)
  (and (symbolp s1)
       (string-equal s1 s2)))

;; s --> "s"
(defun fixproof-symbol (s &key but (test #'symbolp))
  (let ((but (if (listp but) but (list but))))
    (if (and (funcall test s) (not (member s but)))
	(format nil "~s" s)
      s)))

;; s | (s1 .. sn) --> "s" | ("s1" .. "sn")
(defun fixproof-symbol-or-symbols (s &key but (test #'symbolp))
  (if (listp s)
      (mapcar #'(lambda (x) (fixproof-symbol x :but but :test test)) s)
    (fixproof-symbol s :but but :test test)))

;; (step NAME ..) --> (step "name" ..)
;; (LEMMA NAME &OPTIONAL SUBST)
;; (USE/$ LEMMA-NAME &OPTIONAL SUBST (IF-MATCH BEST) (INSTANTIATOR INST?) ...)
;; (REWRITE/$ LEMMA-OR-FNUM &OPTIONAL (FNUMS *) SUBST (TARGET-FNUMS *) ...)
;; (EXPAND FUNCTION-NAME &OPTIONAL (FNUM *) OCCURRENCE ...)
;; (INDUCT/$ VAR &OPTIONAL (FNUM 1) NAME)
;; (LABEL LABEL FNUMS &OPTIONAL PUSH?)
(defun fix-name (s-expr) 
  (cons (car s-expr)
	(cons (fixproof-symbol (cadr s-expr))
	      (cddr s-expr))))

;; (step NAME1 .. NAMEN) --> (step "name1" .. "namen")
;; (EXPAND*/$ &REST NAMES)
;; (AUTO-REWRITE &REST NAMES)
;; (CASE &REST FORMULAS)
;; (HIDE &REST FNUMS)
(defun fix-names (s-expr &key but)
  (cons (car s-expr)
	(mapcar #'(lambda (s) (fixproof-symbol s :but but))
		(cdr s-expr))))

;; (step NAME | (NAME1 .. NAMEN)) --> (step "name1" .. "namen")
;; (TYPEPRED &REST EXPRS)
(defun fix-name-or-names (s-expr)
  (cons (car s-expr)
	(let ((rest (if (listp (cadr s-expr)) (cadr s-expr) (cdr s-expr))))
	  (mapcar #'fixproof-symbol
		  rest))))

;; (step FNUM NAME1 .. NAMEN) --> (step fnum "name1" .. "namen")
;; (INST/$ FNUM &REST TERMS)
;; (INST-CP/$ FNUM &REST TERMS)
(defun fix-fnum-names-or-numbers (s-expr)
  (cons (car s-expr)
	(cons (cadr s-expr)
	      (mapcar #'(lambda (s) (fixproof-symbol s :but '_ :test #'symbol-or-number))
		      (cddr s-expr)))))

;; (step FNUM NAME | (NAME1 .. NAMEN) ..) --> (step fnum "name | ("name1" .. "namen") ..)
;; (SKOLEM FNUM CONSTANTS &OPTIONAL SKOLEM-TYPEPREDS? DONT-SIMPLIFY?)
(defun fix-fnum-name-or-names (s-expr)
  (cons (car s-expr)
	(cons (cadr s-expr)
	      (cons (fixproof-symbol-or-symbols (caddr s-expr))
		    (cdddr s-expr)))))


;; (step NAME NAME | (NAME1 .. NAMEN) ..) --> (step name "name | ("name1" .. "namen") ..)
;; (MEASURE-INDUCT/$ MEASURE VARS &OPTIONAL (FNUM 1) ORDER SKOLEM-TYPEPREDS?)
(defun fix-name-name-or-names (s-expr)
  (cons (car s-expr)
	(cons (fixproof-symbol (cadr s-expr))
	      (cons (fixproof-symbol-or-symbols (caddr s-expr))
		    (cdddr s-expr)))))

;; (step NAME NAME ..) --> (step "name" "name" ..)
;; (GENERALIZE/$ TERM VAR &OPTIONAL GTYPE (FNUMS *) (SUBTERMS-ONLY? T))
(defun fix-name-name (s-expr) 
  (cons (car s-expr)
	(cons (fixproof-symbol (cadr s-expr))
	      (cons (fixproof-symbol (caddr s-expr))
		    (cdddr s-expr)))))

(defun fix-proofs (s-expr)
  (if (listp s-expr)
      (cond ((member (car s-expr) '("lemma" "use" "rewrite" "expand" "induct" "label") :test #'fixproof-equal)
	     (fix-name s-expr))
	    ((member (car s-expr) '("expand*" "case" "auto-rewrite") :test #'fixproof-equal)
	     (fix-names s-expr))
	    ((fixproof-equal (car s-expr) "hide")
	     (fix-names s-expr :but '(+ - *)))
	    ((fixproof-equal (car s-expr) "typepred") 
	     (fix-name-or-names s-expr))
	    ((member (car s-expr) '("inst" "inst-cp") :test #'fixproof-equal) 
	     (fix-fnum-names-or-numbers s-expr))
	    ((fixproof-equal (car s-expr) "skolem") 
	     (fix-fnum-name-or-names s-expr))
	    ((fixproof-equal (car s-expr) "measure-induct") 
	     (fix-name-name-or-names s-expr))
	    ((fixproof-equal (car s-expr) "generalize") 
	     (fix-name-name s-expr))
	    (t (mapcar #'fix-proofs s-expr)))
    s-expr))

(defun fix-file (name)
  (let* ((in-name name)
	 (out-name (format nil "~a.new" in-name)))
    (with-open-file
     (in-file (merge-pathnames in-name) :direction :input)
     (with-open-file
      (out-file (merge-pathnames out-name) :direction :output
		:if-exists :supersede)
      (let ((s-expr (read in-file)))
	(format out-file "~s" (fix-proofs s-expr)))))))

(defun fix-files (names)
  (let ((names (if (listp names) names (list names))))
    (loop for name in names
	  do (fix-file name))))
